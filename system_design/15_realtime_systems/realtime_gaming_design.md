# Realtime Gaming システム設計

## 1. システム概要

### 目的と主要機能

リアルタイムゲームシステムは、低レイテンシでのゲーム状態の同期とマルチプレイヤーゲームを可能にするシステムです。

**主要機能**:
- ゲーム状態の同期
- プレイヤーアクションの処理
- マッチメイキング
- ゲームサーバーの管理
- アンチチート
- リプレイ機能

### ユーザースケール

- **月間アクティブユーザー（MAU）**: 約5億人
- **日間アクティブユーザー（DAU）**: 約2億人
- **1日の同時接続数**: 約5,000万人（ピーク時）
- **1日のマッチ数**: 約1億マッチ
- **1秒あたりのアクション数**: 約1,000万アクション/秒（ピーク時）

### 主要なユースケース

1. **ゲーム状態同期**: プレイヤー間でのゲーム状態の同期
2. **マッチメイキング**: 適切なマッチの検索
3. **ゲームサーバー**: ゲームロジックの実行
4. **アンチチート**: 不正行為の検出
5. **リプレイ**: ゲームのリプレイ機能

## 2. 機能要件

### コア機能

1. **ゲーム状態同期**
   - クライアント予測
   - サーバーオーソリティ
   - 状態の補間

2. **マッチメイキング**
   - スキルベースマッチング
   - 地理的マッチング
   - 待機時間の最小化

3. **ゲームサーバー**
   - ゲームロジックの実行
   - 物理演算
   - 衝突検出

4. **アンチチート**
   - サーバーサイド検証
   - 異常検出
   - レート制限

### 非機能要件

- **可用性**: 99.9%以上
- **パフォーマンス**:
  - ゲーム状態更新: < 50ms
  - マッチメイキング: < 10秒
  - ゲームサーバー接続: < 2秒
- **スケーラビリティ**: 水平スケーリング可能

### 優先順位付け

1. **P0（必須）**: ゲーム状態同期、マッチメイキング、ゲームサーバー
2. **P1（重要）**: アンチチート、リプレイ機能
3. **P2（望ましい）**: 高度な分析機能、統計・リーダーボード

## 3. システムアーキテクチャ

### 高レベルアーキテクチャ

```
┌─────────────┐
│   Client    │ (Game Client)
└──────┬──────┘
       │ UDP/TCP
       │
┌──────▼─────────────────────────────────────┐
│         Load Balancer                       │
└──────┬──────────────────────────────────────┘
       │
       ├─────────────────┬──────────────────┐
       │                 │                  │
┌──────▼──────┐   ┌──────▼──────┐   ┌──────▼──────┐
│  Match      │   │  Game       │   │  Anti-Cheat │
│  Making     │   │  Server     │   │  Service    │
│  Service    │   │  Manager    │   │             │
└──────┬──────┘   └──────┬──────┘   └──────┬──────┘
       │                 │                  │
       ├─────────────────┴──────────────────┤
       │                                     │
┌──────▼─────────────────────────────────────▼──────┐
│              Game Servers                          │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐        │
│  │ Game     │  │ Game     │  │ Game     │        │
│  │ Server 1 │  │ Server 2 │  │ Server N │        │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘        │
└───────┼──────────────┼──────────────┼──────────────┘
        │             │             │
┌───────▼─────────────▼─────────────▼──────┐
│   Database   │   Cache       │  Message     │
│   (Sharded)  │   (Redis)     │  Queue       │
└──────────────┴───────────────┴──────────────┘
```

### コンポーネントの説明

1. **Match Making Service**: 適切なマッチの検索
2. **Game Server Manager**: ゲームサーバーの管理
3. **Game Servers**: ゲームロジックの実行
4. **Anti-Cheat Service**: 不正行為の検出
5. **Database**: ゲーム状態、マッチ情報の永続化
6. **Cache**: 頻繁にアクセスされるデータのキャッシング
7. **Message Queue**: 非同期処理（リプレイ保存など）

### データフロー

#### ゲーム状態同期のフロー

```
1. Client → Game Server: プレイヤーアクション送信
2. Game Server:
   a. アクションを検証
   b. ゲーム状態を更新
   c. 更新された状態を全プレイヤーに送信
3. Client: ゲーム状態を受信して表示
```

## 4. データモデル設計

### 主要なエンティティ

#### Matches テーブル

```sql
CREATE TABLE matches (
    match_id BIGINT PRIMARY KEY,
    game_id BIGINT NOT NULL,
    game_server_id BIGINT NOT NULL,
    status ENUM('waiting', 'in_progress', 'completed', 'cancelled') DEFAULT 'waiting',
    started_at TIMESTAMP,
    ended_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (game_id) REFERENCES games(game_id),
    INDEX idx_game_id_status (game_id, status),
    INDEX idx_game_server_id (game_server_id)
) ENGINE=InnoDB;
```

#### Game_States テーブル

```sql
CREATE TABLE game_states (
    state_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    match_id BIGINT NOT NULL,
    game_state JSON NOT NULL,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (match_id) REFERENCES matches(match_id),
    INDEX idx_match_id_timestamp (match_id, timestamp DESC)
) ENGINE=InnoDB;
```

### データベース選択の理由

- **RDBMS（MySQL/PostgreSQL）**: 
  - 理由: ACID特性が必要、複雑なクエリ（JOIN、集計）、トランザクション処理
  - 用途: マッチ、ゲーム状態の永続化
- **Redis**:
  - 理由: リアルタイムデータ、ゲーム状態のキャッシング
  - 用途: ゲーム状態、マッチメイキングキュー

## 5. API設計

### 主要なAPIエンドポイント

#### マッチメイキング

```
POST /api/v1/matches/join
Authorization: Bearer <token>
Content-Type: application/json

Request Body:
{
  "game_id": 1234567890,
  "skill_level": 1500
}

Response (200 OK):
{
  "match_id": 9876543210,
  "game_server_url": "udp://game.example.com:7777",
  "session_token": "abc123"
}
```

## 6. スケーラビリティ設計

### 水平スケーリング戦略

#### ゲームサーバー

- **動的スケーリング**: 需要に応じてゲームサーバーを起動・停止
- **地理的分散**: 複数のリージョンにゲームサーバーを配置
- **専用サーバー**: マルチプレイヤーゲーム用の専用サーバー

#### データベースシャーディング

**シャーディング戦略**: Game IDベースのシャーディング

```
Shard 1: game_id % 8 == 0
Shard 2: game_id % 8 == 1
...
Shard 8: game_id % 8 == 7
```

**シャーディングキー**: `game_id`
- マッチは`game_id`でシャーディング

## 7. レイテンシ最適化

### ボトルネックの特定

1. **ゲーム状態同期**: ゲーム状態の更新頻度
2. **ネットワークレイテンシ**: クライアントとサーバー間の距離
3. **ゲームサーバーの処理**: ゲームロジックの実行時間

### ゲーム状態同期最適化

1. **クライアント予測**: クライアント側で予測して表示
2. **サーバーオーソリティ**: サーバー側で最終的な状態を決定
3. **状態の補間**: 状態の補間でスムーズな表示

### ネットワーク最適化

1. **UDP使用**: 低レイテンシのためのUDP使用
2. **地理的分散**: ユーザーに近いゲームサーバーに接続
3. **データ圧縮**: ゲーム状態のデータ圧縮

## 8. コスト最適化

### インフラコストの見積もり

#### 前提条件

- **月間アクティブユーザー**: 5億人
- **日間アクティブユーザー**: 2億人
- **1日の同時接続数**: 5,000万人（ピーク時）

#### サーバーコスト（AWS）

**アプリケーションサーバー**:
- EC2インスタンス: m5.xlarge (4 vCPU, 16 GB RAM)
- インスタンス数: 500台
- コスト: $0.192/時間 × 500台 × 730時間 = **$70,080/月**

**ゲームサーバー**:
- EC2インスタンス: c5.2xlarge (8 vCPU, 16 GB RAM)
- インスタンス数: 10,000台（動的スケーリング）
- コスト: $0.34/時間 × 10,000台 × 730時間 = **$2,482,000/月**

**データベース**:
- RDS MySQL db.r5.2xlarge (8 vCPU, 64 GB RAM)
- インスタンス数: 50台（マスター + レプリカ）
- コスト: $0.76/時間 × 50台 × 730時間 = **$27,740/月**

**キャッシュ（ElastiCache）**:
- Redis cache.r5.xlarge (26 GB RAM)
- インスタンス数: 100台
- コスト: $0.175/時間 × 100台 × 730時間 = **$12,775/月**

**ネットワーク**:
- データ転送: 100 PB/月
- コスト: $0.09/GB × 100,000,000 GB = **$9,000,000/月**

**合計**: 約 **$11,592,595/月**（約139,111,140ドル/年）

### コスト削減戦略

1. **リザーブドインスタンス**: 1年契約で最大72%削減
2. **Spotインスタンス**: 非クリティカルなワークロードで最大90%削減
3. **オートスケーリング**: 需要に応じてインスタンス数を調整

## 9. 可用性・信頼性

### 障害対策

1. **冗長化**: 
   - 複数のゲームサーバーにデプロイ
   - データベースのマルチAZ配置

2. **ヘルスチェック**:
   - ゲームサーバーのヘルスチェック
   - データベースの接続チェック

3. **自動フェイルオーバー**:
   - ゲームサーバー障害時の自動フェイルオーバー

## 10. セキュリティ

### 認証・認可

1. **認証**: OAuth 2.0 / JWT
2. **認可**: セッションベースのアクセス制御

### アンチチート

1. **サーバーサイド検証**: 全てのアクションをサーバー側で検証
2. **異常検出**: 異常な行動パターンの検出
3. **レート制限**: アクションのレート制限

## 11. UX最適化

### パフォーマンス指標

- **ゲーム状態更新**: < 50ms
- **マッチメイキング**: < 10秒
- **ゲームサーバー接続**: < 2秒

## 12. 実装例

### ゲームサーバー（疑似コード）

```python
class GameServer:
    def __init__(self, db, cache, anti_cheat_service):
        self.db = db
        self.cache = cache
        self.anti_cheat_service = anti_cheat_service
        self.game_state = {}
    
    async def handle_player_action(self, match_id: int, player_id: int, action: dict):
        # アンチチート検証
        is_valid = await self.anti_cheat_service.validate_action(
            match_id=match_id,
            player_id=player_id,
            action=action
        )
        
        if not is_valid:
            raise InvalidActionError("Invalid action")
        
        # ゲーム状態を更新
        self.update_game_state(match_id=match_id, player_id=player_id, action=action)
        
        # 更新された状態を全プレイヤーに送信
        await self.broadcast_game_state(match_id=match_id)
        
        # ゲーム状態を保存（非同期）
        await self.save_game_state(match_id=match_id)
```

## 13. 数値例と計算

### トラフィック見積もり

#### 読み取りトラフィック

- **1日のマッチアクセス**: 10億回
- **1時間あたり**: 10億 / 24 = 約4,167万回
- **1秒あたり**: 4,167万 / 3600 = 約11,575回/秒
- **ピーク時（3倍）**: 約34,725回/秒

#### 書き込みトラフィック

- **1日のマッチ数**: 1億マッチ
- **1時間あたり**: 1億 / 24 = 約416万マッチ
- **1秒あたり**: 416万 / 3600 = 約1,156マッチ/秒
- **ピーク時（3倍）**: 約3,468マッチ/秒

## 14. ベストプラクティス

### 設計のベストプラクティス

1. **クライアント予測**: クライアント側で予測して表示
2. **サーバーオーソリティ**: サーバー側で最終的な状態を決定
3. **低レイテンシ**: UDP使用と地理的分散
4. **アンチチート**: サーバーサイド検証と異常検出
5. **モニタリング**: 包括的なモニタリングとアラート

### よくある落とし穴

1. **ゲーム状態同期のレイテンシ**:
   - 問題: ゲーム状態の更新が遅い
   - 解決策: クライアント予測とサーバーオーソリティ

2. **ゲームサーバーのスケーラビリティ**:
   - 問題: ゲームサーバーのリソース不足
   - 解決策: 動的スケーリングとオートスケーリング

## 15. 関連システム

### 類似システムへのリンク

- [Zoom](zoom_design.md) - ビデオ会議プラットフォーム
- [WebRTC](webrtc_design.md) - WebRTCプロトコル

### 共通パターンへのリンク

- [Load Balancing](../17_common_patterns/load_balancing.md) - 負荷分散
- [Caching Strategies](../17_common_patterns/caching_strategies.md) - キャッシング戦略

---

**次のステップ**: [Recommendation System](../16_ml_ai_systems/recommendation_system_design.md)でレコメンデーションシステムの設計を学ぶ

