# Message Queues パターン

## 1. 概要

メッセージキューは、アプリケーション間で非同期にメッセージを送受信するためのシステムです。非同期処理、スケーラビリティ、信頼性の向上を実現します。

## 2. メッセージキューの種類

### 2.1 Point-to-Point（P2P）

**説明**: 1つのメッセージを1つのコンシューマーが処理します。

**特徴**:
- メッセージの順序が保証される
- 負荷分散が可能

**使用例**:
- タスクキュー
- ジョブ処理

### 2.2 Publish-Subscribe（Pub/Sub）

**説明**: 1つのメッセージを複数のコンシューマーが処理します。

**特徴**:
- 複数のコンシューマーに配信
- イベント駆動アーキテクチャ

**使用例**:
- イベント通知
- ログ配信

## 3. メッセージキューの実装

### 3.1 Apache Kafka

**説明**: 分散ストリーミングプラットフォームです。

**特徴**:
- 高スループット
- 耐久性
- パーティショニング

**使用例**:
- イベントストリーミング
- ログ集約
- リアルタイムデータパイプライン

### 3.2 RabbitMQ

**説明**: メッセージブローカーです。

**特徴**:
- 柔軟なルーティング
- 複数のプロトコルサポート
- 管理UI

**使用例**:
- タスクキュー
- ワークフロー管理

### 3.3 Amazon SQS

**説明**: AWSが提供するマネージドメッセージキューサービスです。

**特徴**:
- マネージドサービス
- 自動スケーリング
- 高い可用性

**使用例**:
- AWS環境での非同期処理
- マイクロサービス間の通信

## 4. メッセージパターン

### 4.1 非同期処理

**説明**: 時間のかかる処理を非同期で実行します。

**メリット**:
- レスポンス時間の短縮
- リソースの効率的な使用

**使用例**:
- 画像処理
- メール送信
- レポート生成

### 4.2 イベント駆動アーキテクチャ

**説明**: イベントに基づいてシステムを構築します。

**メリット**:
- 疎結合
- スケーラビリティ
- 拡張性

**使用例**:
- マイクロサービス
- リアルタイムシステム

### 4.3 バックプレッシャー

**説明**: メッセージの処理速度に応じて送信速度を調整します。

**メリット**:
- システムの保護
- リソースの効率的な使用

**使用例**:
- 高負荷時の処理
- リソース制限がある場合

## 5. メッセージの保証

### 5.1 At-Least-Once Delivery

**説明**: メッセージは少なくとも1回配信されます。

**特徴**:
- メッセージの重複の可能性
- 高い信頼性

**使用例**:
- メッセージの損失が許容できない場合

### 5.2 At-Most-Once Delivery

**説明**: メッセージは最大1回配信されます。

**特徴**:
- メッセージの損失の可能性
- 重複なし

**使用例**:
- メッセージの損失が許容できる場合

### 5.3 Exactly-Once Delivery

**説明**: メッセージは正確に1回配信されます。

**特徴**:
- 重複なし、損失なし
- 実装が複雑

**使用例**:
- 金融取引
- 重要なデータ処理

## 6. 実装例

### 6.1 Kafka Producer

```python
from kafka import KafkaProducer
import json

producer = KafkaProducer(
    bootstrap_servers=['localhost:9092'],
    value_serializer=lambda v: json.dumps(v).encode('utf-8')
)

def send_message(topic: str, message: dict):
    """メッセージを送信"""
    producer.send(topic, message)
    producer.flush()
```

### 6.2 Kafka Consumer

```python
from kafka import KafkaConsumer
import json

consumer = KafkaConsumer(
    'my_topic',
    bootstrap_servers=['localhost:9092'],
    value_deserializer=lambda m: json.loads(m.decode('utf-8'))
)

for message in consumer:
    process_message(message.value)
```

## 7. ベストプラクティス

1. **メッセージのサイズ**: メッセージのサイズを小さく保つ
2. **バッチ処理**: 複数のメッセージをバッチで処理
3. **エラーハンドリング**: 適切なエラーハンドリングを実装
4. **モニタリング**: メッセージキューのメトリクスを監視
5. **デッドレターキュー**: 処理できないメッセージを保存

## 8. よくある落とし穴

1. **メッセージの順序**: メッセージの順序が保証されない場合がある
2. **メッセージの重複**: 重複メッセージの処理が必要
3. **デッドレターキュー**: 処理できないメッセージの管理が必要

## 9. 関連パターン

- [Load Balancing](load_balancing.md) - 負荷分散
- [Rate Limiting](rate_limiting.md) - レート制限

---

**次のステップ**: [Rate Limiting](rate_limiting.md)でレート制限を学ぶ

