# Caching Strategies パターン

## 1. 概要

キャッシングは、頻繁にアクセスされるデータを高速なストレージに保存し、パフォーマンスを向上させる技術です。

## 2. キャッシングレイヤー

### 2.1 L1 Cache（アプリケーション内キャッシュ）

**説明**: アプリケーションのメモリ内にキャッシュを保存します。

**特徴**:
- 最も高速
- アプリケーションのメモリを使用
- アプリケーション再起動時に失われる

**使用例**:
- 頻繁にアクセスされる小さなデータ
- 設定情報
- セッション情報

### 2.2 L2 Cache（分散キャッシュ）

**説明**: RedisやMemcachedなどの分散キャッシュを使用します。

**特徴**:
- 複数のアプリケーションサーバー間で共有可能
- 永続化可能
- ネットワークレイテンシがある

**使用例**:
- ユーザーセッション
- 頻繁にアクセスされるデータ
- 計算結果のキャッシュ

### 2.3 L3 Cache（CDN）

**説明**: CDNを使用してコンテンツをキャッシュします。

**特徴**:
- 地理的に分散
- 静的コンテンツに適している
- レイテンシが低い

**使用例**:
- 静的コンテンツ（画像、CSS、JavaScript）
- 動画コンテンツ
- APIレスポンス

## 3. キャッシング戦略

### 3.1 Cache-Aside（Lazy Loading）

**説明**: アプリケーションがキャッシュを管理します。

**フロー**:
1. アプリケーションがキャッシュを確認
2. キャッシュにデータがない場合、データベースから取得
3. データをキャッシュに保存
4. データを返す

**メリット**:
- シンプル
- キャッシュの障害時も動作可能

**デメリット**:
- キャッシュミス時のレイテンシが高い
- キャッシュの更新が必要

**使用例**:
- 読み取りが多いアプリケーション
- キャッシュの更新頻度が低い場合

### 3.2 Write-Through

**説明**: データの書き込み時にキャッシュとデータベースの両方に書き込みます。

**フロー**:
1. アプリケーションがデータを書き込み
2. データベースに書き込み
3. キャッシュに書き込み
4. 完了を返す

**メリット**:
- キャッシュとデータベースの一貫性が保たれる
- 読み取り時のキャッシュミスが少ない

**デメリット**:
- 書き込みのレイテンシが高い
- 書き込み頻度が高い場合に非効率

**使用例**:
- 読み取りが多いアプリケーション
- データの一貫性が重要な場合

### 3.3 Write-Back（Write-Behind）

**説明**: データの書き込み時にキャッシュにのみ書き込み、後でデータベースに書き込みます。

**フロー**:
1. アプリケーションがデータを書き込み
2. キャッシュに書き込み
3. 非同期でデータベースに書き込み
4. 完了を返す

**メリット**:
- 書き込みのレイテンシが低い
- 高スループット

**デメリット**:
- データの損失リスク
- 実装が複雑

**使用例**:
- 書き込みが多いアプリケーション
- データの損失が許容できる場合

### 3.4 Refresh-Ahead

**説明**: キャッシュの有効期限が切れる前に自動的に更新します。

**フロー**:
1. キャッシュの有効期限を監視
2. 有効期限が近づいたら、バックグラウンドで更新
3. ユーザーリクエスト時には更新済みのデータを返す

**メリット**:
- キャッシュミスが少ない
- レイテンシが低い

**デメリット**:
- 実装が複雑
- 不要な更新が発生する可能性

**使用例**:
- キャッシュミスを最小化したい場合
- 予測可能なアクセスパターン

## 4. キャッシュ無効化戦略

### 4.1 TTL（Time To Live）

**説明**: キャッシュに有効期限を設定します。

**メリット**:
- シンプル
- 自動的に無効化

**デメリット**:
- データが更新されても有効期限まで残る
- 古いデータが表示される可能性

### 4.2 明示的な無効化

**説明**: データが更新されたときに明示的にキャッシュを無効化します。

**メリット**:
- データの一貫性が保たれる
- 古いデータが表示されない

**デメリット**:
- 実装が複雑
- 無効化のタイミングが重要

### 4.3 イベントベース無効化

**説明**: データ更新イベントに基づいてキャッシュを無効化します。

**メリット**:
- リアルタイムでの無効化
- データの一貫性が保たれる

**デメリット**:
- イベントシステムが必要
- 実装が複雑

## 5. 実装例

### 5.1 Redis使用例

```python
import redis
import json

redis_client = redis.Redis(host='localhost', port=6379, db=0)

def get_user(user_id: int):
    # キャッシュを確認
    cache_key = f"user:{user_id}"
    cached_user = redis_client.get(cache_key)
    
    if cached_user:
        return json.loads(cached_user)
    
    # データベースから取得
    user = db.get_user(user_id)
    
    # キャッシュに保存
    redis_client.setex(
        cache_key,
        3600,  # TTL: 1時間
        json.dumps(user)
    )
    
    return user
```

## 6. ベストプラクティス

1. **キャッシュキーの設計**: 一意で予測可能なキーを使用
2. **TTLの設定**: 適切なTTLを設定
3. **キャッシュサイズの管理**: メモリ使用量を監視
4. **キャッシュヒット率の監視**: キャッシュの効果を測定
5. **キャッシュウォーミング**: 起動時にキャッシュを事前に読み込む

## 7. よくある落とし穴

1. **キャッシュスタンプede**: 同時に複数のリクエストがキャッシュミスを起こす
2. **キャッシュの無効化**: 適切な無効化戦略が必要
3. **メモリ不足**: キャッシュサイズの制限が必要

## 8. 関連パターン

- [Load Balancing](load_balancing.md) - 負荷分散
- [Database Sharding](database_sharding.md) - データベースシャーディング

---

**次のステップ**: [Database Sharding](database_sharding.md)でデータベースシャーディングを学ぶ

