# Kruskal's Algorithm - ロジック解説

## 問題概要

重み付き無向グラフが与えられたとき、最小全域木（MST）の重みの合計を返す。

**制約**:
- `1 <= n <= 100`
- `1 <= edges.length <= min(200, n * (n - 1) / 2)`

**例**:
```
Input: n = 4, edges = [[0,1,1],[0,2,2],[1,2,3],[1,3,4],[2,3,5]]
Output: 7
説明: MSTは辺(0,1), (0,2), (1,3)で構成され、重みの合計は1+2+4=7
```

## ロジックの核心

### なぜUnion-Findが有効か？

**全探索（O(2^E)）**:
- 全ての可能な辺の組み合わせを試す
- 時間計算量: O(2^E) - 非効率

**Union-Findを使う理由**:
- **サイクルの検出**: 辺を追加する際、サイクルを形成しないかチェック
- **時間計算量**: O(E log E) - ソート + Union-Find
- **空間計算量**: O(V) - Union-Findのデータ構造

### 思考プロセス

1. **辺のソート**: 重みの小さい順にソート
2. **Union-Find**: 各辺について、サイクルを形成しない場合のみ追加
3. **MSTの構築**: V-1個の辺が追加されるまで繰り返す

### アルゴリズムのステップ

```
function kruskalMST(n, edges):
    // 辺を重みの小さい順にソート
    edges.sort(key=lambda x: x[2])
    
    uf = UnionFind(n)
    mst_weight = 0
    edges_added = 0
    
    for u, v, w in edges:
        // サイクルを形成しない場合のみ追加
        if uf.find(u) != uf.find(v):
            uf.union(u, v)
            mst_weight += w
            edges_added += 1
            
            // MSTが完成したら終了
            if edges_added == n - 1:
                break
    
    return mst_weight
```

## 具体例でのトレース

### 例: `n = 4, edges = [[0,1,1],[0,2,2],[1,2,3],[1,3,4],[2,3,5]]`

```
ソート後: [[0,1,1],[0,2,2],[1,2,3],[1,3,4],[2,3,5]]

初期状態:
  uf: 各ノードが独立
  mst_weight = 0
  edges_added = 0

edge(0,1,1):
  find(0) != find(1) → union(0,1)
  mst_weight = 1
  edges_added = 1

edge(0,2,2):
  find(0) != find(2) → union(0,2)
  mst_weight = 3
  edges_added = 2

edge(1,2,3):
  find(1) == find(2) → サイクル、スキップ

edge(1,3,4):
  find(1) != find(3) → union(1,3)
  mst_weight = 7
  edges_added = 3 == n-1 → 終了

結果: 7
```

## 現実世界での応用

### 1. ネットワーク設計
- **シナリオ**: データセンターのネットワーク設計で、最小コストの接続を構築
- **実装**: Kruskalアルゴリズムで最小全域木を構築
- **メリット**: コスト効率的なネットワーク

### 2. クラスタリング
- **シナリオ**: データマイニングで、類似したデータをクラスタリング
- **実装**: Kruskalアルゴリズムで最小全域木を構築
- **メリット**: 効率的なクラスタリング

### 3. 画像処理
- **シナリオ**: 画像のセグメンテーションで、類似したピクセルをグループ化
- **実装**: Kruskalアルゴリズムで最小全域木を構築
- **メリット**: 効率的な画像処理

### 4. 電力網の設計
- **シナリオ**: 電力網で、最小コストの接続を構築
- **実装**: Kruskalアルゴリズムで最小全域木を構築
- **メリット**: コスト効率的な電力網

### 5. 交通ネットワーク
- **シナリオ**: 交通ネットワークで、最小コストの道路を構築
- **実装**: Kruskalアルゴリズムで最小全域木を構築
- **メリット**: コスト効率的な交通ネットワーク

### 6. 通信ネットワーク
- **シナリオ**: 通信ネットワークで、最小コストの接続を構築
- **実装**: Kruskalアルゴリズムで最小全域木を構築
- **メリット**: コスト効率的な通信ネットワーク

## 注意点と落とし穴

### 1. サイクルの検出
- **問題**: 辺を追加する際、サイクルを形成しないかチェック
- **解決策**: Union-Findで2つのノードが既に同じ集合に属するか確認
- **実装**: `if uf.find(u) != uf.find(v):`でチェック
- **注意**: サイクルを形成する辺は追加しない

### 2. 辺のソート
- **問題**: 辺を重みの小さい順にソートする必要がある
- **解決策**: `edges.sort(key=lambda x: x[2])`でソート
- **実装**: 重みでソートすることで、貪欲法が最適解を保証
- **注意**: ソートを忘れると、最適解が保証されない

### 3. MSTの完成条件
- **問題**: V-1個の辺が追加されたらMSTが完成
- **解決策**: `if edges_added == n - 1: break`で終了
- **実装**: 早期終了で効率化
- **注意**: V-1個より多く追加すると、サイクルが形成される

### 4. 時間計算量の理解
- **平均**: O(E log E) - ソートのコスト
- **最悪**: O(E log E) - 常に同じ時間計算量
- **空間**: O(V) - Union-Findのデータ構造
- **注意**: ソートのコストが支配的

### 5. Union-Findの実装
- **問題**: Union-Findを正確に実装する必要がある
- **解決策**: 経路圧縮とランク統合を使用
- **実装**: 効率的なUnion-Findの実装
- **注意**: Union-Findの実装が重要

### 6. グラフが連結でない場合
- **問題**: グラフが連結でない場合、MSTは存在しない
- **解決策**: `edges_added < n - 1`の場合、MSTは存在しない
- **実装**: 最終的に`edges_added`をチェック
- **注意**: 連結でないグラフの処理が重要

### 7. 重みが等しい辺
- **問題**: 重みが等しい辺が複数ある場合、どれを選ぶべきか？
- **解決策**: 通常は任意の辺を選ぶ（MSTの重みの合計は同じ）
- **実装**: ソートの安定性に依存
- **注意**: MSTの重みの合計は一意だが、MST自体は複数存在する可能性がある

### 8. Primとの比較
- **問題**: KruskalとPrimのどちらを使うべきか？
- **解決策**: 
  - Kruskal: O(E log E)、実装が簡単
  - Prim: O((V+E)log V)、密グラフで効率的
- **選択**: スパースグラフではKruskal、密グラフではPrim

## 関連問題

- [Prim's Algorithm](../leetcode/hard/) - 最小全域木の別のアルゴリズム
- [Connecting Cities With Minimum Cost](../leetcode/medium/) - MSTの応用
- [Min Cost to Connect All Points](../leetcode/medium/) - MSTの応用
- [Redundant Connection](../16_union_find/redundant_connection_logic.md) - Union-Findの応用

---

**次のステップ**: [Advanced Mathテクニック](../24_advanced_math/README.md)で高度な数学的アルゴリズムを学ぶ

