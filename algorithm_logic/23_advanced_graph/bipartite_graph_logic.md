# 二部グラフ判定 (Bipartite Graph Detection) - ロジック解説

## 問題概要

二部グラフ（Bipartite Graph）は、**頂点を2つのグループに分割し、同じグループ内の頂点間に辺が存在しないグラフ**です。グラフが二部グラフかどうかを判定するには、**2色彩色（2-coloring）**を使用します。O(V + E)で判定できます。マッチング問題、スケジューリング、リソース割り当てなどで広く使用されます。

**例**:
```
グラフ:
0 --- 1
|     |
2 --- 3

2色彩色:
グループA: {0, 3} (色: 0)
グループB: {1, 2} (色: 1)

同じグループ内に辺がない → 二部グラフ ✓
```

## ロジックの核心

### なぜ2色彩色が有効か？

**全探索（O(2^V)）**:
- 全ての可能な分割を試す
- 時間計算量: O(2^V) - 指数時間

**2色彩色を使う理由**:
- **効率的な探索**: DFS/BFSで1回の探索で判定
- **時間計算量**: O(V + E) - 線形時間
- **空間計算量**: O(V) - 色の配列

### アルゴリズムのステップ

#### BFSを使用した判定

```
function isBipartite(graph):
    colors = [-1] * n  // -1: 未着色, 0: 色0, 1: 色1
    
    for i in range(n):
        if colors[i] == -1:
            queue = [i]
            colors[i] = 0
            
            while queue:
                node = queue.pop(0)
                for neighbor in graph[node]:
                    if colors[neighbor] == -1:
                        colors[neighbor] = 1 - colors[node]
                        queue.append(neighbor)
                    elif colors[neighbor] == colors[node]:
                        return False  // 同じ色の隣接頂点がある
    
    return True
```

#### DFSを使用した判定

```
function dfs(node, color):
    colors[node] = color
    for neighbor in graph[node]:
        if colors[neighbor] == -1:
            if not dfs(neighbor, 1 - color):
                return False
        elif colors[neighbor] == color:
            return False
    return True

function isBipartite(graph):
    colors = [-1] * n
    for i in range(n):
        if colors[i] == -1:
            if not dfs(i, 0):
                return False
    return True
```

### 具体例でのトレース

#### 例1: 二部グラフ

**グラフ**:
```
0 --- 1
|     |
2 --- 3
```

**BFSでの判定**:
```
初期状態: colors = [-1, -1, -1, -1]

頂点0から開始:
  colors[0] = 0
  queue = [0]
  
  頂点0を処理:
    隣接: [1, 2]
    colors[1] = 1 - 0 = 1
    colors[2] = 1 - 0 = 1
    queue = [1, 2]
  
  頂点1を処理:
    隣接: [0, 3]
    colors[0] = 0 (既に着色、同じ色ではない) ✓
    colors[3] = 1 - 1 = 0
    queue = [2, 3]
  
  頂点2を処理:
    隣接: [0, 3]
    colors[0] = 0 (既に着色、同じ色ではない) ✓
    colors[3] = 0 (既に着色、同じ色ではない) ✓
    queue = [3]
  
  頂点3を処理:
    隣接: [1, 2]
    colors[1] = 1 (既に着色、同じ色ではない) ✓
    colors[2] = 1 (既に着色、同じ色ではない) ✓
    queue = []

結果: colors = [0, 1, 1, 0]
グループA (色0): {0, 3}
グループB (色1): {1, 2}
→ 二部グラフ ✓
```

#### 例2: 二部グラフではない

**グラフ**:
```
0 --- 1
| \ / |
|  X  |
| / \ |
2 --- 3
```

**BFSでの判定**:
```
初期状態: colors = [-1, -1, -1, -1]

頂点0から開始:
  colors[0] = 0
  queue = [0]
  
  頂点0を処理:
    隣接: [1, 2, 3]
    colors[1] = 1
    colors[2] = 1
    colors[3] = 1
    queue = [1, 2, 3]
  
  頂点1を処理:
    隣接: [0, 2]
    colors[0] = 0 (既に着色、同じ色ではない) ✓
    colors[2] = 1 (既に着色、同じ色) ✗
    → 二部グラフではない
```

## 現実世界での応用

### 1. マッチング問題
- **シナリオ**: ジョブとワーカーのマッチング
- **実装**: 二部グラフでマッチングを表現
- **メリット**: 効率的なマッチングアルゴリズムの適用

### 2. スケジューリング
- **シナリオ**: 会議室と会議のスケジューリング
- **実装**: 二部グラフでスケジューリングを表現
- **メリット**: 競合のないスケジューリング

### 3. リソース割り当て
- **シナリオ**: タスクとリソースの割り当て
- **実装**: 二部グラフで割り当てを表現
- **メリット**: 効率的なリソース割り当て

### 4. ソーシャルネットワーク分析
- **シナリオ**: ユーザーとグループの関係
- **実装**: 二部グラフで関係を表現
- **メリット**: コミュニティの分析

### 5. 推薦システム
- **シナリオ**: ユーザーとアイテムの関係
- **実装**: 二部グラフで関係を表現
- **メリット**: 効率的な推薦アルゴリズム

### 6. ゲーム開発
- **シナリオ**: プレイヤーとチームのマッチング
- **実装**: 二部グラフでマッチングを表現
- **メリット**: バランスの取れたマッチング

## 注意点と落とし穴

### 1. 非連結グラフの処理
- **問題**: グラフが非連結の場合、各連結成分を個別に判定
- **解決策**: 全ての頂点を探索し、未訪問の頂点から開始
- **実装**: ループで全ての頂点をチェック
- **注意**: 1つの連結成分が二部グラフでなくても、全体が二部グラフでない

### 2. 色の初期化
- **問題**: 色の配列を-1で初期化（未着色を表す）
- **解決策**: `colors = [-1] * n`で初期化
- **実装**: 未着色の状態を明確に管理
- **注意**: 0と1は色を表すため、-1を使用

### 3. 同じ色の隣接頂点の検出
- **問題**: 隣接頂点が同じ色の場合、二部グラフではない
- **解決策**: 隣接頂点の色をチェック
- **実装**: `if colors[neighbor] == colors[node]: return False`
- **注意**: この条件を忘れると誤判定

### 4. 無向グラフの扱い
- **問題**: 二部グラフ判定は無向グラフを前提
- **解決策**: 有向グラフの場合は適切に変換
- **実装**: 無向グラフとして扱う
- **注意**: 有向グラフの場合は異なるアプローチが必要

### 5. 自己ループの処理
- **問題**: 自己ループがある場合、二部グラフではない
- **解決策**: 自己ループを検出してFalseを返す
- **実装**: グラフの構築時に自己ループをチェック
- **注意**: 自己ループは常に二部グラフを破る

### 6. BFSとDFSの選択
- **問題**: BFSとDFSのどちらを使うか
- **解決策**: 
  - BFS: より直感的、レベル順の処理
  - DFS: 再帰的で簡潔、スタック使用
- **実装**: 問題の要件に応じて選択
- **注意**: 両方の方法を理解することが重要

### 7. 奇サイクルの検出
- **問題**: 奇サイクルがある場合、二部グラフではない
- **解決策**: 2色彩色で奇サイクルを検出
- **実装**: 同じ色の隣接頂点を検出することで奇サイクルを検出
- **注意**: 偶サイクルは二部グラフを破らない

## 関連問題

- [Course Schedule](./course_schedule_logic.md) - サイクル検出
- [Graph Coloring](../10_graph_algorithms/) - グラフ彩色
- [Maximum Bipartite Matching](../23_advanced_graph/) - 最大マッチング

---

**次のステップ**: [強連結成分](./strongly_connected_components_logic.md)で有向グラフの構造を学ぶ

