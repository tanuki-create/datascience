# Course Schedule - ロジック解説

## 問題概要

n個のコースと前提条件のリストが与えられたとき、全てのコースを完了できるか（サイクルがないか）を判定する。

**制約**:
- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= 5000`

**例**:
```
Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
説明: コース0を完了してからコース1を完了できる

Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
説明: サイクルがあるため、完了できない
```

## ロジックの核心

### なぜトポロジカルソートが有効か？

**DFSでサイクル検出（O(V + E)）**:
- DFSでサイクルを検出
- 時間計算量: O(V + E) - 線形時間

**トポロジカルソートを使う理由**:
- **サイクルの検出**: トポロジカルソートが完了すればサイクルなし
- **時間計算量**: O(V + E) - 線形時間
- **実装**: トポロジカルソートの実装を再利用

### 思考プロセス

1. **グラフの構築**: 前提条件からグラフを構築
2. **トポロジカルソート**: BFSでトポロジカルソートを実行
3. **サイクルの検出**: 全てのノードが処理されたか確認

### アルゴリズムのステップ

```
function canFinish(numCourses, prerequisites):
    // グラフと入次数の構築
    graph = defaultdict(list)
    indegree = [0] * numCourses
    
    for course, prereq in prerequisites:
        graph[prereq].append(course)
        indegree[course] += 1
    
    // 入次数が0のノードをキューに追加
    queue = deque()
    for i in range(numCourses):
        if indegree[i] == 0:
            queue.append(i)
    
    count = 0
    
    while queue:
        node = queue.popleft()
        count += 1
        
        // 隣接ノードの入次数を減らす
        for neighbor in graph[node]:
            indegree[neighbor] -= 1
            if indegree[neighbor] == 0:
                queue.append(neighbor)
    
    // 全てのノードが処理されたか確認
    return count == numCourses
```

## 具体例でのトレース

### 例: `numCourses = 2, prerequisites = [[1,0]]`

```
グラフの構築:
  graph[0] = [1]
  graph[1] = []

入次数:
  indegree[0] = 0
  indegree[1] = 1

初期キュー: [0]

ステップ1: node=0
  count = 1
  graph[0]の隣接ノード: [1]
    indegree[1] = 0 → queue.append(1)
  queue = [1]

ステップ2: node=1
  count = 2
  graph[1]の隣接ノード: []
  queue = []

count == numCourses → True
```

### 例: `numCourses = 2, prerequisites = [[1,0],[0,1]]`

```
グラフの構築:
  graph[0] = [1]
  graph[1] = [0]

入次数:
  indegree[0] = 1
  indegree[1] = 1

初期キュー: []（入次数が0のノードがない）

count = 0
count != numCourses → False
```

## 現実世界での応用

### 1. 教育システム
- **シナリオ**: 大学のコース登録システムで、前提条件をチェック
- **実装**: トポロジカルソートでサイクルを検出
- **メリット**: 効率的なコース登録管理

### 2. スキル習得システム
- **シナリオ**: オンライン学習プラットフォームで、スキルの習得順序をチェック
- **実装**: トポロジカルソートでサイクルを検出
- **メリット**: 効率的な学習管理

### 3. タスク管理
- **シナリオ**: プロジェクト管理ツールで、タスクの依存関係をチェック
- **実装**: トポロジカルソートでサイクルを検出
- **メリット**: 効率的なタスク管理

### 4. ビルドシステム
- **シナリオ**: Make、CMakeなどのビルドシステムで、ターゲットの依存関係をチェック
- **実装**: トポロジカルソートでサイクルを検出
- **メリット**: 効率的なビルド管理

### 5. パッケージマネージャー
- **シナリオ**: npm、pipなどのパッケージマネージャーで、依存関係のサイクルを検出
- **実装**: トポロジカルソートでサイクルを検出
- **メリット**: 効率的なパッケージ管理

### 6. ワークフロー管理
- **シナリオ**: ワークフロー管理システムで、ステップの依存関係をチェック
- **実装**: トポロジカルソートでサイクルを検出
- **メリット**: 効率的なワークフロー管理

## 注意点と落とし穴

### 1. サイクルの検出
- **問題**: サイクルがある場合、全てのコースを完了できない
- **解決策**: 処理されたノード数が総ノード数と等しいか確認
- **実装**: `return count == numCourses`
- **注意**: サイクルがある場合、`count < numCourses`になる

### 2. 入次数の管理
- **問題**: 各ノードの入次数を正確に管理する必要がある
- **解決策**: グラフ構築時に入次数を計算
- **実装**: `indegree[course] += 1`で管理
- **注意**: 入次数の計算を忘れると、正しく動作しない

### 3. 空の前提条件
- **問題**: 前提条件がない場合（全てのコースが独立）
- **解決策**: 全てのノードの入次数が0になる
- **実装**: 通常の処理で正しく動作
- **注意**: エッジケースの処理が重要

### 4. 時間計算量の理解
- **平均**: O(V + E) - 各ノードと辺を1回ずつ処理
- **最悪**: O(V + E) - 常に線形時間
- **空間**: O(V) - グラフ、入次数、キュー
- **メリット**: 効率的なアルゴリズム

### 5. DFSアプローチとの比較
- **問題**: BFSとDFSのどちらを使うべきか？
- **解決策**: 
  - BFS: 実装が簡単、キューを使用
  - DFS: 再帰的実装、サイクル検出が直接的に
- **選択**: 通常はBFSが推奨される

### 6. エッジケースの処理
- **問題**: 空のグラフ、1つのコース、サイクルがある場合
- **解決策**: 各操作でエッジケースをチェック
- **実装**: `if numCourses == 0: return True`などのチェック
- **注意**: エッジケースを忘れると、エラーが発生

### 7. グラフの表現
- **問題**: グラフをどのように表現するか
- **解決策**: 通常は隣接リストが効率的
- **実装**: `graph = defaultdict(list)`で表現
- **注意**: スパースグラフでは隣接リストが有利

### 8. カウントの管理
- **問題**: 処理されたノード数を正確に追跡する必要がある
- **解決策**: ノードを処理するたびにカウントを増やす
- **実装**: `count += 1`で管理
- **注意**: カウントを忘れると、サイクルの検出が正しく動作しない

## 関連問題

- [Topological Sort](./topological_sort_logic.md) - トポロジカルソートの基本
- [Course Schedule II](../leetcode/medium/) - トポロジカルソートの順序を返す
- [Alien Dictionary](../leetcode/hard/) - トポロジカルソートの応用
- [Sequence Reconstruction](../leetcode/hard/) - トポロジカルソートの応用

---

**次のステップ**: [Dijkstra Shortest Path](./dijkstra_shortest_path_logic.md)で最短経路を学ぶ

