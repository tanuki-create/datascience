# Bellman-Ford Algorithm - ロジック解説

## 問題概要

重み付き有向グラフと開始ノードが与えられたとき、開始ノードから全てのノードへの最短経路の距離を返す。負の重みも扱えるが、負のサイクルがある場合は検出する。

**制約**:
- `1 <= n <= 100`
- 負の重みが存在する可能性がある

**例**:
```
Input: n = 4, edges = [[0,1,1],[1,2,-1],[2,3,2],[0,3,4]], start = 0
Output: [0,1,0,2]
説明: 負の重みを含む最短経路
```

## ロジックの核心

### なぜBellman-Fordが有効か？

**Dijkstra（非負重みのみ）**:
- 非負の重みのみを扱える
- 負の重みがある場合、正しく動作しない

**Bellman-Fordを使う理由**:
- **負の重みの対応**: 負の重みも扱える
- **負のサイクルの検出**: 負のサイクルを検出可能
- **時間計算量**: O(V × E) - 全ての辺をV回緩和

### 思考プロセス

1. **距離の初期化**: 開始ノードの距離を0、他を無限大に設定
2. **緩和操作**: 全ての辺をV-1回緩和
3. **負のサイクルの検出**: V回目の緩和で距離が更新される場合、負のサイクルが存在

### アルゴリズムのステップ

```
function bellmanFord(n, edges, start):
    // 距離の初期化
    dist = [float('inf')] * n
    dist[start] = 0
    
    // V-1回の緩和
    for i in range(n - 1):
        for u, v, w in edges:
            if dist[u] != float('inf') and dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
    
    // 負のサイクルの検出
    for u, v, w in edges:
        if dist[u] != float('inf') and dist[u] + w < dist[v]:
            return None  // 負のサイクルが存在
    
    return dist
```

## 具体例でのトレース

### 例: `n = 4, edges = [[0,1,1],[1,2,-1],[2,3,2],[0,3,4]], start = 0`

```
初期状態:
  dist = [0, inf, inf, inf]

緩和1回目:
  edge(0,1,1): dist[1] = min(inf, 0+1) = 1
  edge(1,2,-1): dist[2] = min(inf, 1+(-1)) = 0
  edge(2,3,2): dist[3] = min(inf, 0+2) = 2
  edge(0,3,4): dist[3] = min(2, 0+4) = 2
  dist = [0, 1, 0, 2]

緩和2回目:
  edge(0,1,1): dist[1] = min(1, 0+1) = 1（変更なし）
  edge(1,2,-1): dist[2] = min(0, 1+(-1)) = 0（変更なし）
  edge(2,3,2): dist[3] = min(2, 0+2) = 2（変更なし）
  edge(0,3,4): dist[3] = min(2, 0+4) = 2（変更なし）

結果: [0,1,0,2]
```

## 現実世界での応用

### 1. 金融取引システム
- **シナリオ**: 為替取引で、通貨の変換レートに基づいて最適な経路を計算
- **実装**: Bellman-Fordで負の重み（利益）を扱う
- **メリット**: アービトラージの検出

### 2. ネットワークルーティング
- **シナリオ**: ネットワークで、コストが負になる可能性がある経路を計算
- **実装**: Bellman-Fordで負の重みを扱う
- **メリット**: 効率的なルーティング

### 3. ゲーム開発
- **シナリオ**: ゲームで、負のコスト（ボーナス）を含む経路を計算
- **実装**: Bellman-Fordで負の重みを扱う
- **メリット**: 効率的なゲーム処理

### 4. 物流システム
- **シナリオ**: 配送ルートで、リベートや割引を含む最適な経路を計算
- **実装**: Bellman-Fordで負の重みを扱う
- **メリット**: コストの最適化

### 5. 電力網の管理
- **シナリオ**: 電力網で、発電コストが負になる可能性がある経路を計算
- **実装**: Bellman-Fordで負の重みを扱う
- **メリット**: 効率的な電力管理

### 6. データ分析
- **シナリオ**: データ分析で、負のコストを含む最適化問題を解く
- **実装**: Bellman-Fordで負の重みを扱う
- **メリット**: 効率的なデータ分析

## 注意点と落とし穴

### 1. 負のサイクルの検出
- **問題**: 負のサイクルがある場合、最短経路は存在しない
- **解決策**: V回目の緩和で距離が更新される場合、負のサイクルが存在
- **実装**: V回目の緩和でチェック
- **注意**: 負のサイクルがある場合、Noneを返すか、エラーを返す

### 2. V-1回の緩和
- **問題**: なぜV-1回の緩和が必要か？
- **解決策**: 最長の経路はV-1個の辺を持つため
- **実装**: `for i in range(n - 1):`でV-1回緩和
- **注意**: V回以上緩和しても、最短経路は変わらない

### 3. 時間計算量の理解
- **平均**: O(V × E) - 全ての辺をV回緩和
- **最悪**: O(V × E) - 常に同じ時間計算量
- **空間**: O(V) - 距離配列
- **注意**: Dijkstraより遅いが、負の重みを扱える

### 4. 無限大のチェック
- **問題**: 到達不可能なノードの距離が`inf`のまま
- **解決策**: 緩和時に`dist[u] != float('inf')`をチェック
- **実装**: 無限大のノードからは緩和しない
- **注意**: 無限大のチェックを忘れると、誤った結果が返される

### 5. エッジケースの処理
- **問題**: 空のグラフ、1つのノード、負のサイクルがある場合
- **解決策**: 各操作でエッジケースをチェック
- **実装**: `if n == 0: return []`などのチェック
- **注意**: エッジケースを忘れると、エラーが発生

### 6. 負のサイクルの位置
- **問題**: 負のサイクルが開始ノードから到達可能かどうか
- **解決策**: 開始ノードから到達可能な負のサイクルのみを検出
- **実装**: 通常の実装で自動的に検出
- **注意**: 到達不可能な負のサイクルは無視される

### 7. Dijkstraとの比較
- **問題**: DijkstraとBellman-Fordのどちらを使うべきか？
- **解決策**: 
  - Dijkstra: 非負重み、O((V+E)log V)
  - Bellman-Ford: 負重みも扱える、O(V×E)
- **選択**: 負の重みがある場合はBellman-Ford

### 8. 最適化の可能性
- **問題**: 早期終了で効率化できる場合がある
- **解決策**: 緩和で距離が更新されなくなったら終了
- **実装**: `updated = False`で更新を追跡
- **メリット**: 実際の実行時間を短縮

## 関連問題

- [Dijkstra Shortest Path](./dijkstra_shortest_path_logic.md) - 非負重みの最短経路
- [Network Delay Time](../leetcode/medium/) - 最短経路の応用
- [Cheapest Flights Within K Stops](../leetcode/medium/) - 制約付き最短経路
- [Path With Minimum Effort](../leetcode/medium/) - 最短経路の応用

---

**次のステップ**: [Kruskal MST](./kruskal_mst_logic.md)で最小全域木を学ぶ

