# N-Queens - ロジック解説

## 問題概要

n×nのチェス盤に、n個のクイーンを配置する。クイーンは互いに攻撃できないように配置する必要がある。全ての可能な配置を返す。

**制約**:
- `1 <= n <= 9`
- クイーンは縦・横・斜めの8方向に攻撃できる

**例**:
```
Input: n = 4
Output: [
 [".Q..","...Q","Q...","..Q."],
 ["..Q.","Q...","...Q",".Q.."]
]
説明: 4×4の盤に4個のクイーンを配置する2つの方法
```

## ロジックの核心

### なぜバックトラッキングが有効か？

**全探索（非効率）**:
- 全ての可能な配置を試す: n^2個の位置からn個を選ぶ
- 時間計算量: O(C(n^2, n)) - 組み合わせ爆発

**バックトラッキングを使う理由**:
- **制約を満たすものだけを生成**: 無効な配置を生成しない
- **行ごとに配置**: 各行に1つのクイーンを配置することで、横方向の衝突を自動的に回避
- **早期終了**: 制約を満たさない場合は即座に戻る
- **時間計算量**: O(n!) - 各行でn個の選択肢があるが、制約により減る

### 思考プロセス

1. **制約の理解**: 
   - 各行に1つのクイーン（横方向の衝突を回避）
   - 各列に1つのクイーン（縦方向の衝突を回避）
   - 各対角線に1つのクイーン（斜め方向の衝突を回避）

2. **行ごとの配置**:
   - 各行iについて、有効な列jを選択
   - 列jが既に使用されていないか確認
   - 対角線が衝突していないか確認

3. **バックトラック**:
   - 有効な配置が見つからない場合、一つ前の行に戻る

### アルゴリズムのステップ

```
function solveNQueens(n):
    result = []
    board = [["."] * n for _ in range(n)]
    
    function backtrack(row):
        // ベースケース: 全ての行に配置完了
        if row == n:
            result.append(createSolution(board))
            return
        
        // 現在の行の各列を試す
        for col in range(n):
            if isValid(board, row, col):
                board[row][col] = "Q"
                backtrack(row + 1)
                board[row][col] = "."  // バックトラック
    
    function isValid(board, row, col):
        // 列のチェック
        for i in range(row):
            if board[i][col] == "Q":
                return False
        
        // 左上対角線のチェック
        i, j = row - 1, col - 1
        while i >= 0 and j >= 0:
            if board[i][j] == "Q":
                return False
            i, j = i - 1, j - 1
        
        // 右上対角線のチェック
        i, j = row - 1, col + 1
        while i >= 0 and j < n:
            if board[i][j] == "Q":
                return False
            i, j = i - 1, j + 1
        
        return True
    
    backtrack(0)
    return result
```

## 具体例でのトレース

### 例: `n = 4`

```
初期状態: 空の4×4盤

行0: 列0に配置を試す
  Q . . .
  . . . .
  . . . .
  . . . .

行1: 列2に配置を試す（列0,1は衝突）
  Q . . .
  . . Q .
  . . . .
  . . . .

行2: 列1に配置を試す（列0,3は衝突、列2も衝突）
  Q . . .
  . . Q .
  . Q . .
  . . . .

行3: 列3に配置を試す（列0,1,2は衝突）
  Q . . .
  . . Q .
  . Q . .
  . . . Q  ✓ 解1が見つかった

バックトラック: 行3から戻る
  Q . . .
  . . Q .
  . Q . .
  . . . .

行2: 列3に配置を試す
  Q . . .
  . . Q .
  . . . Q
  . . . .

行3: 列1に配置を試す（列0,2,3は衝突）
  Q . . .
  . . Q .
  . . . Q
  . Q . .  ✓ 解2が見つかった

結果: 2つの解
```

### 可視化

```
n = 4 の場合の探索木（一部）:

                    []
                   /
            [0] (行0に列0)
           /  |  \
      [0,2] [0,3] [0,1] (行1の選択)
       /  \
  [0,2,3] [0,2,1] (行2の選択)
    |       |
  [0,2,3,1] [0,2,1,3] (解)
```

## 現実世界での応用

### 1. スケジューリング問題
- **シナリオ**: 複数のタスクを時間スロットに割り当て、制約を満たす
- **実装**: 各タスクを行、時間スロットを列として、制約を満たす配置を探索
- **例**: 会議室の予約システムで、時間の重複を避ける
- **メリット**: 最適なスケジュールを見つける

### 2. レイアウト最適化
- **シナリオ**: オブジェクトを配置領域に配置し、制約を満たす
- **実装**: 各オブジェクトを行、配置位置を列として、衝突を避ける
- **例**: チップ設計で、コンポーネントの配置を最適化
- **メリット**: 効率的なレイアウトを生成

### 3. データベースのクエリ最適化
- **シナリオ**: 複数のテーブルを結合する際、最適な順序を見つける
- **実装**: 各テーブルを行、結合順序を列として、制約を満たす
- **例**: SQLクエリの実行計画を最適化
- **メリット**: クエリの実行時間を短縮

### 4. ゲームAI（チェス、将棋）
- **シナリオ**: 複数の駒を配置し、最適な戦略を見つける
- **実装**: 各駒を行、配置位置を列として、ルールを満たす
- **例**: チェスエンジンで、最適な駒の配置を探索
- **メリット**: 強いAIを実現

### 5. ネットワークルーティング
- **シナリオ**: 複数のパケットを経路に割り当て、衝突を避ける
- **実装**: 各パケットを行、経路を列として、制約を満たす
- **例**: ネットワークスイッチで、パケットのルーティングを最適化
- **メリット**: ネットワークの効率を向上

### 6. リソース割り当て
- **シナリオ**: 複数のリソースをタスクに割り当て、制約を満たす
- **実装**: 各タスクを行、リソースを列として、制約を満たす
- **例**: クラウドコンピューティングで、VMの配置を最適化
- **メリット**: リソースの効率的な利用

## 注意点と落とし穴

### 1. 制約チェックの効率化
- **問題**: 毎回全ての既存クイーンをチェックすると非効率
- **解決策**: 列、対角線の使用状況をセットで管理
- **実装**: 
  ```
  cols = set()
  diag1 = set()  // row - col
  diag2 = set()  // row + col
  ```
- **メリット**: O(1)で制約チェックが可能

### 2. 対角線のインデックス計算
- **問題**: 対角線をどのように表現するか
- **解決策**: 
  - 左上から右下: `row - col`（一定値）
  - 右上から左下: `row + col`（一定値）
- **実装**: これらの値をセットで管理
- **注意**: インデックスが負になる場合があるため、オフセットを加える

### 3. バックトラック時の状態復元
- **問題**: バックトラック時に、盤の状態を正確に復元する必要がある
- **解決策**: 再帰呼び出しの後、配置を元に戻す
- **実装**: `board[row][col] = "."`で元に戻す
- **注意**: セットを使う場合も、追加した要素を削除する必要がある

### 4. 時間計算量の理解
- **平均**: O(n!) - 各行でn個の選択肢があるが、制約により減る
- **最悪**: O(n!) - 常に階乗時間
- **空間**: O(n) - 再帰の深さが最大n
- **注意**: nが大きい場合、解の数が指数関数的に増える

### 5. 解の数の増加
- **問題**: nが大きくなるにつれて、解の数が急激に増える
- **例**: n=8の場合、92個の解が存在
- **解決策**: 1つの解だけを求める問題の場合は、見つかったら即座に終了
- **注意**: 全ての解を求める場合は、時間がかかる可能性がある

### 6. メモ化の可能性
- **問題**: 同じ状態が複数回計算される可能性があるか？
- **解決策**: この問題では、各行は1回だけ処理されるため、メモ化は不要
- **理由**: 探索木がDAGであり、重複がない
- **注意**: 他の制約充足問題では、メモ化が有効な場合がある

### 7. 対称性の利用
- **問題**: 盤の対称性を利用して、探索を効率化できる
- **解決策**: 最初の行の半分だけを試し、対称な解を生成
- **実装**: `for col in range(n // 2):`で最初の行を制限
- **メリット**: 探索空間を半分に削減

### 8. ビットマスクによる最適化
- **問題**: 列と対角線の使用状況をビットマスクで管理
- **解決策**: 整数のビットで列・対角線の使用状況を表現
- **実装**: `cols = 0b0000`として管理し、ビット演算でチェック
- **メリット**: メモリ使用量と実行時間を改善

## 関連問題

- [N-Queens II](../leetcode/hard/) - 解の数のみを返す
- [Sudoku Solver](./sudoku_solver_logic.md) - より複雑な制約充足問題
- [Word Search](../leetcode/medium/) - グリッド上のパス探索
- [Permutations](../leetcode/medium/) - 順列生成

---

**次のステップ**: [Sudoku Solver](./sudoku_solver_logic.md)でより複雑な制約充足問題を学ぶ

