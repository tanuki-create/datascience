# バックトラッキング (Backtracking)

## 概要

バックトラッキングは、全ての可能な解を体系的に探索するアルゴリズム手法です。解が見つからない場合や、現在の選択が解に繋がらない場合に、**一つ前の状態に戻って別の選択を試す**という特徴があります。組み合わせ問題、順列問題、制約充足問題などで威力を発揮します。

## 基本概念

### バックトラッキングの仕組み

1. **選択**: 現在の状態から可能な選択肢を選ぶ
2. **再帰**: 選択した状態で次のステップに進む
3. **制約チェック**: 現在の選択が有効か確認
4. **バックトラック**: 無効な場合、または解が見つからない場合に一つ前の状態に戻る
5. **解の記録**: 有効な解を見つけたら記録

### 主な操作と計算量

| 操作 | 時間計算量 | 空間計算量 | 適用場面 |
|------|-----------|-----------|---------|
| 組み合わせ生成 | O(2^n) | O(n) | 全ての部分集合を生成 |
| 順列生成 | O(n!) | O(n) | 全ての順列を生成 |
| N-Queens | O(n!) | O(n) | 制約充足問題 |

**注意**: バックトラッキングは指数時間または階乗時間になることが多いですが、早期終了（pruning）により実際の実行時間は大幅に短縮される場合があります。

## いつ使うべきか

バックトラッキングは以下のような場面で威力を発揮します：

### 1. 組み合わせ・順列問題
- 全ての可能な組み合わせを生成する必要がある
- 「n個からk個を選ぶ」全ての組み合わせ
- 全ての順列を生成

### 2. 制約充足問題
- 複数の制約を同時に満たす解を探す
- N-Queens問題（クイーンが互いに攻撃しない配置）
- 数独ソルバー（行・列・ブロックの制約を満たす）

### 3. パス探索問題
- 迷路やグラフで全ての可能なパスを探索
- 条件を満たす全てのパスを見つける

### 4. 分割問題
- 文字列や配列を条件を満たすように分割
- パーティション問題

## 現実世界での応用例

### 1. スケジューリングシステム
- **例**: 会議室の予約システムで、制約を満たす全てのスケジュールを探索
- **実装**: 時間スロットを選択し、制約（会議室の容量、時間の重複など）をチェック
- **メリット**: 最適なスケジュールを見つける

### 2. ゲームAI（パズルゲーム）
- **例**: 数独、クロスワードパズル、N-Queensなどの自動解法
- **実装**: 可能な選択肢を試し、制約に違反したら戻る
- **メリット**: 複雑なパズルを自動的に解く

### 3. コンパイラの最適化
- **例**: レジスタ割り当て、命令スケジューリング
- **実装**: 可能な割り当てを試し、最適なものを選択
- **メリット**: コードの実行効率を向上

### 4. ネットワークルーティング
- **例**: 複数の経路から最適な経路を探索
- **実装**: 可能な経路を試し、制約（帯域幅、遅延など）を満たすものを選択
- **メリット**: 効率的なネットワーク経路を見つける

### 5. DNA配列解析
- **例**: 遺伝子配列の組み合わせを探索
- **実装**: 可能な配列を生成し、生物学的制約をチェック
- **メリット**: 遺伝子の機能を理解

### 6. パスワードクラッキング（セキュリティテスト）
- **例**: セキュリティテストで、可能なパスワードの組み合わせを試す
- **実装**: 文字の組み合わせを生成し、ハッシュと照合
- **メリット**: システムの脆弱性を発見

## 実装時の注意点

### 1. 状態の管理
- **問題**: 再帰呼び出しで状態を正確に管理する必要がある
- **解決策**: 状態を引数として渡す、またはグローバル変数を使用
- **推奨**: 引数として渡す方が、バックトラック時に自動的に状態が戻る

### 2. メモ化の活用
- **問題**: 同じ状態が複数回計算される可能性がある
- **解決策**: 計算済みの状態をメモ化して再利用
- **注意**: メモ化により時間計算量を大幅に改善できる場合がある

### 3. 早期終了（Pruning）
- **問題**: 全ての可能性を探索すると時間がかかりすぎる
- **解決策**: 制約を満たさない選択肢を早期に排除
- **実装**: 制約チェックを各ステップで行い、無効な場合は即座に戻る

### 4. 空間計算量
- **問題**: 再帰の深さが深い場合、スタックオーバーフローのリスク
- **解決策**: 反復的実装を使用、または再帰の深さを制限
- **注意**: Pythonのデフォルト再帰制限は1000程度

### 5. 解の重複
- **問題**: 同じ解が複数回生成される可能性がある
- **解決策**: 解をセットに保存する、または生成時に重複チェック
- **実装**: ソートしてから生成することで、重複を避けられる場合がある

## 関連するLeetCode/AtCoder問題

### Medium
- [Generate Parentheses](./generate_parentheses_logic.md) - バックトラッキングの基本
- [Combination Sum](./combination_sum_logic.md) - 組み合わせ問題
- [Permutations](../leetcode/medium/) - 順列生成

### Hard
- [N-Queens](./n_queens_logic.md) - 制約充足問題の典型例
- [Sudoku Solver](./sudoku_solver_logic.md) - 複雑な制約充足問題
- [Word Search II](../15_trie/word_search_ii_logic.md) - バックトラッキング + Trie

## 学習の進め方

1. **Generate Parentheses**から始める: バックトラッキングの最も基本的な例
2. **Combination Sum**で組み合わせ問題を学ぶ: 選択肢の生成と制約チェック
3. **N-Queens**で制約充足問題を学ぶ: 複数の制約を同時に満たす解の探索
4. **より複雑な問題**に挑戦: 他のテクニックと組み合わせた使用法を学ぶ

## 次のステップ

- [Generate Parentheses のロジック解説](./generate_parentheses_logic.md)
- [N-Queens のロジック解説](./n_queens_logic.md)
- [動的計画法テクニック](../07_dynamic_programming/README.md) - バックトラッキングと比較

---

**重要**: バックトラッキングは、全ての可能な解を探索する強力な手法ですが、時間計算量が大きくなる可能性があります。早期終了（pruning）とメモ化を適切に使用することで、実用的な実行時間に抑えることができます。

