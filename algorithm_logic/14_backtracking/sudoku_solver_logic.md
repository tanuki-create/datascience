# Sudoku Solver - ロジック解説

## 問題概要

9×9の数独パズルが与えられたとき、空のマス（'.'）に1-9の数字を埋めて、数独のルールを満たす解を見つける。

**制約**:
- 各行に1-9が1回ずつ出現
- 各列に1-9が1回ずつ出現
- 各3×3のブロックに1-9が1回ずつ出現

**例**:
```
Input: board = [
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
```

## ロジックの核心

### なぜバックトラッキングが有効か？

**全探索（非効率）**:
- 全ての可能な数字の組み合わせを試す
- 時間計算量: O(9^m) - mは空のマスの数

**バックトラッキングを使う理由**:
- **制約を満たすものだけを生成**: 無効な数字を配置しない
- **早期終了**: 制約を満たさない場合は即座に戻る
- **時間計算量**: 実際にはO(9^m)だが、早期終了により大幅に短縮

### 思考プロセス

1. **空のマスを見つける**: 次の空のマスを探す
2. **可能な数字を試す**: 1-9の数字で、制約を満たすものを試す
3. **制約チェック**: 
   - 同じ行に同じ数字がないか
   - 同じ列に同じ数字がないか
   - 同じ3×3ブロックに同じ数字がないか
4. **再帰**: 有効な数字を配置し、次の空のマスに進む
5. **バックトラック**: 解が見つからない場合、一つ前のマスに戻る

### アルゴリズムのステップ

```
function solveSudoku(board):
    function backtrack():
        // 空のマスを見つける
        for i in range(9):
            for j in range(9):
                if board[i][j] == ".":
                    // 1-9の数字を試す
                    for num in "123456789":
                        if isValid(board, i, j, num):
                            board[i][j] = num
                            if backtrack():
                                return True
                            board[i][j] = "."  // バックトラック
                    return False  // どの数字も無効
        return True  // 全てのマスが埋まった
    
    function isValid(board, row, col, num):
        // 行のチェック
        for j in range(9):
            if board[row][j] == num:
                return False
        
        // 列のチェック
        for i in range(9):
            if board[i][col] == num:
                return False
        
        // ブロックのチェック
        block_row = (row // 3) * 3
        block_col = (col // 3) * 3
        for i in range(block_row, block_row + 3):
            for j in range(block_col, block_col + 3):
                if board[i][j] == num:
                    return False
        
        return True
    
    backtrack()
```

## 具体例でのトレース

### 例: 部分的な数独パズル

```
初期状態:
5 3 . . 7 . . . .
6 . . 1 9 5 . . .
. 9 8 . . . . 6 .
...

(0,2)のマスに'1'を試す:
5 3 1 . 7 . . . .
...

制約チェック: 行0に'1'はない ✓
             列2に'1'はない ✓
             ブロック(0,0)に'1'はない ✓

(0,3)のマスに'2'を試す:
5 3 1 2 7 . . . .
...

制約チェック: 行0に'2'はない ✓
             列3に'2'はない ✓
             ブロック(0,1)に'2'はない ✓

... 続けて埋めていく

解が見つからない場合、バックトラック:
5 3 . . 7 . . . .
...

(0,2)のマスに'4'を試す:
5 3 4 . 7 . . . .
...
```

## 現実世界での応用

### 1. パズルゲームの自動解法
- **シナリオ**: 数独アプリで、ユーザーが詰まった際に自動で解く
- **実装**: バックトラッキングで全ての可能な解を探索
- **例**: 数独アプリの「ヒント」機能
- **メリット**: ユーザーの体験を向上

### 2. 制約充足問題の一般化
- **シナリオ**: 複数の制約を同時に満たす解を探す
- **実装**: 数独のアルゴリズムを一般化して、他の制約充足問題に適用
- **例**: スケジューリング、レイアウト最適化
- **メリット**: 汎用的な問題解決手法

### 3. データ検証
- **シナリオ**: データの整合性をチェックし、矛盾を解決
- **実装**: 制約を満たすようにデータを修正
- **例**: データベースの整合性チェック
- **メリット**: データの品質を保証

### 4. コンパイラの最適化
- **シナリオ**: コードの最適化で、複数の制約を満たす
- **実装**: レジスタ割り当て、命令スケジューリング
- **例**: コンパイラがコードを最適化する際の制約解決
- **メリット**: コードの実行効率を向上

### 5. ネットワーク設計
- **シナリオ**: ネットワークトポロジーの設計で、制約を満たす
- **実装**: ノードの配置、リンクの割り当てを最適化
- **例**: データセンターのネットワーク設計
- **メリット**: 効率的なネットワーク構築

### 6. リソース割り当て
- **シナリオ**: 複数のリソースをタスクに割り当て、制約を満たす
- **実装**: 各リソースの制約を満たすように割り当て
- **例**: クラウドコンピューティングでのリソース割り当て
- **メリット**: リソースの効率的な利用

## 注意点と落とし穴

### 1. 制約チェックの効率化
- **問題**: 毎回全ての行・列・ブロックをチェックすると非効率
- **解決策**: 各行・列・ブロックの使用済み数字をセットで管理
- **実装**: 
  ```
  rows = [set() for _ in range(9)]
  cols = [set() for _ in range(9)]
  blocks = [set() for _ in range(9)]
  ```
- **メリット**: O(1)で制約チェックが可能

### 2. 空のマスの順序
- **問題**: どの順序で空のマスを埋めるかが重要
- **解決策**: 制約が厳しいマス（候補が少ない）から埋める
- **実装**: 各空のマスの候補数を計算し、少ない順に処理
- **メリット**: 探索空間を大幅に削減

### 3. バックトラック時の状態復元
- **問題**: バックトラック時に、盤の状態を正確に復元する必要がある
- **解決策**: 再帰呼び出しの後、配置を元に戻す
- **実装**: `board[i][j] = "."`で元に戻す
- **注意**: セットを使う場合も、追加した要素を削除する必要がある

### 4. 時間計算量の理解
- **平均**: O(9^m) - mは空のマスの数
- **最悪**: O(9^m) - 常に指数時間
- **空間**: O(1) - 盤を直接変更するため
- **注意**: 実際には早期終了により、大幅に短縮される

### 5. 唯一解の保証
- **問題**: 数独パズルが唯一解を持つかどうか
- **解決策**: 解が見つかった後、他の解が存在するかチェック
- **実装**: 最初の解を見つけた後、続けて探索
- **注意**: 唯一解を保証する必要がある場合は、全ての解を探索

### 6. メモ化の可能性
- **問題**: 同じ状態が複数回計算される可能性があるか？
- **解決策**: この問題では、各状態は1回だけ訪問されるため、メモ化は不要
- **理由**: 探索木がDAGであり、重複がない
- **注意**: 他の制約充足問題では、メモ化が有効な場合がある

### 7. ヒューリスティックの活用
- **問題**: どの数字を先に試すかが重要
- **解決策**: 制約が厳しい数字（候補が少ない）から試す
- **実装**: 各数字の候補数を計算し、少ない順に試す
- **メリット**: 探索空間を削減

### 8. 初期状態の前処理
- **問題**: 初期状態から確定できるマスを先に埋める
- **解決策**: 制約から確定できるマスを前処理で埋める
- **実装**: 各空のマスについて、候補が1つだけの場合は確定
- **メリット**: 探索空間を削減

## 関連問題

- [Valid Sudoku](../leetcode/medium/) - 数独の有効性チェック
- [N-Queens](./n_queens_logic.md) - 制約充足問題の基本
- [Word Search](../leetcode/medium/) - グリッド上のパス探索
- [Combination Sum](./combination_sum_logic.md) - 組み合わせ問題

---

**次のステップ**: [Combination Sum](./combination_sum_logic.md)で組み合わせ問題を学ぶ

