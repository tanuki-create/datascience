# Generate Parentheses - ロジック解説

## 問題概要

n組の括弧が与えられたとき、有効な括弧の組み合わせを全て生成する。

**制約**:
- `1 <= n <= 8`
- 有効な括弧の組み合わせ: 開き括弧と閉じ括弧が正しく対応している

**例**:
```
Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]
説明: 3組の括弧で作れる全ての有効な組み合わせ
```

## ロジックの核心

### なぜバックトラッキングが有効か？

**全探索（非効率）**:
- 全ての可能な文字列を生成してから、有効性をチェック
- 時間計算量: O(2^(2n) × n) - 非効率

**バックトラッキングを使う理由**:
- **制約を満たすものだけを生成**: 無効な括弧の組み合わせを生成しない
- **早期終了**: 制約を満たさない場合は即座に戻る
- **時間計算量**: O(4^n / √n) - カタラン数の数だけ解が存在

### 思考プロセス

1. **制約の理解**: 
   - 開き括弧の数 <= n
   - 閉じ括弧の数 <= 開き括弧の数（常に有効な状態を保つ）

2. **選択肢の生成**:
   - 開き括弧を追加できる場合: `open < n`
   - 閉じ括弧を追加できる場合: `close < open`

3. **バックトラック**:
   - 選択を試した後、状態を戻して別の選択を試す

### アルゴリズムのステップ

```
function generateParentheses(n):
    result = []
    
    function backtrack(current, open, close):
        // ベースケース: 長さが2nになったら結果に追加
        if len(current) == 2 * n:
            result.append(current)
            return
        
        // 開き括弧を追加できる場合
        if open < n:
            backtrack(current + "(", open + 1, close)
        
        // 閉じ括弧を追加できる場合（開き括弧より少ない場合のみ）
        if close < open:
            backtrack(current + ")", open, close + 1)
    
    backtrack("", 0, 0)
    return result
```

### 疑似コード

```
function generateParentheses(n):
    result = []
    
    function backtrack(s, open_count, close_count):
        // 終了条件: 長さが2n
        if len(s) == 2 * n:
            result.append(s)
            return
        
        // 開き括弧を追加
        if open_count < n:
            backtrack(s + "(", open_count + 1, close_count)
        
        // 閉じ括弧を追加（開き括弧より少ない場合のみ）
        if close_count < open_count:
            backtrack(s + ")", open_count, close_count + 1)
    
    backtrack("", 0, 0)
    return result
```

## 具体例でのトレース

### 例: `n = 3`

```
初期状態: current = "", open = 0, close = 0

レベル0: ""
├─ レベル1: "(" (open=1, close=0)
│  ├─ レベル2: "((" (open=2, close=0)
│  │  ├─ レベル3: "(((" (open=3, close=0)
│  │  │  ├─ レベル4: "((()" (open=3, close=1)
│  │  │  │  ├─ レベル5: "((())" (open=3, close=2)
│  │  │  │  │  └─ レベル6: "((()))" ✓ 結果に追加
│  │  │  │  └─ レベル5: "((()" (別の選択肢なし)
│  │  │  └─ レベル4: "(((" (別の選択肢なし)
│  │  └─ レベル3: "(()" (open=2, close=1)
│  │     ├─ レベル4: "(()(" (open=3, close=1)
│  │     │  ├─ レベル5: "(()()" (open=3, close=2)
│  │     │  │  └─ レベル6: "(()())" ✓ 結果に追加
│  │     │  └─ レベル5: "(()(" (別の選択肢なし)
│  │     └─ レベル4: "(())" (open=2, close=2)
│  │        ├─ レベル5: "(())(" (open=3, close=2)
│  │        │  └─ レベル6: "(())()" ✓ 結果に追加
│  │        └─ レベル5: "(())" (別の選択肢なし)
│  └─ レベル2: "()" (open=1, close=1)
│     ├─ レベル3: "()(" (open=2, close=1)
│     │  ├─ レベル4: "()((" (open=3, close=1)
│     │  │  ├─ レベル5: "()(()" (open=3, close=2)
│     │  │  │  └─ レベル6: "()(())" ✓ 結果に追加
│     │  │  └─ レベル5: "()((" (別の選択肢なし)
│     │  └─ レベル4: "()()" (open=2, close=2)
│     │     ├─ レベル5: "()()(" (open=3, close=2)
│     │     │  └─ レベル6: "()()()" ✓ 結果に追加
│     │     └─ レベル5: "()()" (別の選択肢なし)
│     └─ レベル3: "()" (別の選択肢なし)
└─ レベル1: "" (開き括弧なしは不可能)

結果: ["((()))","(()())","(())()","()(())","()()()"]
```

### 可視化

```
n = 3 の場合の探索木:

                    ""
                   /
                  "("
                 /   \
            "(("     "()"
           /   \      |
        "((("  "(()"  "()("
         |     /  \   /   \
      "((()" "(())" "()((" "()()"
        |      |     |      |
     "((())" "(())(" "()(()" "()()("
       |        |       |        |
   "((()))" "(())()" "()(())" "()()()"
```

## 現実世界での応用

### 1. プログラミング言語のパーサー
- **シナリオ**: コードの構文解析で、括弧の対応を確認
- **実装**: 有効な括弧の組み合わせを生成して、構文の検証に使用
- **例**: コンパイラが括弧の対応をチェックする際のテストケース生成
- **メリット**: 構文解析の正確性を保証

### 2. 数式エディタ
- **シナリオ**: 数学的な式を入力する際、有効な括弧の組み合わせを提案
- **実装**: ユーザーの入力に基づいて、有効な括弧の組み合わせを生成
- **例**: LaTeXエディタで、括弧の自動補完機能
- **メリット**: ユーザーの入力ミスを防ぐ

### 3. コードフォーマッター
- **シナリオ**: コードの自動フォーマットで、括弧の配置を最適化
- **実装**: 有効な括弧の組み合わせを生成して、読みやすい形式を選択
- **例**: PrettierやBlackなどのコードフォーマッター
- **メリット**: コードの可読性を向上

### 4. 正規表現の生成
- **シナリオ**: 正規表現エンジンで、括弧を使ったパターンマッチング
- **実装**: 有効な括弧の組み合わせを生成して、パターンを構築
- **例**: 正規表現の括弧グループの生成
- **メリット**: 複雑なパターンマッチングを実現

### 5. データ構造のシリアライゼーション
- **シナリオ**: ネストしたデータ構造を文字列に変換
- **実装**: 有効な括弧の組み合わせを使って、データ構造を表現
- **例**: JSONやXMLのパースで、括弧の対応を確認
- **メリット**: データの整合性を保証

### 6. ゲーム開発（パズルゲーム）
- **シナリオ**: パズルゲームで、括弧を使った問題を生成
- **実装**: 有効な括弧の組み合わせを生成して、問題を作成
- **例**: 括弧の対応を正しく理解するパズルゲーム
- **メリット**: 教育的なゲームコンテンツの作成

## 注意点と落とし穴

### 1. 制約の正確な理解
- **問題**: 開き括弧と閉じ括弧の数の制約を正確に理解する必要がある
- **解決策**: 
  - 開き括弧の数 <= n
  - 閉じ括弧の数 <= 開き括弧の数（常に有効な状態を保つ）
- **注意**: 閉じ括弧を先に追加すると、無効な状態になる

### 2. 状態の管理
- **問題**: 再帰呼び出しで状態（開き括弧数、閉じ括弧数）を正確に管理する必要がある
- **解決策**: 状態を引数として渡すことで、バックトラック時に自動的に戻る
- **実装**: `backtrack(current, open, close)`で状態を管理
- **注意**: グローバル変数を使うと、バックトラック時に状態が戻らない

### 3. 文字列の連結のコスト
- **問題**: 文字列の連結はO(n)の時間がかかる
- **解決策**: リストを使って文字を追加し、最後に結合する
- **実装**: `current = ["(", "(", ...]`として管理し、最後に`"".join(current)`
- **メリット**: 時間計算量を改善できる場合がある

### 4. メモ化の必要性
- **問題**: 同じ状態が複数回計算される可能性があるか？
- **解決策**: この問題では、各状態は1回だけ訪問されるため、メモ化は不要
- **理由**: 探索木がDAG（有向非巡回グラフ）であり、重複がない
- **注意**: 他のバックトラッキング問題では、メモ化が有効な場合がある

### 5. 時間計算量の理解
- **平均**: O(4^n / √n) - カタラン数の数だけ解が存在
- **最悪**: O(4^n / √n) - 常に同じ時間計算量
- **空間**: O(n) - 再帰の深さが最大n
- **注意**: nが大きい場合、解の数が指数関数的に増える

### 6. カタラン数との関係
- **問題**: この問題の解の数はカタラン数C_nに等しい
- **公式**: C_n = (2n)! / ((n+1)! × n!)
- **例**: n=3の場合、C_3 = 5（5つの解が存在）
- **応用**: カタラン数は多くの組み合わせ問題で出現する

### 7. バックトラッキングの基本パターン
- **パターン**: 
  1. 終了条件をチェック
  2. 可能な選択肢を試す
  3. 再帰的に次のステップに進む
  4. バックトラック（自動的に状態が戻る）
- **注意**: このパターンは他のバックトラッキング問題でも使用される

### 8. 早期終了の重要性
- **問題**: 無効な状態を早期に検出することで、探索を効率化
- **解決策**: 制約チェックを各ステップで行い、無効な場合は即座に戻る
- **実装**: `if close < open:`で制約をチェック
- **メリット**: 無効な状態を生成しないため、効率的

## 関連問題

- [Valid Parentheses](../04_stack_queue/valid_parentheses_logic.md) - 括弧の有効性チェック
- [Remove Invalid Parentheses](../leetcode/hard/) - 無効な括弧を削除
- [Different Ways to Add Parentheses](../leetcode/medium/) - 括弧の配置による計算結果
- [Score of Parentheses](../leetcode/medium/) - 括弧のスコア計算

---

**次のステップ**: [N-Queens](./n_queens_logic.md)でより複雑な制約充足問題を学ぶ

