# Combinatorics - ロジック解説

## 問題概要

整数`n`と`k`が与えられたとき、組み合わせC(n,k)と順列P(n,k)を計算する。

**制約**:
- `0 <= k <= n <= 10^6`
- モジュラー演算を使用（mod = 10^9 + 7）

**例**:
```
Input: n = 5, k = 2
Output: C(5,2) = 10, P(5,2) = 20
説明: 
- C(5,2) = 5! / (2! * 3!) = 10
- P(5,2) = 5! / 3! = 20
```

## ロジックの核心

### なぜ動的計画法が有効か？

**階乗の直接計算（O(n)）**:
- n!を直接計算してから割り算
- 時間計算量: O(n) - 大きなnでオーバーフロー

**動的計画法を使う理由**:
- **パスカルの三角形**: C(n,k) = C(n-1,k-1) + C(n-1,k)
- **時間計算量**: O(n×k) - 効率的
- **モジュラー演算**: オーバーフローを回避

### 思考プロセス

1. **パスカルの三角形**: C(n,k) = C(n-1,k-1) + C(n-1,k)
2. **階乗の事前計算**: n!を事前に計算
3. **逆元の計算**: モジュラー逆元を使用して除算

### アルゴリズムのステップ

```
function combination(n, k, mod):
    if k > n or k < 0:
        return 0
    
    // 階乗の事前計算
    fact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i-1] * i % mod
    
    // 逆元の計算
    inv_fact = [1] * (n + 1)
    inv_fact[n] = pow(fact[n], mod - 2, mod)
    for i in range(n, 0, -1):
        inv_fact[i-1] = inv_fact[i] * i % mod
    
    // 組み合わせの計算
    return fact[n] * inv_fact[k] % mod * inv_fact[n-k] % mod

function permutation(n, k, mod):
    return fact[n] * inv_fact[n-k] % mod
```

## 具体例でのトレース

### 例: `n = 5, k = 2, mod = 10^9 + 7`

```
階乗の計算:
  fact[0] = 1
  fact[1] = 1
  fact[2] = 2
  fact[3] = 6
  fact[4] = 24
  fact[5] = 120

逆元の計算:
  inv_fact[5] = pow(120, mod-2, mod)
  inv_fact[4] = inv_fact[5] * 5 % mod
  ...

組み合わせの計算:
  C(5,2) = fact[5] * inv_fact[2] * inv_fact[3] % mod
  = 120 * inv(2) * inv(6) % mod
  = 10

結果: C(5,2) = 10
```

## 現実世界での応用

### 1. データ分析
- **シナリオ**: データ分析で、組み合わせの数を計算
- **実装**: 組み合わせ計算を使用
- **メリット**: 効率的なデータ分析

### 2. ゲーム開発
- **シナリオ**: ゲームで、確率や組み合わせを計算
- **実装**: 組み合わせ計算を使用
- **メリット**: 効率的なゲーム処理

### 3. 金融計算
- **シナリオ**: 金融計算で、投資の組み合わせを計算
- **実装**: 組み合わせ計算を使用
- **メリット**: 効率的な金融計算

### 4. 機械学習
- **シナリオ**: 機械学習で、特徴の組み合わせを計算
- **実装**: 組み合わせ計算を使用
- **メリット**: 効率的な特徴選択

### 5. 暗号化
- **シナリオ**: 暗号化で、鍵の組み合わせを計算
- **実装**: 組み合わせ計算を使用
- **メリット**: セキュリティの評価

### 6. 統計学
- **シナリオ**: 統計学で、サンプルの組み合わせを計算
- **実装**: 組み合わせ計算を使用
- **メリット**: 効率的な統計計算

## 注意点と落とし穴

### 1. モジュラー逆元の計算
- **問題**: モジュラー演算で除算を行う必要がある
- **解決策**: フェルマーの小定理を使用: a^(-1) ≡ a^(mod-2) (mod mod)
- **実装**: `pow(fact[n], mod - 2, mod)`で逆元を計算
- **注意**: modが素数の場合のみ有効

### 2. 階乗の事前計算
- **問題**: 階乗を毎回計算すると非効率
- **解決策**: 階乗を事前に計算して保存
- **実装**: `fact[i] = fact[i-1] * i % mod`で計算
- **メリット**: 複数の組み合わせ計算で効率的

### 3. 逆元の事前計算
- **問題**: 逆元を毎回計算すると非効率
- **解決策**: 逆元を事前に計算して保存
- **実装**: `inv_fact[i] = pow(fact[i], mod - 2, mod)`で計算
- **メリット**: 複数の組み合わせ計算で効率的

### 4. 時間計算量の理解
- **平均**: O(n) - 階乗と逆元の事前計算
- **最悪**: O(n) - 常に線形時間
- **空間**: O(n) - 階乗と逆元の配列
- **注意**: 事前計算後、各組み合わせ計算はO(1)

### 5. オーバーフローの注意
- **問題**: 大きな数の階乗でオーバーフローが発生する可能性
- **解決策**: モジュラー演算を使用
- **実装**: 各計算で`% mod`を適用
- **注意**: モジュラー演算を忘れると、オーバーフローが発生

### 6. エッジケースの処理
- **問題**: k > n、k < 0、n < 0の場合の処理
- **解決策**: `if k > n or k < 0: return 0`などのチェック
- **実装**: エッジケースの処理が重要
- **注意**: エッジケースを忘れると、エラーが発生

### 7. パスカルの三角形
- **問題**: パスカルの三角形を使った実装も可能
- **解決策**: C(n,k) = C(n-1,k-1) + C(n-1,k)
- **実装**: 動的計画法で計算
- **注意**: O(n×k)時間、O(k)空間

### 8. 大きなnへの対応
- **問題**: nが非常に大きい場合、階乗の事前計算が困難
- **解決策**: 必要に応じて階乗を計算、または近似を使用
- **実装**: 範囲を制限する、または近似アルゴリズムを使用
- **注意**: 実用的な範囲で使用

## 関連問題

- [Unique Paths](../leetcode/medium/) - 組み合わせの応用
- [Unique Paths II](../leetcode/medium/) - 組み合わせの応用
- [Pascal's Triangle](../leetcode/easy/) - パスカルの三角形
- [Modular Arithmetic](./modular_arithmetic_logic.md) - モジュラー演算

---

**次のステップ**: [Modular Arithmetic](./modular_arithmetic_logic.md)でモジュラー演算を学ぶ

