# 拡張ユークリッドの互除法 (Extended Euclidean Algorithm) - ロジック解説

## 問題概要

拡張ユークリッドの互除法は、2つの整数`a`と`b`に対して、**ax + by = gcd(a, b)を満たす整数x, yを求める**アルゴリズムです。モジュラー逆元の計算、一次不定方程式の求解、RSA暗号などで広く使用されます。

**例**:
```
a = 48, b = 18
gcd(48, 18) = 6
48x + 18y = 6 を満たす (x, y) = (-1, 3)
検証: 48×(-1) + 18×3 = -48 + 54 = 6 ✓
```

## ロジックの核心

### なぜ拡張ユークリッドが有効か？

**全探索（O(min(a, b))）**:
- 全ての可能なx, yの組み合わせを試す
- 時間計算量: O(min(a, b)) - 非効率

**拡張ユークリッドを使う理由**:
- **再帰的な計算**: ユークリッドの互除法を拡張
- **時間計算量**: O(log min(a, b)) - 対数時間
- **空間計算量**: O(log min(a, b)) - 再帰の深さ

### アルゴリズムのステップ

#### 再帰的な実装

```
function extendedGCD(a, b):
    if b == 0:
        return (a, 1, 0)  // gcd, x, y
    
    gcd, x1, y1 = extendedGCD(b, a % b)
    x = y1
    y = x1 - (a // b) * y1
    return (gcd, x, y)
```

#### 反復的な実装

```
function extendedGCD(a, b):
    x0, x1 = 1, 0
    y0, y1 = 0, 1
    
    while b != 0:
        q = a // b
        a, b = b, a % b
        x0, x1 = x1, x0 - q * x1
        y0, y1 = y1, y0 - q * y1
    
    return (a, x0, y0)  // gcd, x, y
```

### 具体例でのトレース

#### 例: a = 48, b = 18

**再帰的な実装でのトレース**:
```
extendedGCD(48, 18):
  a = 48, b = 18
  q = 48 // 18 = 2
  r = 48 % 18 = 12
  
  gcd, x1, y1 = extendedGCD(18, 12)
    a = 18, b = 12
    q = 18 // 12 = 1
    r = 18 % 12 = 6
    
    gcd, x1, y1 = extendedGCD(12, 6)
      a = 12, b = 6
      q = 12 // 6 = 2
      r = 12 % 6 = 0
      
      gcd, x1, y1 = extendedGCD(6, 0)
        b == 0 → return (6, 1, 0)
      
      x = y1 = 0
      y = x1 - q * y1 = 1 - 2 * 0 = 1
      return (6, 0, 1)
    
    x = y1 = 1
    y = x1 - q * y1 = 0 - 1 * 1 = -1
    return (6, 1, -1)
  
  x = y1 = -1
  y = x1 - q * y1 = 1 - 2 * (-1) = 1 + 2 = 3
  return (6, -1, 3)

結果: gcd(48, 18) = 6, x = -1, y = 3
検証: 48×(-1) + 18×3 = -48 + 54 = 6 ✓
```

**反復的な実装でのトレース**:
```
a = 48, b = 18
x0 = 1, x1 = 0
y0 = 0, y1 = 1

反復1:
  q = 48 // 18 = 2
  a, b = 18, 48 % 18 = 18, 12
  x0, x1 = 0, 1 - 2 * 0 = 0, 1
  y0, y1 = 1, 0 - 2 * 1 = 1, -2

反復2:
  q = 18 // 12 = 1
  a, b = 12, 18 % 12 = 12, 6
  x0, x1 = 1, 0 - 1 * 1 = 1, -1
  y0, y1 = -2, 1 - 1 * (-2) = -2, 3

反復3:
  q = 12 // 6 = 2
  a, b = 6, 12 % 6 = 6, 0
  x0, x1 = -1, 1 - 2 * (-1) = -1, 3
  y0, y1 = 3, -2 - 2 * 3 = 3, -8

b == 0 → 終了
結果: gcd = 6, x = -1, y = 3
```

#### モジュラー逆元の計算

**問題**: a^(-1) mod m を計算（aとmは互いに素）

```
a = 7, m = 11
7x ≡ 1 (mod 11) を満たすxを求める

拡張ユークリッドで 7x + 11y = 1 を解く:
extendedGCD(11, 7):
  extendedGCD(7, 4):
    extendedGCD(4, 3):
      extendedGCD(3, 1):
        extendedGCD(1, 0):
          return (1, 1, 0)
        x = 0, y = 1 - 3 * 0 = 1
        return (1, 0, 1)
      x = 1, y = 0 - 1 * 1 = -1
      return (1, 1, -1)
    x = -1, y = 1 - 1 * (-1) = 2
    return (1, -1, 2)
  x = 2, y = -1 - 1 * 2 = -3
  return (1, 2, -3)

結果: 7×2 + 11×(-3) = 14 - 33 = -19
      -19 mod 11 = 8
      7×8 = 56 ≡ 1 (mod 11) ✓

7^(-1) mod 11 = 8
```

## 現実世界での応用

### 1. モジュラー逆元の計算
- **シナリオ**: モジュラー演算で除算を実装
- **実装**: 拡張ユークリッドで逆元を計算
- **メリット**: 効率的なモジュラー除算

### 2. RSA暗号
- **シナリオ**: RSA暗号で秘密鍵を生成
- **実装**: 拡張ユークリッドで秘密鍵を計算
- **メリット**: 暗号化システムの実装

### 3. 一次不定方程式の求解
- **シナリオ**: ax + by = c の整数解を求める
- **実装**: 拡張ユークリッドで特殊解を求める
- **メリット**: 整数解の存在判定と計算

### 4. 中国剰余定理
- **シナリオ**: 連立合同式を解く
- **実装**: 拡張ユークリッドで係数を計算
- **メリット**: 連立合同式の求解

### 5. 組み合わせ計算
- **シナリオ**: 大きな数の組み合わせをモジュラー演算で計算
- **実装**: 拡張ユークリッドで逆元を計算
- **メリット**: 効率的な組み合わせ計算

### 6. 多項式の最大公約数
- **シナリオ**: 多項式のGCDを計算
- **実装**: 拡張ユークリッドを多項式に適用
- **メリット**: 多項式の操作

## 注意点と落とし穴

### 1. ベースケースの処理
- **問題**: b == 0の場合の処理が重要
- **解決策**: gcd(a, 0) = a, x = 1, y = 0を返す
- **実装**: `if b == 0: return (a, 1, 0)`
- **注意**: ベースケースを間違えると結果が間違う

### 2. 再帰的な関係式
- **問題**: x, yの更新式が重要
- **解決策**: `x = y1, y = x1 - (a // b) * y1`
- **実装**: ユークリッドの互除法の関係式を利用
- **注意**: 更新式を間違えると結果が間違う

### 3. 負の数の扱い
- **問題**: x, yが負になる可能性がある
- **解決策**: 必要に応じて正規化
- **実装**: モジュラー逆元の場合は正の値に変換
- **注意**: 負の値も有効な解

### 4. モジュラー逆元の存在条件
- **問題**: gcd(a, m) != 1の場合、逆元は存在しない
- **解決策**: 拡張ユークリッドでgcdを確認
- **実装**: gcd(a, m) == 1を確認してから逆元を計算
- **注意**: 存在しない場合のエラーハンドリング

### 5. オーバーフローの処理
- **問題**: 大きな数でオーバーフローが発生
- **解決策**: モジュラー演算を使用
- **実装**: 各ステップでモジュラー演算を適用
- **注意**: 中間結果のオーバーフローに注意

### 6. 再帰の深さ
- **問題**: 大きな数で再帰の深さが増加
- **解決策**: 反復的な実装を使用
- **実装**: スタックを使用して再帰を回避
- **注意**: スタックオーバーフローに注意

### 7. 解の一意性
- **問題**: 解は一意ではない（無限に存在）
- **解決策**: 特殊解を1つ求める
- **実装**: 拡張ユークリッドで特殊解を計算
- **注意**: 一般解は特殊解から導出可能

## 関連問題

- [Modular Arithmetic](./modular_arithmetic_logic.md) - モジュラー演算
- [GCD/LCM](./gcd_lcm_logic.md) - 最大公約数と最小公倍数
- [Combinatorics](./combinatorics_logic.md) - 組み合わせ計算

---

**次のステップ**: [Modular Arithmetic](./modular_arithmetic_logic.md)でモジュラー演算を学ぶ

