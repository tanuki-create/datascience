# GCD/LCM - ロジック解説

## 問題概要

2つの整数`a`と`b`が与えられたとき、最大公約数（GCD）と最小公倍数（LCM）を計算する。

**制約**:
- `1 <= a, b <= 10^9`

**例**:
```
Input: a = 48, b = 18
Output: GCD = 6, LCM = 144
説明: 
- GCD(48,18) = 6
- LCM(48,18) = 144
```

## ロジックの核心

### なぜユークリッドの互除法が有効か？

**素朴なアプローチ（O(min(a,b))）**:
- 1からmin(a,b)まで全ての数をチェック
- 時間計算量: O(min(a,b)) - 非効率

**ユークリッドの互除法を使う理由**:
- **再帰的性質**: GCD(a,b) = GCD(b, a mod b)
- **時間計算量**: O(log min(a,b)) - 対数時間
- **空間計算量**: O(1) - 定数空間

### 思考プロセス

1. **ユークリッドの互除法**: GCD(a,b) = GCD(b, a mod b)
2. **ベースケース**: b == 0の場合、aがGCD
3. **LCMの計算**: LCM(a,b) = a * b / GCD(a,b)

### アルゴリズムのステップ

```
function gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

function lcm(a, b):
    return a * b // gcd(a, b)
```

## 具体例でのトレース

### 例: `a = 48, b = 18`

```
GCD計算:
  ステップ1: a=48, b=18 → a=18, b=48%18=12
  ステップ2: a=18, b=12 → a=12, b=18%12=6
  ステップ3: a=12, b=6 → a=6, b=12%6=0
  ステップ4: b=0 → GCD=6

LCM計算:
  LCM(48,18) = 48 * 18 / 6 = 144

結果: GCD=6, LCM=144
```

## 現実世界での応用

### 1. 分数の約分
- **シナリオ**: 分数を約分する際、GCDを使用
- **実装**: GCDで分子と分母を割る
- **メリット**: 効率的な分数の処理

### 2. 暗号化システム
- **シナリオ**: RSA暗号で、公開鍵と秘密鍵の生成にGCDを使用
- **実装**: GCDで互いに素な数を生成
- **メリット**: セキュアな暗号化

### 3. コンピュータグラフィックス
- **シナリオ**: グラフィックスで、アスペクト比を計算
- **実装**: GCDでアスペクト比を約分
- **メリット**: 効率的なグラフィックス処理

### 4. 音楽理論
- **シナリオ**: 音楽で、リズムパターンの周期を計算
- **実装**: LCMで周期を計算
- **メリット**: 効率的な音楽処理

### 5. スケジューリング
- **シナリオ**: タスクのスケジューリングで、周期を計算
- **実装**: LCMで周期を計算
- **メリット**: 効率的なスケジューリング

### 6. データ分析
- **シナリオ**: データ分析で、データの周期を計算
- **実装**: LCMで周期を計算
- **メリット**: 効率的なデータ分析

## 注意点と落とし穴

### 1. ユークリッドの互除法の実装
- **問題**: 再帰的または反復的に実装可能
- **解決策**: 反復的実装が推奨（スタックオーバーフローのリスクがない）
- **実装**: `while b != 0:`で反復
- **注意**: 再帰的実装も可能だが、深い再帰に注意

### 2. 負の数の扱い
- **問題**: 負の数が与えられた場合の処理
- **解決策**: 絶対値を取る
- **実装**: `a, b = abs(a), abs(b)`で処理
- **注意**: GCDとLCMは非負の値

### 3. ゼロの扱い
- **問題**: aまたはbが0の場合の処理
- **解決策**: 
  - GCD(0,b) = b, GCD(a,0) = a
  - LCM(0,b) = 0, LCM(a,0) = 0
- **実装**: エッジケースの処理が重要
- **注意**: ゼロの扱いを明確にする必要がある

### 4. 時間計算量の理解
- **平均**: O(log min(a,b)) - ユークリッドの互除法
- **最悪**: O(log min(a,b)) - 常に対数時間
- **空間**: O(1) - 定数空間
- **メリット**: O(min(a,b))からO(log min(a,b))に改善

### 5. LCMの計算
- **問題**: LCMを効率的に計算する必要がある
- **解決策**: LCM(a,b) = a * b / GCD(a,b)
- **実装**: GCDを計算してからLCMを計算
- **注意**: オーバーフローに注意（a * bが大きい場合）

### 6. 拡張ユークリッドの互除法
- **問題**: ax + by = GCD(a,b)となるx,yを見つける必要がある場合
- **解決策**: 拡張ユークリッドの互除法を使用
- **実装**: 再帰的にx,yを計算
- **注意**: モジュラー逆元の計算に使用される

### 7. 複数の数のGCD/LCM
- **問題**: 3つ以上の数のGCD/LCMを計算する必要がある場合
- **解決策**: GCD(a,b,c) = GCD(GCD(a,b), c)
- **実装**: 順次GCD/LCMを計算
- **注意**: 順次計算で拡張可能

### 8. オーバーフローの注意
- **問題**: LCM計算でa * bがオーバーフローする可能性
- **解決策**: `a // gcd(a,b) * b`で計算順序を変更
- **実装**: 先に割り算してから掛け算
- **注意**: 計算順序が重要

## 関連問題

- [Sieve of Eratosthenes](./sieve_of_eratosthenes_logic.md) - 素数の列挙
- [Combinatorics](./combinatorics_logic.md) - 組み合わせの計算
- [Modular Arithmetic](./modular_arithmetic_logic.md) - モジュラー演算
- [Water and Jug Problem](../leetcode/medium/) - GCDの応用

---

**次のステップ**: [Sieve of Eratosthenes](./sieve_of_eratosthenes_logic.md)で素数の列挙を学ぶ

