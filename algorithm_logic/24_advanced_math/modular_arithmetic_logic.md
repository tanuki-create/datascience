# Modular Arithmetic - ロジック解説

## 問題概要

大きな数のべき乗`a^b mod m`を効率的に計算する。

**制約**:
- `1 <= a, b <= 10^9`
- `1 <= m <= 10^9`

**例**:
```
Input: a = 2, b = 10, m = 1000
Output: 24
説明: 2^10 = 1024, 1024 mod 1000 = 24
```

## ロジックの核心

### なぜバイナリべき乗が有効か？

**素朴なアプローチ（O(b)）**:
- aをb回掛ける
- 時間計算量: O(b) - bが大きい場合、非効率

**バイナリべき乗を使う理由**:
- **指数の分割**: bを2進数表現に分解
- **時間計算量**: O(log b) - 対数時間
- **空間計算量**: O(1) - 定数空間

### 思考プロセス

1. **指数の2進数表現**: bを2進数に分解
2. **累乗の計算**: a^(2^i)を順次計算
3. **結果の統合**: 2進数のビットが1の位置の累乗を掛け合わせる

### アルゴリズムのステップ

```
function modularExponentiation(a, b, m):
    result = 1
    a = a % m
    
    while b > 0:
        // bの最下位ビットが1の場合
        if b % 2 == 1:
            result = (result * a) % m
        
        // aを2乗
        a = (a * a) % m
        // bを右シフト
        b //= 2
    
    return result
```

## 具体例でのトレース

### 例: `a = 2, b = 10, m = 1000`

```
初期状態:
  result = 1
  a = 2
  b = 10 (binary: 1010)

ステップ1: b=10, b%2=0
  a = 2^2 = 4
  b = 5

ステップ2: b=5, b%2=1
  result = 1 * 4 = 4
  a = 4^2 = 16
  b = 2

ステップ3: b=2, b%2=0
  a = 16^2 = 256
  b = 1

ステップ4: b=1, b%2=1
  result = 4 * 256 = 1024
  a = 256^2 = 65536
  b = 0

結果: 1024 % 1000 = 24
```

## 現実世界での応用

### 1. 暗号化システム
- **シナリオ**: RSA暗号で、大きな数のべき乗を計算
- **実装**: モジュラーべき乗で効率的に計算
- **メリット**: セキュアな暗号化

### 2. ハッシュ関数
- **シナリオ**: ハッシュ関数で、大きな数のべき乗を計算
- **実装**: モジュラーべき乗で効率的に計算
- **メリット**: 効率的なハッシュ計算

### 3. 乱数生成
- **シナリオ**: 乱数生成器で、大きな数のべき乗を計算
- **実装**: モジュラーべき乗で効率的に計算
- **メリット**: 効率的な乱数生成

### 4. データベース
- **シナリオ**: データベースで、ハッシュ関数を実装
- **実装**: モジュラーべき乗で効率的に計算
- **メリット**: 効率的なハッシュ計算

### 5. 金融計算
- **シナリオ**: 金融計算で、複利を計算
- **実装**: モジュラーべき乗で効率的に計算
- **メリット**: 効率的な金融計算

### 6. ゲーム開発
- **シナリオ**: ゲームで、確率や組み合わせを計算
- **実装**: モジュラーべき乗で効率的に計算
- **メリット**: 効率的なゲーム処理

## 注意点と落とし穴

### 1. モジュラー演算の性質
- **問題**: モジュラー演算の性質を理解する必要がある
- **解決策**: (a * b) % m = ((a % m) * (b % m)) % m
- **実装**: 各計算で`% m`を適用
- **注意**: モジュラー演算を忘れると、オーバーフローが発生

### 2. オーバーフローの注意
- **問題**: 中間結果がオーバーフローする可能性
- **解決策**: 各計算でモジュラー演算を適用
- **実装**: `result = (result * a) % m`で計算
- **注意**: モジュラー演算を忘れると、誤った結果が返される

### 3. 時間計算量の理解
- **平均**: O(log b) - 指数のビット数に比例
- **最悪**: O(log b) - 常に対数時間
- **空間**: O(1) - 定数空間
- **メリット**: O(b)からO(log b)に改善

### 4. 指数が0の場合
- **問題**: b = 0の場合の処理
- **解決策**: a^0 = 1
- **実装**: `if b == 0: return 1`などのチェック
- **注意**: エッジケースの処理が重要

### 5. 底が0の場合
- **問題**: a = 0の場合の処理
- **解決策**: 0^b = 0 (b > 0), 0^0 = 1
- **実装**: `if a == 0: return 0 if b > 0 else 1`
- **注意**: エッジケースの処理が重要

### 6. モジュロが1の場合
- **問題**: m = 1の場合の処理
- **解決策**: 任意の数 mod 1 = 0
- **実装**: `if m == 1: return 0`
- **注意**: エッジケースの処理が重要

### 7. 負の指数
- **問題**: 負の指数の場合の処理
- **解決策**: a^(-b) = (a^(-1))^b mod m
- **実装**: 逆元を計算してからべき乗
- **注意**: モジュラー逆元の計算が必要

### 8. フェルマーの小定理
- **問題**: mが素数の場合、a^(m-1) ≡ 1 (mod m)
- **解決策**: 指数をm-1で割った余りを使用
- **実装**: `b = b % (m - 1)`で最適化
- **注意**: mが素数の場合のみ有効

## 関連問題

- [Pow(x, n)](../18_divide_conquer/pow_x_n_logic.md) - べき乗の計算
- [Super Pow](../leetcode/medium/) - 大きな指数の計算
- [GCD/LCM](./gcd_lcm_logic.md) - 最大公約数と最小公倍数
- [Combinatorics](./combinatorics_logic.md) - 組み合わせの計算

---

**次のステップ**: [Segment Treeテクニック](../25_segment_tree/README.md)でセグメント木を学ぶ

