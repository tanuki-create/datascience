# Sieve of Eratosthenes - ロジック解説

## 問題概要

整数`n`が与えられたとき、n以下の全ての素数を返す。

**制約**:
- `2 <= n <= 10^6`

**例**:
```
Input: n = 10
Output: [2,3,5,7]
説明: 10以下の素数は2,3,5,7
```

## ロジックの核心

### なぜエラトステネスの篩が有効か？

**素朴なアプローチ（O(n√n)）**:
- 各数について、2から√nまで全ての数で割り切れるかチェック
- 時間計算量: O(n√n) - 非効率

**エラトステネスの篩を使う理由**:
- **合成数の除去**: 各素数の倍数を順次除去
- **時間計算量**: O(n log log n) - ほぼ線形時間
- **空間計算量**: O(n) - ブール配列

### 思考プロセス

1. **初期化**: 全ての数を素数としてマーク
2. **篩い落とし**: 各素数の倍数を合成数としてマーク
3. **素数の収集**: 素数としてマークされた数を収集

### アルゴリズムのステップ

```
function sieveOfEratosthenes(n):
    // 全ての数を素数として初期化
    is_prime = [True] * (n + 1)
    is_prime[0] = is_prime[1] = False
    
    // 2から√nまで篩い落とし
    for i in range(2, int(n**0.5) + 1):
        if is_prime[i]:
            // iの倍数を合成数としてマーク
            for j in range(i*i, n + 1, i):
                is_prime[j] = False
    
    // 素数を収集
    primes = []
    for i in range(2, n + 1):
        if is_prime[i]:
            primes.append(i)
    
    return primes
```

## 具体例でのトレース

### 例: `n = 20`

```
初期状態:
  is_prime = [False,False,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True]

i=2: 2は素数
  4,6,8,10,12,14,16,18,20をFalseに
  is_prime = [False,False,True,True,False,True,False,True,False,True,False,True,False,True,False,True,False,True,False,True,False]

i=3: 3は素数
  9,15をFalseに（6,12,18は既にFalse）
  is_prime = [False,False,True,True,False,True,False,True,False,False,False,True,False,True,False,False,False,True,False,True,False]

i=4: 4は合成数（既にFalse）→ スキップ

i=5: 5は素数
  25は20を超える → スキップ

結果: [2,3,5,7,11,13,17,19]
```

## 現実世界での応用

### 1. 暗号化システム
- **シナリオ**: RSA暗号で、大きな素数を生成
- **実装**: エラトステネスの篩で素数を列挙
- **メリット**: セキュアな暗号化

### 2. データ分析
- **シナリオ**: データ分析で、素数のパターンを分析
- **実装**: エラトステネスの篩で素数を列挙
- **メリット**: 効率的なデータ分析

### 3. 数学的研究
- **シナリオ**: 数学的研究で、素数の分布を研究
- **実装**: エラトステネスの篩で素数を列挙
- **メリット**: 効率的な数学的研究

### 4. コンピュータグラフィックス
- **シナリオ**: グラフィックスで、ハッシュ関数に素数を使用
- **実装**: エラトステネスの篩で素数を列挙
- **メリット**: 効率的なグラフィックス処理

### 5. データベース
- **シナリオ**: データベースで、ハッシュテーブルのサイズに素数を使用
- **実装**: エラトステネスの篩で素数を列挙
- **メリット**: 効率的なハッシュ計算

### 6. ゲーム開発
- **シナリオ**: ゲームで、乱数生成に素数を使用
- **実装**: エラトステネスの篩で素数を列挙
- **メリット**: 効率的な乱数生成

## 注意点と落とし穴

### 1. 開始位置の最適化
- **問題**: iの倍数を篩い落とす際、i²から開始する
- **解決策**: i²より小さい倍数は既に篩い落とされている
- **実装**: `for j in range(i*i, n + 1, i):`
- **メリット**: 効率化

### 2. √nまでの走査
- **問題**: なぜ√nまで走査すれば十分か？
- **解決策**: √nより大きい数の倍数は既に篩い落とされている
- **実装**: `for i in range(2, int(n**0.5) + 1):`
- **メリット**: 効率化

### 3. 時間計算量の理解
- **平均**: O(n log log n) - ほぼ線形時間
- **最悪**: O(n log log n) - 常に同じ時間計算量
- **空間**: O(n) - ブール配列
- **メリット**: O(n√n)からO(n log log n)に改善

### 4. メモリ使用量
- **問題**: 大きなnでメモリを大量に消費する可能性
- **解決策**: ビットセットを使用してメモリを削減
- **実装**: `bitarray`や`bitstring`を使用
- **メリット**: メモリ使用量を1/8に削減

### 5. セグメント化された篩
- **問題**: 非常に大きなnでメモリが不足する場合
- **解決策**: セグメント化された篩を使用
- **実装**: 範囲を分割して篩い落とし
- **メリット**: メモリ効率的な処理

### 6. エッジケースの処理
- **問題**: n < 2の場合の処理
- **解決策**: `if n < 2: return []`などのチェック
- **実装**: エッジケースの処理が重要
- **注意**: エッジケースを忘れると、エラーが発生

### 7. 素数の数のカウント
- **問題**: 素数のリストだけでなく、素数の数が必要な場合
- **解決策**: `sum(is_prime)`でカウント
- **実装**: ブール配列の合計でカウント
- **注意**: リストを作成するより効率的

### 8. 範囲の素数の検索
- **問題**: [L, R]の範囲の素数を検索する必要がある場合
- **解決策**: セグメント化された篩を使用
- **実装**: √Rまでの素数で篩い落とし
- **メリット**: 効率的な範囲検索

## 関連問題

- [Count Primes](../leetcode/medium/) - 素数の数
- [Prime Number of Set Bits](../leetcode/easy/) - 素数の応用
- [GCD/LCM](./gcd_lcm_logic.md) - 最大公約数と最小公倍数
- [Combinatorics](./combinatorics_logic.md) - 組み合わせの計算

---

**次のステップ**: [Combinatorics](./combinatorics_logic.md)で組み合わせを学ぶ

