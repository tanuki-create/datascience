git add# KMP Algorithm - ロジック解説

## 問題概要

テキスト`text`とパターン`pattern`が与えられたとき、`pattern`が`text`内に出現する最初の位置を返す。

**制約**:
- `1 <= text.length, pattern.length <= 10^4`

**例**:
```
Input: text = "ABABDABACDABABCABCABAB", pattern = "ABABCABAB"
Output: 10
説明: パターンが位置10から開始
```

## ロジックの核心

### なぜKMPが有効か？

**素朴なアプローチ（O(n×m)）**:
- 各位置でパターンを比較
- 時間計算量: O(n×m) - 非効率

**KMPを使う理由**:
- **失敗関数の活用**: マッチに失敗した場合、既にマッチした部分を再利用
- **時間計算量**: O(n + m) - 線形時間
- **空間計算量**: O(m) - 失敗関数の配列

### 思考プロセス

1. **失敗関数の構築**: パターンの各位置で、最長の接頭辞と接尾辞を計算
2. **テキストの走査**: 失敗関数を使って、不要な比較をスキップ
3. **マッチの検出**: パターン全体がマッチしたら位置を返す

### アルゴリズムのステップ

```
function kmpSearch(text, pattern):
    n, m = len(text), len(pattern)
    lps = buildLPS(pattern)  // 失敗関数
    
    i = 0  // textのインデックス
    j = 0  // patternのインデックス
    
    while i < n:
        if text[i] == pattern[j]:
            i += 1
            j += 1
        
        if j == m:
            return i - j  // マッチが見つかった
        elif i < n and text[i] != pattern[j]:
            if j != 0:
                j = lps[j-1]  // 失敗関数を使用
            else:
                i += 1
    
    return -1

function buildLPS(pattern):
    m = len(pattern)
    lps = [0] * m
    length = 0
    i = 1
    
    while i < m:
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length-1]
            else:
                lps[i] = 0
                i += 1
    
    return lps
```

## 具体例でのトレース

### 例: `text = "ABABDABACDABABCABAB", pattern = "ABABCABAB"`

```
LPS構築:
  pattern = "ABABCABAB"
  lps = [0,0,1,2,0,1,2,3,4]

検索:
  i=0, j=0: 'A'=='A' → i=1, j=1
  i=1, j=1: 'B'=='B' → i=2, j=2
  i=2, j=2: 'A'=='A' → i=3, j=3
  i=3, j=3: 'B'=='B' → i=4, j=4
  i=4, j=4: 'D'!='C' → j=lps[3]=2
  i=4, j=2: 'D'!='A' → j=lps[1]=0
  i=4, j=0: 'D'!='A' → i=5
  ... 続けて検索

結果: 10
```

## 現実世界での応用

### 1. テキストエディタの検索機能
- **シナリオ**: Vim、VS Codeなどの検索機能
- **実装**: KMPアルゴリズムでパターンを検索
- **メリット**: 高速なテキスト検索

### 2. 検索エンジン
- **シナリオ**: Google検索エンジン
- **実装**: KMPでキーワードを検索
- **メリット**: 効率的なキーワード検索

### 3. コンパイラの構文解析
- **シナリオ**: プログラミング言語のコンパイラ
- **実装**: KMPでキーワードや演算子を検索
- **メリット**: 高速な構文解析

### 4. DNA配列解析
- **シナリオ**: バイオインフォマティクスでのDNA配列の検索
- **実装**: KMPでパターンを検索
- **メリット**: 効率的なDNA配列解析

### 5. ネットワークセキュリティ
- **シナリオ**: 侵入検知システムでのパターンマッチング
- **実装**: KMPで悪意のあるパターンを検出
- **メリット**: リアルタイムの脅威検出

### 6. データ圧縮
- **シナリオ**: データ圧縮アルゴリズムでの文字列マッチング
- **実装**: KMPで繰り返しパターンを検出
- **メリット**: 効率的なデータ圧縮

## 注意点と落とし穴

### 1. 失敗関数の構築
- **問題**: 失敗関数（LPS）の構築が複雑
- **解決策**: パターンの最長の接頭辞と接尾辞を事前に計算
- **実装**: `buildLPS`関数で構築
- **注意**: 失敗関数の構築が重要

### 2. 接頭辞と接尾辞の理解
- **問題**: 最長の接頭辞と接尾辞の概念を理解する必要がある
- **解決策**: パターンの各位置で、最長の一致する接頭辞と接尾辞を計算
- **実装**: `lps[i]`が`pattern[0..i]`の最長の接頭辞と接尾辞の長さ
- **注意**: 接頭辞と接尾辞の概念が重要

### 3. 時間計算量の理解
- **平均**: O(n + m) - テキストとパターンを1回ずつ走査
- **最悪**: O(n + m) - 常に線形時間
- **空間**: O(m) - 失敗関数の配列
- **メリット**: O(n×m)からO(n + m)に改善

### 4. マッチの検出
- **問題**: パターン全体がマッチしたら位置を返す
- **解決策**: `j == m`でマッチを検出
- **実装**: `return i - j`で開始位置を返す
- **注意**: 全てのマッチを見つける場合は、続けて検索

### 5. 失敗時の処理
- **問題**: マッチに失敗した場合、どこまで戻るか
- **解決策**: 失敗関数を使って、既にマッチした部分を再利用
- **実装**: `j = lps[j-1]`で戻る
- **注意**: 失敗関数がない場合（j=0）、テキストのポインタを進める

### 6. 全てのマッチを見つける
- **問題**: 最初のマッチだけでなく、全てのマッチを見つける必要がある場合
- **解決策**: マッチを見つけた後、`j = lps[j-1]`で続けて検索
- **実装**: `if j == m:`の後、`j = lps[j-1]`で続ける
- **注意**: 全てのマッチを見つける場合は、実装を変更する必要がある

### 7. 空のパターン
- **問題**: パターンが空の場合の処理
- **解決策**: `if m == 0: return 0`などのチェック
- **実装**: エッジケースの処理が重要
- **注意**: エッジケースを忘れると、エラーが発生

### 8. 大文字小文字の扱い
- **問題**: 大文字小文字を区別するかどうか
- **解決策**: 問題の要件に応じて、小文字に統一
- **実装**: `text.lower()`と`pattern.lower()`で統一
- **注意**: 問題の要件を確認する必要がある

## 関連問題

- [Rabin-Karp](./rabin_karp_logic.md) - ローリングハッシュ
- [Manacher's Algorithm](./manacher_algorithm_logic.md) - パリンドローム検出
- [Shortest Palindrome](../leetcode/hard/) - KMPの応用
- [Repeated String Match](../leetcode/medium/) - KMPの応用

---

**次のステップ**: [Rabin-Karp](./rabin_karp_logic.md)でローリングハッシュを学ぶ

