# Rabin-Karp Algorithm - ロジック解説

## 問題概要

テキスト`text`とパターン`pattern`が与えられたとき、`pattern`が`text`内に出現する全ての位置を返す。Rabin-Karpアルゴリズム（ローリングハッシュ）を使用する。

**制約**:
- `1 <= text.length, pattern.length <= 10^4`

**例**:
```
Input: text = "ABABDABACDABABCABCABAB", pattern = "ABAB"
Output: [0, 10, 12, 16]
説明: パターンが複数の位置に出現
```

## ロジックの核心

### なぜローリングハッシュが有効か？

**素朴なアプローチ（O(n×m)）**:
- 各位置でパターンを比較
- 時間計算量: O(n×m) - 非効率

**ローリングハッシュを使う理由**:
- **ハッシュの再利用**: 前のウィンドウのハッシュから次のウィンドウのハッシュをO(1)で計算
- **時間計算量**: O(n + m)平均 - ハッシュの衝突が少ない場合
- **空間計算量**: O(1) - 追加の空間は定数

### 思考プロセス

1. **パターンのハッシュ**: パターンのハッシュ値を計算
2. **テキストのハッシュ**: テキストの各位置でのハッシュ値をローリングで計算
3. **マッチの検出**: ハッシュが一致した場合、実際の文字列を比較

### アルゴリズムのステップ

```
function rabinKarp(text, pattern):
    n, m = len(text), len(pattern)
    base = 256
    mod = 10**9 + 7
    
    // パターンのハッシュ
    pattern_hash = 0
    for char in pattern:
        pattern_hash = (pattern_hash * base + ord(char)) % mod
    
    // テキストの最初のウィンドウのハッシュ
    text_hash = 0
    for i in range(m):
        text_hash = (text_hash * base + ord(text[i])) % mod
    
    result = []
    base_power = pow(base, m-1, mod)
    
    for i in range(n - m + 1):
        // ハッシュが一致した場合、実際の文字列を比較
        if text_hash == pattern_hash:
            if text[i:i+m] == pattern:
                result.append(i)
        
        // 次のウィンドウのハッシュを計算
        if i < n - m:
            text_hash = ((text_hash - ord(text[i]) * base_power) * base + ord(text[i+m])) % mod
    
    return result
```

## 具体例でのトレース

### 例: `text = "ABAB", pattern = "AB"`

```
base = 256, mod = 10**9 + 7

パターンのハッシュ:
  pattern_hash = (0 * 256 + ord('A')) % mod = 65
  pattern_hash = (65 * 256 + ord('B')) % mod = 16641

テキストのハッシュ:
  i=0: text_hash = 16641
    text_hash == pattern_hash → text[0:2] == "AB" → result = [0]
    text_hash = ((16641 - ord('A')*256) * 256 + ord('A')) % mod = 16641
  i=1: text_hash = 16641
    text_hash == pattern_hash → text[1:3] == "BA" → 不一致
    text_hash = ((16641 - ord('B')*256) * 256 + ord('B')) % mod = 16641
  i=2: text_hash = 16641
    text_hash == pattern_hash → text[2:4] == "AB" → result = [0,2]

結果: [0, 2]
```

## 現実世界での応用

### 1. 検索エンジン
- **シナリオ**: Google検索エンジンで、複数のキーワードを検索
- **実装**: Rabin-Karpで複数のパターンを同時に検索
- **メリット**: 効率的なキーワード検索

### 2. テキストエディタの検索機能
- **シナリオ**: テキストエディタで、複数のパターンを検索
- **実装**: Rabin-Karpで複数のパターンを同時に検索
- **メリット**: 高速なテキスト検索

### 3. ファイルシステム
- **シナリオ**: ファイルシステムで、ファイル内容を検索
- **実装**: Rabin-Karpでパターンを検索
- **メリット**: 効率的なファイル検索

### 4. ネットワークセキュリティ
- **シナリオ**: 侵入検知システムで、複数のパターンを検出
- **実装**: Rabin-Karpで複数のパターンを同時に検索
- **メリット**: リアルタイムの脅威検出

### 5. DNA配列解析
- **シナリオ**: バイオインフォマティクスで、複数のDNAパターンを検索
- **実装**: Rabin-Karpで複数のパターンを同時に検索
- **メリット**: 効率的なDNA配列解析

### 6. データ圧縮
- **シナリオ**: データ圧縮アルゴリズムで、繰り返しパターンを検出
- **実装**: Rabin-Karpでパターンを検索
- **メリット**: 効率的なデータ圧縮

## 注意点と落とし穴

### 1. ハッシュの衝突
- **問題**: ハッシュが一致しても、実際の文字列が異なる場合がある
- **解決策**: ハッシュが一致した場合、実際の文字列を比較
- **実装**: `if text_hash == pattern_hash: if text[i:i+m] == pattern:`
- **注意**: ハッシュの衝突に注意が必要

### 2. モジュロ演算
- **問題**: 大きなハッシュ値でオーバーフローが発生する可能性
- **解決策**: モジュロ演算を使用して、ハッシュ値を制限
- **実装**: `mod = 10**9 + 7`などの大きな素数を使用
- **注意**: モジュロの選択が重要

### 3. ローリングハッシュの計算
- **問題**: 次のウィンドウのハッシュを効率的に計算
- **解決策**: 前のウィンドウのハッシュから、最初の文字を引いて、新しい文字を加える
- **実装**: `text_hash = ((text_hash - ord(text[i]) * base_power) * base + ord(text[i+m])) % mod`
- **注意**: 負の値になる可能性があるため、モジュロ演算で処理

### 4. 時間計算量の理解
- **平均**: O(n + m) - ハッシュの衝突が少ない場合
- **最悪**: O(n×m) - ハッシュの衝突が多い場合
- **空間**: O(1) - 追加の空間は定数
- **注意**: ハッシュの衝突により、最悪時間計算量が悪化する可能性がある

### 5. baseの選択
- **問題**: ハッシュのbaseをどのように選択するか
- **解決策**: 通常は256（ASCII文字数）または大きな素数
- **実装**: `base = 256`または`base = 31`など
- **注意**: baseの選択がハッシュの衝突率に影響

### 6. modの選択
- **問題**: モジュロをどのように選択するか
- **解決策**: 大きな素数を使用（10^9 + 7など）
- **実装**: `mod = 10**9 + 7`
- **注意**: modの選択がハッシュの衝突率に影響

### 7. 負の値の処理
- **問題**: モジュロ演算で負の値になる可能性がある
- **解決策**: `text_hash = (text_hash % mod + mod) % mod`で正の値に変換
- **実装**: 負の値を正の値に変換
- **注意**: 負の値の処理が重要

### 8. 複数パターンの検索
- **問題**: 複数のパターンを同時に検索する場合
- **解決策**: 各パターンのハッシュを計算し、テキストのハッシュと比較
- **実装**: パターンのハッシュをセットに保存
- **メリット**: 複数パターンの効率的な検索

## 関連問題

- [KMP Algorithm](./kmp_algorithm_logic.md) - パターンマッチングの基本
- [Manacher's Algorithm](./manacher_algorithm_logic.md) - パリンドローム検出
- [Repeated String Match](../leetcode/medium/) - Rabin-Karpの応用
- [Find All Anagrams](../leetcode/medium/) - ローリングハッシュの応用

---

**次のステップ**: [Manacher's Algorithm](./manacher_algorithm_logic.md)でパリンドローム検出を学ぶ

