# Container With Most Water - ロジック解説

## 問題概要

長さ`n`の整数配列`height`が与えられたとき、`i`番目の線の両端点は`(i, 0)`と`(i, height[i])`で表される。2本の線とx軸で囲まれる容器が含むことができる最大の水量を返す。

**制約**:
- `n == height.length`
- `2 <= n <= 10^5`
- `0 <= height[i] <= 10^4`

**例**:
```
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
説明: インデックス1と8の線（高さ8と7）で囲まれる容器の面積が最大
面積 = min(8, 7) × (8 - 1) = 7 × 7 = 49
```

## ロジックの核心

### なぜ二ポインタが有効か？

**素朴なアプローチ（O(n²)）**:
- 全てのペアをチェック: `(i, j)`の全ての組み合わせで面積を計算
- 時間計算量: O(n²) - 2重ループが必要

**二ポインタを使う理由**:
- **貪欲的なアプローチ**: 短い方の線を動かすことで、より大きな面積の可能性を探る
- **不要な探索の省略**: ある状態で短い方の線を動かさない場合、その状態より大きな面積は得られないことが証明できる
- **時間計算量**: O(n) - 1回の走査で完了

### 思考プロセス

1. **面積の計算式**: `area = min(height[left], height[right]) × (right - left)`
   - 面積は2つの線のうち**短い方の高さ**と**幅**の積で決まる
   - 高さが低い方が面積を制限する

2. **貪欲的な選択**:
   - 現在の状態: `left`と`right`の2本の線
   - 短い方の線を内側に動かす: より高い線との組み合わせを探す
   - 長い方の線を動かさない: 幅が減る一方で、高さが増える可能性は低い

3. **最適性の証明**:
   - 短い方の線（例: `height[left]`）を固定した場合、`right`を動かしても面積は増えない
   - 理由: 幅が減る一方で、高さは`min(height[left], height[right])`で制限される
   - したがって、短い方の線を動かすのが最適

### アルゴリズムのステップ

```
1. 左ポインタ left = 0、右ポインタ right = n-1 を初期化
2. max_area = 0 を初期化
3. left < right の間、以下を繰り返す:
   a. 現在の面積を計算: area = min(height[left], height[right]) × (right - left)
   b. max_area を更新: max_area = max(max_area, area)
   c. 短い方の線を内側に動かす:
      - height[left] < height[right] なら left++
      - そうでなければ right--
4. max_area を返す
```

### 疑似コード

```
function maxArea(height):
    left = 0
    right = len(height) - 1
    max_area = 0
    
    while left < right:
        // 現在の面積を計算
        area = min(height[left], height[right]) × (right - left)
        max_area = max(max_area, area)
        
        // 短い方の線を内側に動かす
        if height[left] < height[right]:
            left++
        else:
            right--
    
    return max_area
```

## 具体例でのトレース

### 例: `height = [1,8,6,2,5,4,8,3,7]`

| ステップ | left | right | height[left] | height[right] | 面積 | max_area | アクション |
|---------|------|-------|---------------|---------------|------|----------|-----------|
| 初期 | 0 | 8 | 1 | 7 | 1×8=8 | 8 | left < right → left++ |
| 1 | 1 | 8 | 8 | 7 | 7×7=49 | 49 | right > left → right-- |
| 2 | 1 | 7 | 8 | 3 | 3×6=18 | 49 | right < left → right-- |
| 3 | 1 | 6 | 8 | 8 | 8×5=40 | 49 | 等しい → left++ |
| 4 | 2 | 6 | 6 | 8 | 6×4=24 | 49 | left < right → left++ |
| 5 | 3 | 6 | 2 | 8 | 2×3=6 | 49 | left < right → left++ |
| 6 | 4 | 6 | 5 | 8 | 5×2=10 | 49 | left < right → left++ |
| 7 | 5 | 6 | 4 | 8 | 4×1=4 | 49 | left < right → left++ |
| 終了 | 6 | 6 | - | - | - | 49 | left >= right → 終了 |

**結果**: `49` - インデックス1（高さ8）とインデックス8（高さ7）の組み合わせが最大

### 可視化

```
高さ
8 |     |     |           |     |
7 |     |     |           |     |     |
6 |     |  |  |           |     |     |
5 |     |  |  |     |     |     |     |
4 |     |  |  |     |  |  |     |     |
3 |     |  |  |     |  |  |  |  |     |
2 |     |  |  |  |  |  |  |  |  |     |
1 |  |  |  |  |  |  |  |  |  |  |     |
0 |--|--|--|--|--|--|--|--|--|--|----
   0  1  2  3  4  5  6  7  8  9  インデックス

最大面積: インデックス1と8の間
面積 = min(8, 7) × (8-1) = 7 × 7 = 49
```

## 現実世界での応用

### 1. 建築設計（水槽の設計）
- **シナリオ**: 複数の壁の高さが異なる水槽で、最大の容水量を計算
- **実装**: 2つの壁を選んで、その間の最大容水量を計算
- **例**: 雨水を貯めるための水槽設計で、最適な壁の配置を決定

### 2. 金融取引（在庫管理）
- **シナリオ**: 2つの時点での在庫レベルの差を最大化
- **実装**: 時系列データから、最大の在庫差を生む2つの時点を探す
- **例**: 商品の在庫レベルが最も異なる2つの時点を特定

### 3. 画像処理（領域検出）
- **シナリオ**: 画像内の2つの点で囲まれる最大の領域を検出
- **実装**: 画像の高さ情報から、最大の矩形領域を計算
- **例**: 物体検出で、2つの特徴点間の最大領域を特定

### 4. ゲーム開発（地形生成）
- **シナリオ**: 2つの地点間で囲まれる最大の地形領域を計算
- **実装**: 地形の高さデータから、最大の容積を計算
- **例**: マインクラフトのようなゲームで、2つの地点間の最大の掘削可能領域を計算

### 5. データ分析（時系列データ）
- **シナリオ**: 2つの時点での値の差を最大化する組み合わせを探す
- **実装**: 時系列データから、最大の差を生む2つの時点を特定
- **例**: 株価データで、2つの時点間の最大の価格差を計算

## 注意点と落とし穴

### 1. 貪欲法の正しさの理解
- **問題**: なぜ短い方の線を動かすのが最適なのか？
- **証明**: 
  - 現在の状態: `left`と`right`で、`height[left] < height[right]`とする
  - `left`を固定した場合: `right`を`right-1`に動かすと、幅が1減り、高さは最大でも`height[left]`のまま
  - したがって、面積は必ず減る
  - 逆に、`left`を`left+1`に動かすと、より高い線との組み合わせの可能性がある
- **結論**: 短い方の線を動かすのが最適

### 2. 等しい高さの場合
- **問題**: `height[left] == height[right]`の場合、どちらを動かすべきか？
- **解決策**: どちらを動かしてもよい（両方動かす必要はない）
- **理由**: どちらを動かしても、もう一方との組み合わせは既に計算済み
- **実装**: `else`節で`right--`するか、`left++`するかは実装次第

### 3. 面積の計算順序
- **問題**: ポインタを動かす前に面積を計算する必要がある
- **解決策**: 面積を計算してからポインタを動かす
- **注意**: ポインタを動かしてから面積を計算すると、最初の状態がスキップされる

### 4. 初期値の設定
- **問題**: `max_area`の初期値を0にすると、全ての高さが0の場合に正しく動作する
- **解決策**: `max_area = 0`で初期化
- **注意**: 負の面積は存在しないため、0で十分

### 5. 境界条件
- **問題**: `left < right`の条件で、`left == right`の場合は処理しない
- **解決策**: これは正しい（1本の線だけでは面積は0）
- **注意**: ループの終了条件を`left <= right`にすると、不要な計算が発生する

### 6. 時間計算量の理解
- **平均**: O(n) - 各要素を1回ずつ処理
- **最悪**: O(n) - 常に線形時間
- **空間**: O(1) - 追加の空間は定数（ポインタと変数のみ）

### 7. 最適化の余地
- **早期終了**: 理論的には可能だが、実用的には効果が限定的
- **メモ化**: この問題では不要（各状態は1回しか訪問しない）

## 関連問題

同じテクニック（二ポインタ + 貪欲法）を使う問題：

1. **Trapping Rain Water** - より複雑な水の問題
2. **3Sum** - 3つの要素の組み合わせを探す
3. **Longest Substring Without Repeating Characters** - スライディングウィンドウとの組み合わせ
4. **Maximum Product Subarray** - 積を最大化する部分配列を探す

## まとめ

Container With Most Waterは、二ポインタと貪欲法を組み合わせた典型例です。重要なポイントは：

1. **貪欲的な選択**: 短い方の線を動かすことで、より大きな面積の可能性を探る
2. **最適性の証明**: 短い方の線を固定した場合、もう一方を動かしても面積は増えない
3. **O(n)時間**: 1回の走査で最適解を見つける
4. **O(1)空間**: 追加のメモリをほとんど使わない

この問題を理解することで、二ポインタと貪欲法の組み合わせが身につきます。

---

**次のステップ**: 
- [二ポインタのREADME](./README.md)に戻って他の問題も確認
- [スライディングウィンドウテクニック](../03_sliding_window/README.md)で、連続する部分配列の問題を学ぶ

