# 二ポインタ (Two Pointers)

## 概要

二ポインタテクニックは、配列や文字列を効率的に処理するための強力な手法です。2つのポインタ（インデックス）を同時に使用して、配列を1回の走査で処理することで、時間計算量を大幅に改善できます。

## 基本概念

### 二ポインタのパターン

1. **対向ポインタ（Opposite Ends）**: 配列の両端から中央に向かって移動
   - 左ポインタ: 先頭から開始
   - 右ポインタ: 末尾から開始
   - 用途: ソート済み配列での検索、回文判定など

2. **同方向ポインタ（Same Direction）**: 両方のポインタが同じ方向に移動
   - スローポインタ: ゆっくり移動
   - ファストポインタ: 速く移動
   - 用途: リンクリストのサイクル検出、配列の重複削除など

3. **スライディングウィンドウ**: 二ポインタの特殊なケース
   - 連続する部分配列を効率的に処理
   - 詳細は[スライディングウィンドウ](../03_sliding_window/README.md)を参照

### 主な操作と計算量

| パターン | 時間計算量 | 空間計算量 | 適用場面 |
|---------|-----------|-----------|---------|
| 対向ポインタ | O(n) | O(1) | ソート済み配列、回文判定 |
| 同方向ポインタ | O(n) | O(1) | 重複削除、サイクル検出 |
| スライディングウィンドウ | O(n) | O(k) | 連続する部分配列 |

**特徴**: 通常はO(1)の追加空間のみで、O(n)の時間計算量を達成できます。

## いつ使うべきか

二ポインタテクニックは以下のような場面で威力を発揮します：

### 1. ソート済み配列での検索
- 「2つの要素の合計が目標値になる組み合わせを探す」
- 「3つの要素の合計が目標値になる組み合わせを探す」
- **利点**: ソート済みという性質を活かして効率的に検索

### 2. 回文判定
- 「文字列が回文かどうか判定」
- 「配列が対称かどうか判定」
- **利点**: 両端から中央に向かって比較することで効率的に判定

### 3. 配列の重複削除
- 「ソート済み配列から重複を削除」
- 「特定の条件を満たす要素を削除」
- **利点**: 1回の走査で処理可能

### 4. 領域の最大化
- 「2つの線で囲まれる最大の面積を求める」
- 「2つの要素の間の最大の差を求める」
- **利点**: 貪欲的なアプローチで最適解を効率的に発見

### 5. マージ操作
- 「2つのソート済み配列をマージ」
- 「2つのソート済みリストをマージ」
- **利点**: 各配列を1回ずつ走査するだけでマージ可能

## 現実世界での応用例

### 1. 検索エンジンのインデックス
- **例**: ソート済みの文書IDリストから、2つのクエリの共通部分を高速に検索
- **実装**: 2つのソート済みリストを二ポインタで走査して共通要素を発見
- **メリット**: 大量のデータからもO(n + m)で処理可能

### 2. データベースのJOIN操作
- **例**: 2つのソート済みテーブルを結合
- **実装**: 二ポインタで両方のテーブルを同時に走査
- **メリット**: インデックスを活用して効率的に結合

### 3. ゲーム開発（衝突検出）
- **例**: ソート済みのオブジェクトリストから、距離が近いオブジェクトのペアを検出
- **実装**: 二ポインタで効率的にペアを探索
- **メリット**: 全ペアをチェックする必要がなく、O(n²)からO(n)に改善

### 4. 金融取引システム
- **例**: ソート済みの価格リストから、目標価格になる2つの商品の組み合わせを探す
- **実装**: 二ポインタで効率的に検索
- **メリット**: リアルタイム取引で高速な検索が必要な場合に有効

### 5. 画像処理（エッジ検出）
- **例**: 画像の端から中央に向かってエッジを検出
- **実装**: 二ポインタで両端から同時に処理
- **メリット**: 対称的な処理を効率的に実行

## 実装時の注意点

### 1. ポインタの移動条件
- **問題**: いつ、どちらのポインタを動かすべきか判断が難しい
- **解決策**: 問題の性質に応じて明確なルールを設定
  - 対向ポインタ: 条件に応じて左または右を動かす
  - 同方向ポインタ: スローポインタは条件を満たすまで動かさない

### 2. 境界条件
- **問題**: 配列の範囲外アクセス
- **解決策**: ループ条件を`left < right`や`left <= right`で適切に設定
- **注意**: インデックスの範囲を常に確認

### 3. 重複要素の扱い
- **問題**: 同じ値が複数回出現する場合の処理
- **解決策**: 重複をスキップするロジックを追加
- **例**: `while left < right and nums[left] == nums[left+1]: left += 1`

### 4. ソートの必要性
- **問題**: 多くの二ポインタ問題はソート済み配列を前提とする
- **解決策**: 必要に応じて事前にソート（O(n log n)のコスト）
- **トレードオフ**: ソートのコストと二ポインタの効率性を比較

### 5. 時間計算量の理解
- **平均**: O(n) - 各要素を1回ずつ処理
- **最悪**: O(n) - 常に線形時間
- **空間**: O(1) - 追加の空間は定数

## 関連するLeetCode/AtCoder問題

### Easy
- [Valid Palindrome](./valid_palindrome_logic.md) - 回文判定の基本
- [Remove Duplicates from Sorted Array](../leetcode/easy/015_remove_duplicates_from_sorted_array/) - 重複削除
- [Merge Sorted Array](../leetcode/easy/017_merge_sorted_array/) - マージ操作

### Medium
- [Container With Most Water](./container_with_most_water_logic.md) - 領域の最大化
- [3Sum](../leetcode/medium/041_3sum/) - 3つの要素の組み合わせ
- [Trapping Rain Water](../leetcode/medium/) - 高度な二ポインタ

### Hard
- [Trapping Rain Water II](../leetcode/hard/) - 3次元への拡張
- [Longest Valid Parentheses](../leetcode/hard/) - 複雑な境界条件

## 学習の進め方

1. **Valid Palindrome**から始める: 最もシンプルな二ポインタの例
2. **Container With Most Water**で最適化を学ぶ: 貪欲的なアプローチとの組み合わせ
3. **3Sum**で複雑な条件を学ぶ: 重複の扱いと複数のポインタ

## 次のステップ

- [Valid Palindrome のロジック解説](./valid_palindrome_logic.md)
- [Container With Most Water のロジック解説](./container_with_most_water_logic.md)
- [スライディングウィンドウテクニック](../03_sliding_window/README.md) - 二ポインタの特殊なケース

---

**重要**: 二ポインタテクニックは、配列や文字列の問題で頻繁に使用されます。ソート済み配列での検索や、回文判定など、多くの問題でO(n²)からO(n)に改善できます。

