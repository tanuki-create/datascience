# 3Sum - ロジック解説

## 問題概要

整数配列`nums`が与えられたとき、合計が0になる3つの要素の組み合わせを全て見つける。重複する組み合わせは除外する。

**制約**:
- `3 <= nums.length <= 3000`
- `-10^5 <= nums[i] <= 10^5`

**例**:
```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
```

## ロジックの核心

### なぜ二ポインタが有効か？

**全探索（O(n³)）**:
- 全ての3つの組み合わせを試す
- 時間計算量: O(n³) - 非効率

**二ポインタを使う理由**:
- **ソートの活用**: ソート済み配列で二ポインタが効率的
- **2Sumへの還元**: 1つの要素を固定して、残り2つを二ポインタで探す
- **時間計算量**: O(n²) - ソートO(n log n) + 二ポインタO(n²)

### 思考プロセス

1. **ソート**: 配列をソートして、二ポインタを使えるようにする
2. **1つ目の要素を固定**: `nums[i]`を1つ目の要素として固定
3. **2Sum問題に還元**: `nums[i] + nums[left] + nums[right] = 0`を満たす`left`, `right`を探す
4. **重複のスキップ**: 同じ値の要素をスキップして重複を避ける

### アルゴリズムのステップ

```
1. 配列をソート
2. i = 0 から n-3 まで:
   a. 重複をスキップ: nums[i] == nums[i-1]なら continue
   b. left = i+1, right = n-1 を設定
   c. left < right の間:
      - sum = nums[i] + nums[left] + nums[right]
      - sum == 0: 結果に追加し、重複をスキップ
      - sum < 0: left++
      - sum > 0: right--
3. 結果を返す
```

## 具体例でのトレース

### 例: `nums = [-1,0,1,2,-1,-4]`

ソート後: `[-4,-1,-1,0,1,2]`

| i | nums[i] | left | right | sum | アクション |
|---|---------|------|-------|-----|-----------|
| 0 | -4 | 1 | 5 | -4+(-1)+2=-3 | sum < 0 → left++ |
| 0 | -4 | 2 | 5 | -4+(-1)+2=-3 | sum < 0 → left++ |
| 0 | -4 | 3 | 5 | -4+0+2=-2 | sum < 0 → left++ |
| 0 | -4 | 4 | 5 | -4+1+2=-1 | sum < 0 → left++ |
| 1 | -1 | 2 | 5 | -1+(-1)+2=0 | **結果に追加** → left++, right-- |
| 1 | -1 | 3 | 4 | -1+0+1=0 | **結果に追加** → left++, right-- |

**結果**: `[[-1,-1,2],[-1,0,1]]`

## 現実世界での応用

### 1. データ分析（3変数の組み合わせ検索）
- **シナリオ**: 3つの変数の組み合わせで特定の条件を満たすデータを検索
- **実装**: 同様の二ポインタアプローチで効率的に検索
- **例**: 顧客データで、年齢、収入、支出の3つの変数の組み合わせで特定の条件を満たす顧客を検索
- **メリット**: 大量のデータから効率的に条件を満たす組み合わせを発見

### 2. 最適化問題（リソース配分）
- **シナリオ**: 3つのリソースの組み合わせで目標値を達成
- **実装**: 制約を満たす組み合わせを効率的に探索
- **例**: 予算配分で、3つのプロジェクトへの投資の組み合わせで目標利益を達成
- **メリット**: 限られたリソースを最適に配分

### 3. 金融取引（3資産のポートフォリオ）
- **シナリオ**: 3つの資産の組み合わせでリスクを最小化
- **実装**: 3つの資産の組み合わせで目標リスクを達成
- **例**: 投資ポートフォリオで、3つの資産の組み合わせで目標リターンを達成
- **メリット**: 投資戦略の最適化に使用

### 4. ゲーム開発（3要素の組み合わせ）
- **シナリオ**: ゲーム内で3つの要素の組み合わせで特定の効果を発揮
- **実装**: 3つの要素の組み合わせを効率的に探索
- **例**: RPGゲームで、3つのアイテムの組み合わせで特定の効果を発揮する組み合わせを検索
- **メリット**: ゲームバランスの調整に使用

### 5. 化学反応の分析
- **シナリオ**: 3つの化学物質の組み合わせで特定の反応を起こす
- **実装**: 3つの物質の組み合わせを効率的に探索
- **例**: 化学実験で、3つの試薬の組み合わせで目標の反応を起こす組み合わせを検索
- **メリット**: 実験の効率化に使用

## 注意点と落とし穴

### 1. 重複のスキップの重要性
- **問題**: 同じ値の要素が複数回出現する場合、重複する組み合わせが生成される
- **解決策**: 
  - 1つ目の要素: `if i > 0 and nums[i] == nums[i-1]: continue`
  - 2つ目と3つ目の要素: 結果に追加した後、同じ値の要素をスキップ
- **実装**: 
  ```
  while left < right and nums[left] == nums[left+1]:
      left += 1
  while left < right and nums[right] == nums[right-1]:
      right -= 1
  ```
- **注意**: 重複をスキップしないと、同じ組み合わせが複数回結果に含まれる

### 2. ソートの必要性とコスト
- **問題**: 二ポインタを使うためにソートが必要
- **コスト**: ソートにO(n log n)の時間がかかる
- **解決策**: ソートのコストを考慮しても、O(n³)からO(n²)に改善される
- **注意**: ソートができない場合（元の順序を保持する必要がある場合）は、別のアプローチが必要

### 3. 境界条件の正確な設定
- **問題**: `i < n-2`までしかループしない（3つの要素が必要）
- **解決策**: `for i in range(len(nums) - 2)`で正確に設定
- **注意**: `i < n-1`にしてしまうと、`left`と`right`が同じ要素を指す可能性がある

### 4. 負の数の扱い
- **問題**: 負の数が含まれる場合の処理
- **解決策**: ソート後は負の数も正しく処理される
- **例**: `nums = [-1,0,1]`の場合、`-1 + 0 + 1 = 0`が正しく見つかる
- **注意**: 負の数がある場合でも、ソート後の二ポインタは正しく動作する

### 5. 時間計算量の理解
- **ソート**: O(n log n)
- **二ポインタ**: O(n²) - 外側のループがO(n)、内側のループがO(n)
- **合計**: O(n²) - ソートのコストは二ポインタのコストに吸収される
- **空間**: O(1) - 結果を除けば定数空間

### 6. 4SumやkSumへの拡張
- **4Sum**: 2つの要素を固定して、残り2つを二ポインタで探す
- **kSum**: 再帰的にk-1Sumに還元
- **実装**: 一般化して`kSum(nums, target, k)`として実装可能
- **注意**: kが大きくなると、時間計算量がO(n^(k-1))になる

## 関連問題

- Two Sum
- 3Sum Closest
- 4Sum

---

**次のステップ**: [二ポインタのREADME](./README.md)に戻る

