# 3Sum - ロジック解説

## 問題概要

整数配列`nums`が与えられたとき、合計が0になる3つの要素の組み合わせを全て見つける。重複する組み合わせは除外する。

**制約**:
- `3 <= nums.length <= 3000`
- `-10^5 <= nums[i] <= 10^5`

**例**:
```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
```

## ロジックの核心

### なぜ二ポインタが有効か？

**全探索（O(n³)）**:
- 全ての3つの組み合わせを試す
- 時間計算量: O(n³) - 非効率

**二ポインタを使う理由**:
- **ソートの活用**: ソート済み配列で二ポインタが効率的
- **2Sumへの還元**: 1つの要素を固定して、残り2つを二ポインタで探す
- **時間計算量**: O(n²) - ソートO(n log n) + 二ポインタO(n²)

### 思考プロセス

1. **ソート**: 配列をソートして、二ポインタを使えるようにする
2. **1つ目の要素を固定**: `nums[i]`を1つ目の要素として固定
3. **2Sum問題に還元**: `nums[i] + nums[left] + nums[right] = 0`を満たす`left`, `right`を探す
4. **重複のスキップ**: 同じ値の要素をスキップして重複を避ける

### アルゴリズムのステップ

```
1. 配列をソート
2. i = 0 から n-3 まで:
   a. 重複をスキップ: nums[i] == nums[i-1]なら continue
   b. left = i+1, right = n-1 を設定
   c. left < right の間:
      - sum = nums[i] + nums[left] + nums[right]
      - sum == 0: 結果に追加し、重複をスキップ
      - sum < 0: left++
      - sum > 0: right--
3. 結果を返す
```

## 具体例でのトレース

### 例: `nums = [-1,0,1,2,-1,-4]`

ソート後: `[-4,-1,-1,0,1,2]`

| i | nums[i] | left | right | sum | アクション |
|---|---------|------|-------|-----|-----------|
| 0 | -4 | 1 | 5 | -4+(-1)+2=-3 | sum < 0 → left++ |
| 0 | -4 | 2 | 5 | -4+(-1)+2=-3 | sum < 0 → left++ |
| 0 | -4 | 3 | 5 | -4+0+2=-2 | sum < 0 → left++ |
| 0 | -4 | 4 | 5 | -4+1+2=-1 | sum < 0 → left++ |
| 1 | -1 | 2 | 5 | -1+(-1)+2=0 | **結果に追加** → left++, right-- |
| 1 | -1 | 3 | 4 | -1+0+1=0 | **結果に追加** → left++, right-- |

**結果**: `[[-1,-1,2],[-1,0,1]]`

## 現実世界での応用

### 1. データ分析
- **シナリオ**: 3つの変数の組み合わせで特定の条件を満たすデータを検索
- **実装**: 同様の二ポインタアプローチで効率的に検索

### 2. 最適化問題
- **シナリオ**: 3つのリソースの組み合わせで目標値を達成
- **実装**: 制約を満たす組み合わせを効率的に探索

## 注意点と落とし穴

1. **重複のスキップ**: 同じ値の要素をスキップして重複を避ける
2. **ソートの必要性**: 二ポインタを使うためにソートが必要
3. **境界条件**: `i < n-2`までしかループしない（3つの要素が必要）

## 関連問題

- Two Sum
- 3Sum Closest
- 4Sum

---

**次のステップ**: [二ポインタのREADME](./README.md)に戻る

