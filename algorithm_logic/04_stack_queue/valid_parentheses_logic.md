# Valid Parentheses - ロジック解説

## 問題概要

文字列`s`が与えられたとき、括弧（`()`, `[]`, `{}`）が正しく対応しているか判定する。

**有効な条件**:
1. 開き括弧は同じ種類の閉じ括弧で閉じられる
2. 開き括弧は正しい順序で閉じられる
3. 全ての閉じ括弧に対応する開き括弧が存在する

**制約**:
- `1 <= s.length <= 10^4`
- `s`は括弧文字のみ（`'()[]{}'`）

**例**:
```
Input: s = "()[]{}"
Output: true

Input: s = "([)]"
Output: false
```

## ロジックの核心

### なぜスタックが有効か？

**素朴なアプローチ（失敗）**:
- 括弧の数をカウント: `(`と`)`の数が同じでも、順序が正しくない場合がある
- 例: `"([)]"`は括弧の数は合っているが、順序が間違っている

**スタックを使う理由**:
- **LIFOの特性**: 最後に開いた括弧が最初に閉じられる必要がある
- **ネストされた構造**: 括弧はネストされた構造を持ち、スタックが自然に適合
- **対応の確認**: 閉じ括弧が来たとき、スタックのトップと対応を確認

### 思考プロセス

1. **括弧の特性**: 括弧は**ネストされた構造**を持つ
   - `"()"` - 単純な対応
   - `"([])"` - ネストされた対応
   - `"([)]"` - 間違った順序（無効）

2. **スタックの適用**:
   - 開き括弧を見つけたらスタックにプッシュ
   - 閉じ括弧を見つけたら、スタックのトップと対応を確認
   - 対応していればポップ、対応していなければ無効

3. **最終確認**: 全ての括弧を処理した後、スタックが空なら有効

### アルゴリズムのステップ

```
1. 空のスタックを作成: stack = []
2. 閉じ括弧から開き括弧へのマッピングを作成: mapping = {')': '(', '}': '{', ']': '['}
3. 文字列を1文字ずつ処理:
   a. 閉じ括弧の場合:
      - スタックが空、またはトップが対応する開き括弧でない → false
      - 対応していれば、スタックからポップ
   b. 開き括弧の場合:
      - スタックにプッシュ
4. 全ての文字を処理した後、スタックが空なら true、そうでなければ false
```

### 疑似コード

```
function isValid(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    
    for char in s:
        if char in mapping:  // 閉じ括弧
            if stack is empty or stack.pop() != mapping[char]:
                return false
        else:  // 開き括弧
            stack.push(char)
    
    return stack is empty
```

## 具体例でのトレース

### 例1: `s = "()[]{}"`

| ステップ | 文字 | スタック | アクション |
|---------|------|----------|-----------|
| 初期 | - | [] | - |
| 1 | '(' | ['('] | 開き括弧 → プッシュ |
| 2 | ')' | [] | 閉じ括弧 → トップ('(')と対応 → ポップ |
| 3 | '[' | ['['] | 開き括弧 → プッシュ |
| 4 | ']' | [] | 閉じ括弧 → トップ('[')と対応 → ポップ |
| 5 | '{' | ['{'] | 開き括弧 → プッシュ |
| 6 | '}' | [] | 閉じ括弧 → トップ('{')と対応 → ポップ |
| 終了 | - | [] | スタックが空 → **true** |

**結果**: `true` ✓

### 例2: `s = "([)]"`

| ステップ | 文字 | スタック | アクション |
|---------|------|----------|-----------|
| 初期 | - | [] | - |
| 1 | '(' | ['('] | 開き括弧 → プッシュ |
| 2 | '[' | ['(', '['] | 開き括弧 → プッシュ |
| 3 | ')' | ['('] | 閉じ括弧 → トップ('[')と対応しない → **false** |

**結果**: `false` - `')'`は`'('`に対応すべきだが、`'['`が間に挟まっている

### 例3: `s = "{[]}"`

| ステップ | 文字 | スタック | アクション |
|---------|------|----------|-----------|
| 初期 | - | [] | - |
| 1 | '{' | ['{'] | 開き括弧 → プッシュ |
| 2 | '[' | ['{', '['] | 開き括弧 → プッシュ |
| 3 | ']' | ['{'] | 閉じ括弧 → トップ('[')と対応 → ポップ |
| 4 | '}' | [] | 閉じ括弧 → トップ('{')と対応 → ポップ |
| 終了 | - | [] | スタックが空 → **true** |

**結果**: `true` ✓

### 可視化

```
有効な例: "([{}])"
処理の流れ:
( → スタック: ['(']
[ → スタック: ['(', '[']
{ → スタック: ['(', '[', '{']
} → スタック: ['(', '[']  (対応する'{'をポップ)
] → スタック: ['(']  (対応する'['をポップ)
) → スタック: []  (対応する'('をポップ)
→ スタックが空なので有効

無効な例: "([)]"
処理の流れ:
( → スタック: ['(']
[ → スタック: ['(', '[']
) → エラー！トップは'['だが、')'は'('に対応すべき
→ 無効
```

## 現実世界での応用

### 1. コンパイラの構文解析
- **シナリオ**: プログラミング言語のコードで、括弧の対応をチェック
- **実装**: パーサーが括弧の対応をスタックで確認
- **例**: Pythonインタープリターがコードを解析する際、括弧の対応を確認

### 2. テキストエディタの括弧ハイライト
- **シナリオ**: エディタで、対応する括弧をハイライト表示
- **実装**: カーソル位置の括弧から、スタックで対応する括弧を探す
- **例**: VS CodeやIntelliJ IDEAで、括弧にカーソルを置くと対応する括弧がハイライトされる

### 3. JSON/XMLパーサー
- **シナリオ**: JSONやXMLファイルの構文チェック
- **実装**: 開きタグと閉じタグの対応をスタックで確認
- **例**: JSONパーサーが`{`と`}`の対応を確認

### 4. 数式エディタ
- **シナリオ**: 数式エディタで、括弧の対応を視覚的に表示
- **実装**: 括弧の対応をスタックで追跡し、色分けして表示
- **例**: LaTeXエディタで、対応する括弧を色分け

### 5. コードレビューツール
- **シナリオ**: コードレビューで、括弧の対応ミスを検出
- **実装**: 静的解析ツールが括弧の対応をチェック
- **例**: ESLintやPylintが、括弧の対応ミスを警告

## 注意点と落とし穴

### 1. スタックが空の場合のチェック
- **問題**: 閉じ括弧が来たとき、スタックが空だとエラー
- **解決策**: 閉じ括弧を処理する前に、スタックが空でないか確認
- **実装**: `if not stack or stack.pop() != mapping[char]:`

### 2. ポップのタイミング
- **問題**: `stack.pop()`を呼ぶと、要素が削除される
- **解決策**: 対応を確認してからポップする（`pop()`の戻り値を使用）
- **注意**: `peek()`と`pop()`を分ける必要はない（Pythonでは`pop()`で確認可能）

### 3. マッピングの方向
- **問題**: 閉じ括弧から開き括弧へのマッピングが必要
- **解決策**: `mapping = {')': '(', '}': '{', ']': '['}`
- **理由**: 閉じ括弧が来たとき、対応する開き括弧を探すため

### 4. 最終確認の重要性
- **問題**: 全ての文字を処理した後、スタックが空でない場合がある
- **解決策**: 最後に`return len(stack) == 0`で確認
- **例**: `s = "("`の場合、スタックに`'('`が残り、無効

### 5. 文字の種類の判定
- **問題**: 開き括弧と閉じ括弧を正確に判定する必要がある
- **解決策**: `char in mapping`で閉じ括弧かどうかを判定
- **注意**: 開き括弧は`mapping`に含まれない

### 6. 時間計算量の理解
- **平均**: O(n) - 各文字を1回ずつ処理
- **最悪**: O(n) - 常に線形時間
- **空間**: O(n) - 最悪の場合、全ての文字が開き括弧でスタックに保存される

### 7. 最適化の余地
- **早期終了**: 閉じ括弧が来たとき、対応しない場合は即座に`false`を返す
- **メモリ効率**: 文字列が長い場合、スタックのサイズが問題になる可能性があるが、通常は問題ない

## 関連問題

同じテクニック（スタック）を使う問題：

1. **Generate Parentheses** - 有効な括弧の組み合わせを生成
2. **Longest Valid Parentheses** - 最長の有効な括弧部分文字列を探す
3. **Remove Invalid Parentheses** - 無効な括弧を削除して有効にする
4. **Decode String** - ネストされた文字列をデコード
5. **Basic Calculator** - 括弧を含む数式を評価

## まとめ

Valid Parenthesesは、スタックの最も基本的な応用例です。重要なポイントは：

1. **LIFOの特性**: 最後に開いた括弧が最初に閉じられる必要がある
2. **ネストされた構造**: 括弧のネストされた構造がスタックに自然に適合
3. **対応の確認**: 閉じ括弧が来たとき、スタックのトップと対応を確認
4. **最終確認**: 全ての括弧を処理した後、スタックが空か確認

この問題を理解することで、スタックを使った他の問題にも応用できるようになります。

---

**次のステップ**: 
- [Daily Temperatures](./daily_temperatures_logic.md)で、モノトニックスタックを学ぶ
- [スタック・キューのREADME](./README.md)に戻って他の問題も確認

