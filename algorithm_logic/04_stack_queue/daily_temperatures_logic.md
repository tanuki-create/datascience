# Daily Temperatures - ロジック解説

## 問題概要

配列`temperatures`が与えられたとき、各日の気温について、それより高い気温が初めて出現するまでの日数を返す。そのような日が存在しない場合は0を返す。

**制約**:
- `1 <= temperatures.length <= 10^5`
- `30 <= temperatures[i] <= 100`

**例**:
```
Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]
説明: 
- 73度の次の日(74度)が高い → 1日後
- 74度の次の日(75度)が高い → 1日後
- 75度は4日後に72度が高い → 4日後
```

## ロジックの核心

### なぜモノトニックスタックが有効か？

**素朴なアプローチ（O(n²)）**:
- 各日について、それ以降の日を全てチェック
- 時間計算量: O(n²) - 2重ループが必要

**モノトニックスタックを使う理由**:
- **単調性の利用**: スタック内の気温を降順に保つことで、効率的に処理
- **1回の走査**: 各要素を1回ずつ処理するだけで済む
- **時間計算量**: O(n) - 1回の走査で完了

### 思考プロセス

1. **問題の本質**: 各日について、「それより高い気温が初めて出現する日」を探す
2. **スタックの活用**: まだ答えが見つかっていない日のインデックスをスタックに保存
3. **モノトニック性**: スタック内の気温を降順に保つ（下から上へ: 高い → 低い）
4. **処理の流れ**: 現在の気温がスタックのトップより高い場合、答えが見つかった

### アルゴリズムのステップ

```
1. 結果配列 result = [0] * n を初期化
2. 空のスタックを作成: stack = []  (インデックスを保存)
3. 各日 i を0から n-1 まで走査:
   a. スタックが空でない、かつ現在の気温がスタックのトップの日の気温より高い場合:
      - スタックからポップ: j = stack.pop()
      - result[j] = i - j  (答えを記録)
      - これを繰り返す（現在の気温より低い全ての日を処理）
   b. 現在のインデックス i をスタックにプッシュ
4. result を返す
```

### 疑似コード

```
function dailyTemperatures(temperatures):
    n = len(temperatures)
    result = [0] * n
    stack = []  // インデックスを保存
    
    for i from 0 to n - 1:
        // スタック内の、現在の気温より低い日の答えを見つける
        while stack is not empty and temperatures[i] > temperatures[stack[-1]]:
            j = stack.pop()
            result[j] = i - j
        
        // 現在のインデックスをスタックに追加
        stack.append(i)
    
    return result
```

## 具体例でのトレース

### 例: `temperatures = [73,74,75,71,69,72,76,73]`

| ステップ | i | temperatures[i] | stack | result | アクション |
|---------|---|----------------|-------|--------|-----------|
| 初期 | - | - | [] | [0,0,0,0,0,0,0,0] | - |
| 1 | 0 | 73 | [0] | [0,0,0,0,0,0,0,0] | スタックに追加 |
| 2 | 1 | 74 | [] → [1] | [1,0,0,0,0,0,0,0] | 73 < 74 → result[0]=1, 1を追加 |
| 3 | 2 | 75 | [] → [2] | [1,1,0,0,0,0,0,0] | 74 < 75 → result[1]=1, 2を追加 |
| 4 | 3 | 71 | [2,3] | [1,1,0,0,0,0,0,0] | 75 > 71 → 3を追加 |
| 5 | 4 | 69 | [2,3,4] | [1,1,0,0,0,0,0,0] | 71 > 69 → 4を追加 |
| 6 | 5 | 72 | [2,3] → [2,5] | [1,1,0,2,1,0,0,0] | 69 < 72 → result[4]=1, 71 < 72 → result[3]=2, 5を追加 |
| 7 | 6 | 76 | [] → [6] | [1,1,4,2,1,1,0,0] | 72 < 76 → result[5]=1, 75 < 76 → result[2]=4, 6を追加 |
| 8 | 7 | 73 | [6,7] | [1,1,4,2,1,1,0,0] | 76 > 73 → 7を追加 |

**結果**: `[1,1,4,2,1,1,0,0]` ✓

### 可視化

```
気温: [73, 74, 75, 71, 69, 72, 76, 73]
インデックス: 0   1   2   3   4   5   6   7

処理の流れ:
i=0: 73 → スタック: [0]
i=1: 74 → 73 < 74 → result[0]=1, スタック: [1]
i=2: 75 → 74 < 75 → result[1]=1, スタック: [2]
i=3: 71 → 75 > 71 → スタック: [2,3]
i=4: 69 → 71 > 69 → スタック: [2,3,4]
i=5: 72 → 69 < 72 → result[4]=1, 71 < 72 → result[3]=2, スタック: [2,5]
i=6: 76 → 72 < 76 → result[5]=1, 75 < 76 → result[2]=4, スタック: [6]
i=7: 73 → 76 > 73 → スタック: [6,7]

最終結果: [1,1,4,2,1,1,0,0]
```

## 現実世界での応用

### 1. 株式市場の分析
- **シナリオ**: 各日の株価について、それより高い株価が初めて出現する日を予測
- **実装**: モノトニックスタックで、株価の上昇タイミングを効率的に計算
- **例**: 投資アプリで、株価が上昇するまでの日数を表示

### 2. 在庫管理システム
- **シナリオ**: 各日の在庫レベルについて、それより高い在庫レベルが出現する日を予測
- **実装**: モノトニックスタックで、在庫の増加タイミングを計算
- **例**: 在庫管理システムで、在庫が増加するまでの日数を予測

### 3. ウェブサイトのトラフィック分析
- **シナリオ**: 各日のトラフィックについて、それより高いトラフィックが出現する日を分析
- **実装**: モノトニックスタックで、トラフィックの増加タイミングを計算
- **例**: アナリティクスツールで、トラフィックが増加するまでの日数を表示

### 4. センサーデータの分析
- **シナリオ**: IoTセンサーのデータで、値が上昇するタイミングを検出
- **実装**: モノトニックスタックで、センサー値の変化を効率的に追跡
- **例**: 温度センサーで、温度が上昇するまでの時間を計算

### 5. パフォーマンス監視
- **シナリオ**: アプリケーションのパフォーマンスメトリクスで、値が改善するタイミングを検出
- **実装**: モノトニックスタックで、パフォーマンスの改善タイミングを計算
- **例**: レスポンスタイムが改善するまでの日数を追跡

## 注意点と落とし穴

### 1. モノトニックスタックの理解
- **問題**: なぜスタック内の要素を降順に保つのか？
- **解決策**: 現在の要素より小さい要素は、現在の要素が答えになる
- **理由**: 降順に保つことで、現在の要素が複数の過去の要素の答えになる

### 2. インデックスの保存
- **問題**: スタックには気温ではなくインデックスを保存する
- **解決策**: インデックスを保存することで、結果配列のどの位置を更新するかが分かる
- **実装**: `stack.append(i)`でインデックスを保存

### 3. 結果の計算
- **問題**: 答えは「日数」なので、インデックスの差を計算する
- **解決策**: `result[j] = i - j`で日数を計算
- **注意**: インデックス0から始まるので、差がそのまま日数になる

### 4. ループの継続条件
- **問題**: `while`ループで、現在の気温より低い全ての要素を処理する必要がある
- **解決策**: `while stack and temperatures[i] > temperatures[stack[-1]]:`で継続
- **注意**: スタックが空になるまで、または現在の気温より高い要素に当たるまで続ける

### 5. 時間計算量の理解
- **平均**: O(n) - 各要素は最大1回プッシュされ、最大1回ポップされる
- **最悪**: O(n) - 全ての要素が1回ずつ処理される
- **空間**: O(n) - 最悪の場合、全てのインデックスがスタックに保存される

### 6. モノトニックスタックのパターン
- **降順スタック**: この問題のように、「次に大きい要素」を探す場合
- **昇順スタック**: 「次に小さい要素」を探す場合に使用
- **応用**: Next Greater Element、Largest Rectangle in Histogramなど

## 関連問題

同じテクニック（モノトニックスタック）を使う問題：

1. **Next Greater Element** - 各要素について、次に大きい要素を探す
2. **Largest Rectangle in Histogram** - ヒストグラム内の最大の矩形を探す
3. **Trapping Rain Water** - 雨水をトラップする量を計算
4. **Remove K Digits** - k桁を削除して最小の数を得る
5. **Maximal Rectangle** - 2次元配列内の最大の矩形を探す

## まとめ

Daily Temperaturesは、モノトニックスタックの典型例です。重要なポイントは：

1. **モノトニック性**: スタック内の要素を降順に保つことで、効率的に処理
2. **インデックスの保存**: 気温ではなくインデックスを保存して、結果を更新
3. **O(n)時間**: 各要素は最大1回プッシュされ、最大1回ポップされる
4. **パターンの理解**: 「次に大きい要素」を探す問題に適用可能

この問題を理解することで、モノトニックスタックを使った他の問題にも応用できるようになります。

---

**次のステップ**: 
- [スタック・キューのREADME](./README.md)に戻って他の問題も確認
- [二分探索テクニック](../05_binary_search/README.md) - 次のPhase 2のテクニック

