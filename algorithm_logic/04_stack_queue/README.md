# スタック・キュー (Stack & Queue)

## 概要

スタックとキューは、データの**挿入順序**と**削除順序**が異なる2つの基本的なデータ構造です。それぞれ異なる特性を持ち、特定の問題に最適化されています。

### スタック（Stack）
- **LIFO（Last In First Out）**: 最後に入れた要素が最初に出る
- **操作**: `push`（追加）、`pop`（削除）、`peek`（先頭参照）
- **例**: 本の積み重ね、関数呼び出しのコールスタック

### キュー（Queue）
- **FIFO（First In First Out）**: 最初に入れた要素が最初に出る
- **操作**: `enqueue`（追加）、`dequeue`（削除）、`peek`（先頭参照）
- **例**: レジの待ち行列、タスクスケジューリング

## 基本概念

### スタックの特性

1. **後入れ先出し**: 最後に追加した要素が最初に取り出される
2. **一方向アクセス**: 先頭（トップ）からのみアクセス可能
3. **再帰的な構造**: 再帰的な問題を反復的に解くのに適している

### キューの特性

1. **先入れ先出し**: 最初に追加した要素が最初に取り出される
2. **双方向アクセス**: 先頭（front）と末尾（rear）からアクセス可能
3. **順序保持**: 要素の順序を保持しながら処理するのに適している

### 主な操作と計算量

| データ構造 | 操作 | 時間計算量 | 空間計算量 |
|-----------|------|-----------|-----------|
| スタック | push/pop | O(1) | O(n) |
| スタック | peek | O(1) | O(1) |
| キュー | enqueue/dequeue | O(1) | O(n) |
| キュー | peek | O(1) | O(1) |

## いつ使うべきか

### スタックを使う場面

1. **括弧のマッチング**: 開き括弧と閉じ括弧の対応を確認
2. **式の評価**: 逆ポーランド記法、中置記法の変換
3. **履歴管理**: 元に戻す（Undo）機能、ブラウザの戻る機能
4. **再帰の代替**: 深さ優先探索（DFS）を反復的に実装
5. **モノトニックスタック**: 次に大きい/小さい要素を探す

### キューを使う場面

1. **幅優先探索（BFS）**: グラフや木のレベル順探索
2. **タスクスケジューリング**: プロセスキュー、ジョブキュー
3. **キャッシュ管理**: LRUキャッシュの実装
4. **ストリーミング処理**: データストリームの順次処理
5. **スライディングウィンドウ**: 固定サイズのウィンドウを管理

## 現実世界での応用例

### スタックの応用

1. **コンパイラの構文解析**
   - **例**: プログラミング言語の構文チェック
   - **実装**: 括弧の対応をスタックで確認
   - **メリット**: ネストされた構造を効率的に処理

2. **ブラウザの戻る/進む機能**
   - **例**: ウェブブラウザの履歴管理
   - **実装**: 訪問したURLをスタックに保存
   - **メリット**: ユーザーの操作履歴を効率的に管理

3. **テキストエディタのUndo/Redo**
   - **例**: 編集操作の履歴管理
   - **実装**: 操作をスタックに保存し、Undoで取り出す
   - **メリット**: 操作の順序を逆順に実行可能

4. **関数呼び出しの管理**
   - **例**: プログラムの実行時のコールスタック
   - **実装**: 関数呼び出しをスタックで管理
   - **メリット**: 再帰的な関数呼び出しを効率的に処理

5. **式の評価（電卓アプリ）**
   - **例**: 数式の計算
   - **実装**: 逆ポーランド記法でスタックを使用
   - **メリット**: 括弧のない数式を効率的に評価

### キューの応用

1. **オペレーティングシステムのプロセススケジューリング**
   - **例**: CPUのタスクキュー
   - **実装**: 実行待ちのプロセスをキューで管理
   - **メリット**: 公平な順序でプロセスを実行

2. **メッセージキューシステム**
   - **例**: メッセージブローカー（RabbitMQ、Kafka）
   - **実装**: メッセージをキューに保存し、順次処理
   - **メリット**: 非同期処理と負荷分散を実現

3. **プリンタの印刷キュー**
   - **例**: 複数の印刷ジョブの管理
   - **実装**: 印刷ジョブをキューに保存
   - **メリット**: 先着順で印刷を実行

4. **幅優先探索（BFS）**
   - **例**: グラフの最短経路探索
   - **実装**: 探索するノードをキューで管理
   - **メリット**: レベル順に探索することで最短経路を保証

5. **リアルタイムデータ処理**
   - **例**: ストリーミングデータの処理
   - **実装**: データをキューに保存し、順次処理
   - **メリット**: データの順序を保持しながら処理

## 実装時の注意点

### スタックの注意点

1. **オーバーフロー/アンダーフロー**
   - **問題**: スタックが満杯の場合の`push`、空の場合の`pop`
   - **解決策**: 事前にサイズをチェック
   - **注意**: 動的配列を使えば自動的に拡張される

2. **メモリ管理**
   - **問題**: 大量の要素をスタックに保存するとメモリを消費
   - **解決策**: 必要に応じて要素を削除
   - **注意**: 再帰の深さが大きい場合、スタックオーバーフローに注意

3. **順序の理解**
   - **問題**: LIFOの特性を理解していないと予期しない動作
   - **解決策**: スタックの動作を視覚的に理解する
   - **例**: 本の積み重ねをイメージする

### キューの注意点

1. **循環キュー**
   - **問題**: 固定サイズのキューで、末尾に達した場合の処理
   - **解決策**: 循環キューを実装してメモリを効率的に使用
   - **メリット**: 先頭の要素が削除された後、そのスペースを再利用

2. **優先度付きキュー**
   - **問題**: 単純なFIFOではなく、優先度に基づいて処理したい場合
   - **解決策**: ヒープを使った優先度付きキューを使用
   - **例**: タスクスケジューリングで優先度の高いタスクを先に処理

3. **デキュー（両端キュー）**
   - **問題**: 先頭と末尾の両方から要素を追加・削除したい場合
   - **解決策**: `collections.deque`を使用
   - **メリット**: スタックとキューの両方の機能を提供

## 関連するLeetCode/AtCoder問題

### Easy
- [Valid Parentheses](./valid_parentheses_logic.md) - スタックの基本
- [Implement Queue using Stacks](../leetcode/easy/) - データ構造の変換
- [Implement Stack using Queues](../leetcode/easy/) - データ構造の変換

### Medium
- [Daily Temperatures](./daily_temperatures_logic.md) - モノトニックスタック
- [Next Greater Element](../leetcode/medium/) - モノトニックスタック
- [Decode String](../leetcode/medium/) - ネストされた構造の処理

### Hard
- [Trapping Rain Water](../leetcode/hard/) - スタックを使った高度な問題
- [Largest Rectangle in Histogram](../leetcode/hard/) - モノトニックスタック
- [Sliding Window Maximum](../leetcode/hard/) - デキューを使った問題

## 学習の進め方

1. **Valid Parentheses**から始める: スタックの最も基本的な使い方
2. **Daily Temperatures**でモノトニックスタックを学ぶ: より高度なスタックの応用
3. **BFS問題**でキューを学ぶ: グラフ探索でのキューの使用

## 次のステップ

- [Valid Parentheses のロジック解説](./valid_parentheses_logic.md)
- [Daily Temperatures のロジック解説](./daily_temperatures_logic.md)
- [二分探索テクニック](../05_binary_search/README.md) - 次のPhase 2のテクニック

---

**重要**: スタックとキューは、多くのアルゴリズムの基礎となるデータ構造です。特に、再帰的な問題を反復的に解く際や、順序を保持しながら処理する際に強力です。

