# テクニック組み合わせガイド

## 概要

このガイドでは、複数のアルゴリズムやデータ構造を**組み合わせて使用する方法**を解説します。多くの実用的な問題では、単一のテクニックでは不十分で、複数のテクニックを組み合わせる必要があります。

## 主要な組み合わせパターン

### 1. ハッシュテーブル + スライディングウィンドウ

#### 適用場面
- 文字列の部分文字列で、文字の出現回数を追跡
- 条件を満たす部分配列の検索

#### 例
- **Minimum Window Substring**: スライディングウィンドウで範囲を管理し、ハッシュテーブルで文字の出現回数を追跡
- **Longest Substring with At Most K Distinct Characters**: スライディングウィンドウ + ハッシュテーブルで文字の種類を管理

#### 実装のポイント
- ハッシュテーブルで文字の出現回数を管理
- スライディングウィンドウで範囲を動的に調整
- 条件を満たす範囲を効率的に検索

### 2. ハッシュテーブル + 累積和

#### 適用場面
- 部分配列の合計が特定の値に等しい場合の検索
- 範囲クエリとハッシュテーブルの組み合わせ

#### 例
- **Subarray Sum Equals K**: 累積和を計算し、ハッシュテーブルで補数を検索
- **Contiguous Array**: 累積和を0/1で管理し、ハッシュテーブルで長さを追跡

#### 実装のポイント
- 累積和を事前に計算
- ハッシュテーブルで補数を検索
- O(n)時間で部分配列を検索

### 3. バックトラッキング + Trie

#### 適用場面
- 文字列の検索とバックトラッキングの組み合わせ
- 複数のパターンを効率的に検索

#### 例
- **Word Search II**: Trieで単語を管理し、バックトラッキングでグリッドを探索
- **Concatenated Words**: Trieで単語を管理し、バックトラッキングで連結を検索

#### 実装のポイント
- Trieで単語を効率的に管理
- バックトラッキングでグリッドを探索
- 早期終了で効率化

### 4. Union-Find + グラフ探索

#### 適用場面
- グラフの連結成分を管理しながら探索
- サイクルの検出と連結成分の管理

#### 例
- **Number of Islands**: DFS/BFSで探索し、Union-Findで連結成分を管理（代替実装）
- **Redundant Connection**: Union-Findでサイクルを検出

#### 実装のポイント
- Union-Findで連結成分を効率的に管理
- DFS/BFSでグラフを探索
- サイクルを効率的に検出

### 5. ヒープ + ハッシュテーブル

#### 適用場面
- 頻度に基づいたトップK問題
- 優先度と頻度の両方を管理

#### 例
- **Top K Frequent Elements**: ハッシュテーブルで頻度を管理し、ヒープでトップKを保持
- **Top K Frequent Words**: ハッシュテーブル + ヒープ + カスタム比較

#### 実装のポイント
- ハッシュテーブルで頻度を管理
- ヒープでトップKを保持
- カスタム比較関数で順序を制御

### 6. セグメント木 + 座標圧縮

#### 適用場面
- 大きな値の範囲でセグメント木を使用
- 値の範囲が大きいが、実際の値が少ない場合

#### 例
- **Count of Smaller Numbers After Self**: 座標圧縮 + セグメント木で範囲クエリ
- **Reverse Pairs**: 座標圧縮 + セグメント木で範囲クエリ

#### 実装のポイント
- 座標圧縮で値を小さな整数にマッピング
- セグメント木で範囲クエリを処理
- メモリ使用量を削減

### 7. 動的計画法 + バックトラッキング

#### 適用場面
- 最適解の構築とパスの復元
- メモ化とバックトラッキングの組み合わせ

#### 例
- **Word Break II**: DPで可能性を判定し、バックトラッキングで解を構築
- **Palindrome Partitioning**: DPで判定し、バックトラッキングで分割

#### 実装のポイント
- DPで可能性を判定
- バックトラッキングで解を構築
- メモ化で効率化

### 8. 二分探索 + 貪欲法

#### 適用場面
- 最適値の探索と貪欲な選択の組み合わせ
- 答えを二分探索し、貪欲法で判定

#### 例
- **Split Array Largest Sum**: 二分探索で答えを探索し、貪欲法で判定
- **Koko Eating Bananas**: 二分探索で速度を探索し、貪欲法で判定

#### 実装のポイント
- 二分探索で答えの範囲を絞る
- 貪欲法で可能性を判定
- O(log n)時間で最適値を探索

### 9. モノトニックスタック + 動的計画法

#### 適用場面
- スタックで範囲を管理し、DPで最適値を計算
- ヒストグラムや配列の最適化

#### 例
- **Largest Rectangle in Histogram**: モノトニックスタックで範囲を管理
- **Trapping Rain Water**: モノトニックスタックで高さを管理

#### 実装のポイント
- モノトニックスタックで単調性を保持
- DPで最適値を計算
- O(n)時間で処理

### 10. Trie + 動的計画法

#### 適用場面
- 文字列の検索とDPの組み合わせ
- 複雑な文字列マッチング

#### 例
- **Word Break**: Trieで単語を管理し、DPで可能性を判定
- **Concatenated Words**: Trie + DPで連結を判定

#### 実装のポイント
- Trieで単語を効率的に管理
- DPで可能性を判定
- メモ化で効率化

## 組み合わせの判断基準

### 1. 操作の種類
- **複数の操作**: 異なるデータ構造を組み合わせ
- **時間計算量**: 各操作の時間計算量を考慮

### 2. データの特性
- **値の範囲**: 座標圧縮が必要か判断
- **データの構造**: グラフ、木、配列など

### 3. 問題の要件
- **時間制限**: アルゴリズムの選択に影響
- **空間制限**: データ構造の選択に影響

## 実践的なアプローチ

### ステップ1: 問題の分析
1. 必要な操作を特定
2. 各操作の時間計算量を考慮
3. データ構造の組み合わせを検討

### ステップ2: データ構造の選択
1. 主要な操作に適したデータ構造を選択
2. 補助的なデータ構造を検討
3. 時間・空間のトレードオフを考慮

### ステップ3: 実装
1. 各データ構造を個別に実装
2. データ構造間の連携を実装
3. エッジケースを処理

## よくある間違い

### 1. 過剰な組み合わせ
- **問題**: 必要以上に複雑な組み合わせ
- **解決策**: シンプルなアプローチから始める
- **注意**: 必要最小限の組み合わせを使用

### 2. データ構造の不整合
- **問題**: データ構造間の同期が取れていない
- **解決策**: データ構造間の連携を慎重に実装
- **注意**: 更新操作で全てのデータ構造を更新

### 3. 時間計算量の誤算
- **問題**: 組み合わせによる時間計算量の増加を見落とす
- **解決策**: 各操作の時間計算量を正確に計算
- **注意**: 組み合わせによるオーバーヘッドを考慮

## 関連リソース

- [Problem Pattern Guide](./problem_pattern_guide.md) - 問題パターンの識別
- [Optimization Techniques](./optimization_techniques.md) - 最適化テクニック
- [各テクニックのREADME](../README.md) - 詳細な解説

---

**重要**: テクニックの組み合わせは、複雑な問題を解決する鍵です。各テクニックの特性を理解し、適切に組み合わせることが重要です。

