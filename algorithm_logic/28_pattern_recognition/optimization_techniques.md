# 最適化テクニック

## 概要

このガイドでは、アルゴリズムの**最適化テクニック**を解説します。時間計算量や空間計算量を改善し、より効率的な解法を実現する方法を学びます。

## 主要な最適化テクニック

### 1. メモ化（Memoization）

#### 概要
- 計算済みの結果を保存して再利用
- 重複する計算を避ける

#### 適用場面
- 再帰的な問題で、同じ状態が複数回計算される
- 動的計画法の実装

#### 実装例
```python
from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

#### 効果
- **時間計算量**: O(2^n) → O(n)
- **空間計算量**: O(n) - メモ化テーブル

### 2. 早期終了（Early Termination）

#### 概要
- 解が見つかったら即座に終了
- 無効な状態を早期に検出

#### 適用場面
- バックトラッキング
- 探索問題

#### 実装例
```python
def backtrack(state):
    if is_invalid(state):
        return  # 早期終了
    if is_solution(state):
        return state  # 解が見つかった
    # 続けて探索
```

#### 効果
- **実際の実行時間**: 大幅に短縮
- **探索空間**: 削減

### 3. 空間最適化

#### 概要
- 空間計算量を削減
- 不要なデータを削除

#### 適用場面
- 動的計画法で、古い状態が不要な場合
- ストリーミングデータの処理

#### 実装例
```python
# 2次元DPを1次元に圧縮
# 古い行のデータが不要な場合
dp_old = [0] * n
dp_new = [0] * n
# 古い行を削除
```

#### 効果
- **空間計算量**: O(n²) → O(n)
- **メモリ使用量**: 削減

### 4. ビット操作の活用

#### 概要
- ビット操作で効率化
- 集合の操作をビットマスクで実現

#### 適用場面
- 部分集合の生成
- 状態の管理

#### 実装例
```python
# 部分集合の生成
for mask in range(1 << n):
    subset = [i for i in range(n) if mask & (1 << i)]
```

#### 効果
- **時間計算量**: 改善
- **空間計算量**: 削減

### 5. 二項係数の事前計算

#### 概要
- 階乗と逆元を事前に計算
- 組み合わせ計算をO(1)に

#### 適用場面
- 組み合わせ計算が頻繁に行われる場合
- モジュラー演算が必要な場合

#### 実装例
```python
# 階乗と逆元の事前計算
fact = [1] * (n + 1)
inv_fact = [1] * (n + 1)
for i in range(1, n + 1):
    fact[i] = fact[i-1] * i % mod
inv_fact[n] = pow(fact[n], mod-2, mod)
for i in range(n, 0, -1):
    inv_fact[i-1] = inv_fact[i] * i % mod
```

#### 効果
- **組み合わせ計算**: O(n) → O(1)
- **複数の組み合わせ計算**: 大幅に改善

### 6. 遅延評価（Lazy Evaluation）

#### 概要
- 計算を必要になるまで遅延
- 不要な計算を避ける

#### 適用場面
- セグメント木での範囲更新
- ストリーミングデータの処理

#### 実装例
```python
class LazySegmentTree:
    def __init__(self, arr):
        self.lazy = [0] * (4 * len(arr))
        # 更新を遅延
    
    def update_range(self, l, r, val):
        # 更新を遅延テーブルに保存
        self.lazy_update(l, r, val)
```

#### 効果
- **範囲更新**: O(n) → O(log n)
- **実際の実行時間**: 改善

### 7. 座標圧縮

#### 概要
- 大きな値を小さな整数にマッピング
- データ構造のサイズを削減

#### 適用場面
- 値の範囲が大きいが、実際の値が少ない場合
- セグメント木やFenwick Treeと組み合わせ

#### 実装例
```python
def coordinate_compression(values):
    unique = sorted(set(values))
    mapping = {val: idx for idx, val in enumerate(unique)}
    return [mapping[v] for v in values]
```

#### 効果
- **メモリ使用量**: 大幅に削減
- **データ構造のサイズ**: 削減

### 8. 反復的実装への変換

#### 概要
- 再帰的実装を反復的実装に変換
- スタックオーバーフローのリスクを回避

#### 適用場面
- 深い再帰が発生する可能性がある場合
- スタックの使用量を削減したい場合

#### 実装例
```python
# 再帰的
def dfs(node):
    if not node:
        return
    dfs(node.left)
    dfs(node.right)

# 反復的
def dfs_iterative(root):
    stack = [root]
    while stack:
        node = stack.pop()
        if node:
            stack.append(node.right)
            stack.append(node.left)
```

#### 効果
- **スタック使用量**: 削減
- **スタックオーバーフローのリスク**: 回避

## 最適化の判断基準

### 1. 時間計算量の改善
- **ボトルネックの特定**: 最も時間がかかる操作を特定
- **改善の余地**: 時間計算量を改善できるか判断

### 2. 空間計算量の改善
- **メモリ使用量**: メモリ制約を考慮
- **不要なデータ**: 削除できるデータを特定

### 3. 実際の実行時間
- **定数係数**: 時間計算量だけでなく、定数係数も考慮
- **キャッシュ効率**: メモリアクセスのパターンを考慮

## 実践的なアプローチ

### ステップ1: プロファイリング
1. ボトルネックを特定
2. 時間計算量を分析
3. 空間計算量を分析

### ステップ2: 最適化の選択
1. 適用可能な最適化テクニックを選択
2. 時間・空間のトレードオフを考慮
3. 実装の複雑さを考慮

### ステップ3: 実装と検証
1. 最適化を実装
2. 正しさを検証
3. 性能を測定

## よくある間違い

### 1. 早期最適化
- **問題**: 必要以上に早く最適化
- **解決策**: まず正しい実装を作成
- **注意**: 最適化は正しさの後に

### 2. 可読性の犠牲
- **問題**: 最適化で可読性が低下
- **解決策**: 可読性と効率のバランスを取る
- **注意**: 過度な最適化を避ける

### 3. 測定の不足
- **問題**: 最適化の効果を測定しない
- **解決策**: 最適化前後で性能を測定
- **注意**: 実際の改善を確認

## 関連リソース

- [Problem Pattern Guide](./problem_pattern_guide.md) - 問題パターンの識別
- [Technique Combination Guide](./technique_combination_guide.md) - テクニックの組み合わせ
- [各テクニックのREADME](../README.md) - 詳細な解説

---

**重要**: 最適化は、正しい実装の後に行うべきです。まず正しい実装を作成し、その後で最適化を検討しましょう。

