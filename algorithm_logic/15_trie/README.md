# トライ木 (Trie)

## 概要

トライ木（Trie、Prefix Tree）は、文字列の集合を効率的に保存・検索するための木構造のデータ構造です。文字列の**共通プレフィックスを共有**することで、メモリを効率的に使用し、高速な検索を実現します。文字列検索、自動補完、IPルーティングなどで広く使用されています。

## 基本概念

### トライ木の構造

1. **ルートノード**: 空文字列を表す
2. **エッジ**: 各エッジは1つの文字を表す
3. **ノード**: 各ノードは文字列のプレフィックスを表す
4. **終端マーカー**: 単語の終わりを示すフラグ

### 主な操作と計算量

| 操作 | 時間計算量 | 空間計算量 | 適用場面 |
|------|-----------|-----------|---------|
| 挿入 | O(m) | O(m) | mは文字列の長さ |
| 検索 | O(m) | O(1) | 文字列の存在確認 |
| プレフィックス検索 | O(m) | O(1) | 共通プレフィックスを持つ文字列を検索 |
| 削除 | O(m) | O(1) | 文字列の削除 |

**注意**: 時間計算量は文字列の長さに比例し、文字列の数には依存しません。これがトライ木の最大の利点です。

## いつ使うべきか

トライ木は以下のような場面で威力を発揮します：

### 1. 文字列の高速検索
- 大量の文字列から特定の文字列を高速に検索
- 文字列の存在確認をO(m)で実行

### 2. プレフィックス検索
- 共通プレフィックスを持つ文字列を全て検索
- 自動補完機能の実装

### 3. 文字列の集合管理
- 辞書や単語リストの管理
- スペルチェッカー

### 4. IPルーティング
- IPアドレスの最長プレフィックスマッチ
- ルーティングテーブルの管理

## 現実世界での応用例

### 1. 検索エンジンの自動補完
- **例**: Google検索で、入力中のクエリに対する候補を表示
- **実装**: トライ木に検索履歴を保存し、プレフィックス検索で候補を取得
- **メリット**: ユーザーの入力効率を向上

### 2. スペルチェッカー
- **例**: ワードプロセッサで、入力中の単語のスペルをチェック
- **実装**: 辞書をトライ木に保存し、単語の存在を確認
- **メリット**: リアルタイムでスペルエラーを検出

### 3. IPルーティング（最長プレフィックスマッチ）
- **例**: ルーターが、IPアドレスに基づいて最適な経路を選択
- **実装**: IPアドレスをトライ木に保存し、最長の一致するプレフィックスを検索
- **メリット**: 効率的なパケットルーティング

### 4. オートコンプリート機能
- **例**: IDEのコード補完機能
- **実装**: 関数名や変数名をトライ木に保存し、入力に基づいて候補を表示
- **メリット**: 開発効率を向上

### 5. 電話帳アプリケーション
- **例**: 電話番号や名前の検索
- **実装**: 連絡先をトライ木に保存し、名前のプレフィックスで検索
- **メリット**: 高速な連絡先検索

### 6. データベースのインデックス
- **例**: 全文検索エンジンで、キーワードの検索
- **実装**: 文書内の単語をトライ木に保存し、高速に検索
- **メリット**: 大量のデータから高速に検索

## 実装時の注意点

### 1. ノードの構造
- **問題**: 各ノードにどのような情報を保存するか
- **解決策**: 
  - 子ノードへのポインタ（配列または辞書）
  - 終端フラグ（単語の終わりを示す）
  - 必要に応じて、追加の情報（出現回数など）
- **実装**: `children = {}`（辞書）または`children = [None] * 26`（配列）

### 2. メモリ使用量
- **問題**: 文字セットが大きい場合、メモリを大量に消費する可能性
- **解決策**: 
  - 辞書を使う場合: 実際に使用される文字のみを保存
  - 配列を使う場合: 固定サイズだが、未使用の領域も確保
- **トレードオフ**: 時間効率 vs 空間効率

### 3. 削除操作の実装
- **問題**: ノードを削除する際、他の単語に影響を与えないようにする必要がある
- **解決策**: 
  - 終端フラグをfalseにする
  - 子ノードがなく、終端フラグもfalseの場合のみノードを削除
- **注意**: 再帰的に親ノードも削除する必要がある場合がある

### 4. プレフィックス検索の実装
- **問題**: 共通プレフィックスを持つ全ての文字列を効率的に取得
- **解決策**: DFS（深さ優先探索）で、プレフィックスノードから全ての子ノードを探索
- **実装**: 再帰的に全ての終端ノードを収集

### 5. 大文字小文字の扱い
- **問題**: 大文字小文字を区別するかどうか
- **解決策**: 問題の要件に応じて、小文字に統一するか、区別するか決定
- **実装**: 挿入・検索時に`.lower()`で統一

## 関連するLeetCode/AtCoder問題

### Medium
- [Implement Trie](./implement_trie_logic.md) - トライ木の基本実装
- [Word Search II](./word_search_ii_logic.md) - トライ木 + バックトラッキング
- [Longest Word in Dictionary](./longest_word_dictionary_logic.md) - トライ木の応用

### Hard
- [Concatenated Words](../leetcode/hard/) - トライ木を使った文字列連結
- [Maximum XOR of Two Numbers](../leetcode/hard/) - トライ木の応用（ビット操作）

## 学習の進め方

1. **Implement Trie**から始める: トライ木の最も基本的な実装
2. **Word Search II**でバックトラッキングと組み合わせ: 複雑な問題への応用
3. **より複雑な問題**に挑戦: 他のテクニックと組み合わせた使用法を学ぶ

## 次のステップ

- [Implement Trie のロジック解説](./implement_trie_logic.md)
- [Word Search II のロジック解説](./word_search_ii_logic.md)
- [バックトラッキングテクニック](../14_backtracking/README.md) - トライ木と組み合わせて使用

---

**重要**: トライ木は文字列検索に特化した強力なデータ構造です。特にプレフィックス検索が必要な場合、他のデータ構造よりも圧倒的に効率的です。

