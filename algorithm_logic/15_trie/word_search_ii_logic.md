# Word Search II - ロジック解説

## 問題概要

2次元グリッド`board`と単語のリスト`words`が与えられたとき、グリッド内で見つかる全ての単語を返す。単語は上下左右に隣接するセルを辿って形成できる。

**制約**:
- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 12`
- `1 <= words.length <= 3 * 10^4`

**例**:
```
Input: board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]]
       words = ["oath","pea","eat","rain"]
Output: ["eat","oath"]
```

## ロジックの核心

### なぜトライ木 + バックトラッキングが有効か？

**素朴なアプローチ（非効率）**:
- 各単語について、グリッド全体を探索
- 時間計算量: O(words × m × n × 4^L) - Lは単語の長さ

**トライ木 + バックトラッキングを使う理由**:
- **共通プレフィックスの共有**: 複数の単語の共通プレフィックスを一度だけ探索
- **早期終了**: プレフィックスが存在しない場合は即座に終了
- **時間計算量**: O(m × n × 4^L) - 大幅に改善

### 思考プロセス

1. **トライ木の構築**: 全ての単語をトライ木に挿入
2. **グリッドの探索**: 各セルからDFSで探索を開始
3. **バックトラッキング**: 
   - トライ木を辿りながら、有効なパスを探索
   - 単語が見つかったら結果に追加
   - 無効なパスの場合は戻る

### アルゴリズムのステップ

```
function findWords(board, words):
    // 1. トライ木を構築
    trie = buildTrie(words)
    result = []
    
    // 2. 各セルから探索を開始
    for i in range(m):
        for j in range(n):
            dfs(board, i, j, trie.root, "", result)
    
    return result

function dfs(board, i, j, node, word, result):
    // 境界チェック
    if i < 0 or i >= m or j < 0 or j >= n:
        return
    
    char = board[i][j]
    // トライ木に存在しない、または既に訪問済み
    if char not in node.children or char == "#":
        return
    
    // 次のノードに進む
    node = node.children[char]
    word += char
    
    // 単語が見つかった
    if node.is_end:
        result.append(word)
        node.is_end = False  // 重複を避ける
    
    // セルをマーク（訪問済み）
    board[i][j] = "#"
    
    // 4方向に探索
    dfs(board, i+1, j, node, word, result)
    dfs(board, i-1, j, node, word, result)
    dfs(board, i, j+1, node, word, result)
    dfs(board, i, j-1, node, word, result)
    
    // バックトラック: セルを元に戻す
    board[i][j] = char
```

## 具体例でのトレース

### 例: `board = [["o","a"],["e","t"]]`, `words = ["oat","eat"]`

```
トライ木:
    root
     |
     o
     |
     a
     |
     t (is_end=True for "oat")
    
    root
     |
     e
     |
     a
     |
     t (is_end=True for "eat")

(0,0)から探索開始: "o"
  (0,1): "oa"
    (1,1): "oat" ✓ 結果に追加
  (1,0): "oe" → トライ木に存在しない

(1,0)から探索開始: "e"
  (1,1): "ea"
    (0,1): "eat" ✓ 結果に追加
  (0,0): "eo" → トライ木に存在しない

結果: ["oat","eat"]
```

## 現実世界での応用

### 1. ワードパズルゲーム
- **シナリオ**: スクラブルやボグルなどのワードパズルゲーム
- **実装**: グリッド上の文字から単語を形成し、辞書と照合
- **例**: モバイルゲームのワードパズル
- **メリット**: ゲームの自動検証機能

### 2. 文字認識システム
- **シナリオ**: OCRで認識した文字から単語を抽出
- **実装**: 認識された文字をグリッドとして扱い、辞書と照合
- **例**: 文書スキャナーの文字認識
- **メリット**: 認識精度の向上

### 3. 遺伝子配列解析
- **シナリオ**: DNA配列から特定のパターンを検索
- **実装**: 配列をグリッドとして扱い、パターンを探索
- **例**: バイオインフォマティクスの研究
- **メリット**: 遺伝子の機能を理解

### 4. ネットワークセキュリティ
- **シナリオ**: ネットワークトラフィックから悪意のあるパターンを検出
- **実装**: パケットデータをグリッドとして扱い、パターンを探索
- **例**: 侵入検知システム
- **メリット**: セキュリティ脅威の早期検出

### 5. データマイニング
- **シナリオ**: 大量のデータから特定のパターンを検索
- **実装**: データをグリッドとして扱い、パターンを探索
- **例**: ビッグデータの分析
- **メリット**: 隠れたパターンの発見

### 6. 画像処理
- **シナリオ**: 画像内の文字を認識し、単語を抽出
- **実装**: 画像をグリッドとして扱い、文字認識と単語検索を組み合わせ
- **例**: 看板の文字認識
- **メリット**: 自動化された情報抽出

## 注意点と落とし穴

### 1. 訪問済みセルのマーク
- **問題**: 同じセルを複数回訪問しないようにする必要がある
- **解決策**: 訪問中のセルを一時的にマーク（例: "#"）
- **実装**: `board[i][j] = "#"`でマークし、バックトラック時に元に戻す
- **注意**: マークを忘れると、無限ループが発生する可能性

### 2. 重複の回避
- **問題**: 同じ単語が複数回見つかる可能性がある
- **解決策**: 単語を見つけた後、終端フラグをfalseにする
- **実装**: `node.is_end = False`で重複を避ける
- **注意**: セットを使う方法もあるが、トライ木の終端フラグを変更する方が効率的

### 3. トライ木の構築
- **問題**: 全ての単語をトライ木に挿入する必要がある
- **解決策**: 事前にトライ木を構築
- **実装**: `buildTrie(words)`で構築
- **注意**: トライ木の構築時間も考慮する必要がある

### 4. 時間計算量の理解
- **平均**: O(m × n × 4^L) - Lは最長の単語の長さ
- **最悪**: O(m × n × 4^L) - 常に指数時間
- **空間**: O(ALPHABET_SIZE × N × M) - Nは単語数、Mは平均長
- **注意**: トライ木により、共通プレフィックスの探索が効率化される

### 5. メモ化の可能性
- **問題**: 同じ状態が複数回計算される可能性があるか？
- **解決策**: この問題では、各セルは1回だけ訪問されるため、メモ化は不要
- **理由**: 訪問済みマークにより、重複を避けている
- **注意**: 他の問題では、メモ化が有効な場合がある

### 6. 境界チェック
- **問題**: 配列の範囲外アクセスに注意が必要
- **解決策**: 各DFS呼び出しで境界をチェック
- **実装**: `if i < 0 or i >= m or j < 0 or j >= n: return`
- **注意**: 境界チェックを忘れると、エラーが発生

### 7. バックトラック時の状態復元
- **問題**: バックトラック時に、セルの状態を正確に復元する必要がある
- **解決策**: 再帰呼び出しの後、マークを元に戻す
- **実装**: `board[i][j] = char`で元に戻す
- **注意**: 状態を復元しないと、他の探索に影響を与える

### 8. トライ木ノードの共有
- **問題**: 複数の単語が同じプレフィックスを持つ場合、ノードを共有
- **解決策**: トライ木の構造により、自動的にノードが共有される
- **メリット**: メモリを効率的に使用
- **注意**: 終端フラグの管理が重要

## 関連問題

- [Word Search](../leetcode/medium/) - 単一の単語を検索
- [Implement Trie](./implement_trie_logic.md) - トライ木の基本実装
- [Longest Word in Dictionary](./longest_word_dictionary_logic.md) - トライ木の応用
- [Concatenated Words](../leetcode/hard/) - トライ木を使った文字列連結

---

**次のステップ**: [Longest Word in Dictionary](./longest_word_dictionary_logic.md)でトライ木の応用を学ぶ

