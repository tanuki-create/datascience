# Coordinate Compression - ロジック解説

## 問題概要

大きな値の配列が与えられたとき、値を連続する小さな整数にマッピングする（座標圧縮）。

**制約**:
- `1 <= n <= 10^5`
- `-10^9 <= values[i] <= 10^9`

**例**:
```
Input: values = [1000000000, 5, 1000000000, 3, 5]
Output: compressed = [2, 1, 2, 0, 1]
説明: 
- 3 → 0
- 5 → 1
- 1000000000 → 2
```

## ロジックの核心

### なぜ座標圧縮が有効か？

**直接使用（メモリ不足）**:
- 大きな値を直接インデックスとして使用
- セグメント木のサイズが10^9になる可能性

**座標圧縮を使う理由**:
- **値のマッピング**: 大きな値を小さな整数にマッピング
- **メモリ効率**: セグメント木のサイズを削減
- **時間計算量**: O(n log n) - ソートのコスト

### 思考プロセス

1. **値の収集**: 全てのユニークな値を収集
2. **ソート**: 値をソート
3. **マッピング**: 各値をインデックスにマッピング

### アルゴリズムのステップ

```
function coordinateCompression(values):
    // ユニークな値を収集してソート
    unique_values = sorted(set(values))
    
    // 値からインデックスへのマッピングを作成
    compression = {val: idx for idx, val in enumerate(unique_values)}
    
    // 圧縮された値を返す
    compressed = [compression[val] for val in values]
    
    return compressed, compression, unique_values
```

## 具体例でのトレース

### 例: `values = [1000000000, 5, 1000000000, 3, 5]`

```
ステップ1: ユニークな値を収集
  set(values) = {1000000000, 5, 3}

ステップ2: ソート
  unique_values = [3, 5, 1000000000]

ステップ3: マッピングを作成
  compression = {3: 0, 5: 1, 1000000000: 2}

ステップ4: 圧縮
  compressed = [2, 1, 2, 0, 1]

結果: compressed = [2, 1, 2, 0, 1]
```

## 現実世界での応用

### 1. データベースのインデックス
- **シナリオ**: データベースで、大きなIDを小さなインデックスにマッピング
- **実装**: 座標圧縮でIDをインデックスに変換
- **メリット**: インデックスのサイズを削減

### 2. 地理情報システム
- **シナリオ**: GISで、大きな座標を小さなインデックスにマッピング
- **実装**: 座標圧縮で座標をインデックスに変換
- **メリット**: メモリ効率的な処理

### 3. 画像処理
- **シナリオ**: 画像処理で、ピクセル座標を圧縮
- **実装**: 座標圧縮で座標をインデックスに変換
- **メリット**: 効率的な画像処理

### 4. ゲーム開発
- **シナリオ**: ゲームで、大きな座標を小さなインデックスにマッピング
- **実装**: 座標圧縮で座標をインデックスに変換
- **メリット**: 効率的なゲーム処理

### 5. データ分析
- **シナリオ**: データ分析で、大きな値を小さなインデックスにマッピング
- **実装**: 座標圧縮で値をインデックスに変換
- **メリット**: 効率的なデータ分析

### 6. ネットワーク分析
- **シナリオ**: ネットワーク分析で、大きなノードIDを小さなインデックスにマッピング
- **実装**: 座標圧縮でIDをインデックスに変換
- **メリット**: 効率的なネットワーク分析

## 注意点と落とし穴

### 1. 値の収集
- **問題**: 全てのユニークな値を収集する必要がある
- **解決策**: セットを使用してユニークな値を収集
- **実装**: `unique_values = sorted(set(values))`
- **注意**: ソートすることで、順序を保持

### 2. マッピングの作成
- **問題**: 値からインデックスへのマッピングを作成
- **解決策**: 辞書を使用してマッピングを作成
- **実装**: `compression = {val: idx for idx, val in enumerate(unique_values)}`
- **注意**: マッピングを正確に作成する必要がある

### 3. 逆変換
- **問題**: インデックスから値への逆変換が必要な場合
- **解決策**: 配列を使用して逆変換を実現
- **実装**: `decompression = unique_values`
- **注意**: 逆変換も効率的に実装可能

### 4. 時間計算量の理解
- **平均**: O(n log n) - ソートのコスト
- **最悪**: O(n log n) - 常に同じ時間計算量
- **空間**: O(n) - ユニークな値の配列とマッピング
- **注意**: ソートのコストが支配的

### 5. 順序の保持
- **問題**: 値の順序を保持する必要がある
- **解決策**: ソートすることで、順序を保持
- **実装**: `sorted(set(values))`でソート
- **注意**: 順序を保持することで、範囲クエリが可能

### 6. 重複の処理
- **問題**: 同じ値が複数回出現する場合の処理
- **解決策**: セットを使用して重複を除去
- **実装**: `set(values)`で重複を除去
- **注意**: 重複を除去することで、マッピングが一意になる

### 7. セグメント木との組み合わせ
- **問題**: 座標圧縮後、セグメント木を使用する場合
- **解決策**: 圧縮された値をセグメント木のインデックスとして使用
- **実装**: セグメント木のサイズがユニークな値の数になる
- **メリット**: メモリ使用量を大幅に削減

### 8. エッジケースの処理
- **問題**: 空の配列、1つの値、全て同じ値の場合
- **解決策**: 各操作でエッジケースをチェック
- **実装**: `if not values: return []`などのチェック
- **注意**: エッジケースを忘れると、エラーが発生

## 関連問題

- [Count of Smaller Numbers After Self](../leetcode/hard/) - 座標圧縮 + セグメント木
- [Reverse Pairs](../leetcode/hard/) - 座標圧縮 + セグメント木
- [Range Sum Query](../25_segment_tree/range_sum_query_segment_tree_logic.md) - セグメント木との組み合わせ
- [Fenwick Tree](../leetcode/hard/) - 座標圧縮 + Fenwick Tree

---

**次のステップ**: [Designテクニック](../27_design/README.md)で設計問題を学ぶ

