# セグメント木 (Segment Tree)

## 概要

セグメント木は、配列の範囲クエリ（合計、最小値、最大値など）を効率的に処理するデータ構造です。AtCoderで頻出のテクニックで、**範囲クエリと点更新をO(log n)で実行**できます。累積和と異なり、**要素の更新も効率的**に処理できます。

## 基本概念

### セグメント木の構造

1. **完全二分木**: 配列を完全二分木として表現
2. **葉ノード**: 各要素に対応
3. **内部ノード**: 子ノードの情報を統合（合計、最小値など）

### 主な操作と計算量

| 操作 | 時間計算量 | 空間計算量 | 適用場面 |
|------|-----------|-----------|---------|
| 構築 | O(n) | O(n) | 初期化 |
| 範囲クエリ | O(log n) | O(1) | 範囲の合計/最小値/最大値 |
| 点更新 | O(log n) | O(1) | 要素の更新 |

**注意**: セグメント木は、範囲更新もO(log n)で処理できます（遅延評価を使用）。

## いつ使うべきか

セグメント木は以下のような場面で威力を発揮します：

### 1. 範囲クエリ + 更新
- 範囲の合計/最小値/最大値を取得し、要素を更新
- 累積和では更新がO(n)だが、セグメント木はO(log n)

### 2. AtCoderの問題
- 範囲クエリと更新が混在する問題
- 遅延評価セグメント木が必要な問題

### 3. データ構造の問題
- 動的な範囲クエリを処理する必要がある場合

## 現実世界での応用例

### 1. データベースのクエリ最適化
- **例**: データベースで、範囲クエリと更新を効率的に処理
- **実装**: セグメント木で範囲クエリと更新を処理
- **メリット**: クエリの実行時間を短縮

### 2. ゲーム開発
- **例**: ゲームで、スコアの範囲クエリと更新を処理
- **実装**: セグメント木で範囲クエリと更新を処理
- **メリット**: 効率的なゲーム処理

### 3. 金融取引システム
- **例**: 金融取引で、価格の範囲クエリと更新を処理
- **実装**: セグメント木で範囲クエリと更新を処理
- **メリット**: 効率的な取引処理

### 4. ログ分析
- **例**: ログ分析で、時間範囲のクエリと更新を処理
- **実装**: セグメント木で範囲クエリと更新を処理
- **メリット**: 効率的なログ分析

### 5. 画像処理
- **例**: 画像処理で、矩形領域のクエリと更新を処理
- **実装**: 2次元セグメント木で範囲クエリと更新を処理
- **メリット**: 効率的な画像処理

### 6. ネットワーク監視
- **例**: ネットワーク監視で、トラフィックの範囲クエリと更新を処理
- **実装**: セグメント木で範囲クエリと更新を処理
- **メリット**: 効率的なネットワーク監視

## 実装時の注意点

### 1. 配列のサイズ
- **問題**: セグメント木の配列サイズは2のべき乗に調整
- **解決策**: `size = 2 ** (n-1).bit_length()`でサイズを決定
- **実装**: 完全二分木にするため、サイズを調整
- **注意**: サイズを間違えると、インデックスの計算が複雑になる

### 2. インデックスの計算
- **問題**: 親子関係のインデックスを正確に計算する必要がある
- **解決策**: 
  - 親: `(i - 1) // 2`
  - 左の子: `2 * i + 1`
  - 右の子: `2 * i + 2`
- **実装**: インデックスの計算を正確に実装
- **注意**: 0-basedか1-basedかを明確にする

### 3. 遅延評価
- **問題**: 範囲更新を効率的に処理する必要がある場合
- **解決策**: 遅延評価セグメント木を使用
- **実装**: 更新を遅延させ、必要になったときに適用
- **注意**: 実装が複雑になる

## 関連するLeetCode/AtCoder問題

### Medium
- [Range Sum Query - Mutable](./range_sum_query_segment_tree_logic.md) - セグメント木の基本
- [Range Minimum Query](./range_minimum_query_logic.md) - 最小値クエリ

### Hard
- [Range Sum Query 2D - Mutable](../leetcode/hard/) - 2次元セグメント木

## 学習の進め方

1. **Range Sum Query**から始める: セグメント木の最も基本的な例
2. **Range Minimum Query**で最小値クエリを学ぶ: 異なる演算の適用
3. **より複雑な問題**に挑戦: 遅延評価セグメント木などの応用を学ぶ

## 次のステップ

- [Range Sum Query - Mutable のロジック解説](./range_sum_query_segment_tree_logic.md)
- [Range Minimum Query のロジック解説](./range_minimum_query_logic.md)
- [累積和テクニック](../19_prefix_sum/README.md) - セグメント木と比較

---

**重要**: セグメント木は、AtCoderで頻出のテクニックです。範囲クエリと更新が混在する問題で強力です。

