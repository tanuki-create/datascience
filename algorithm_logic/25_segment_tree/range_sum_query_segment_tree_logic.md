# Range Sum Query - Mutable (Segment Tree) - ロジック解説

## 問題概要

配列`nums`が与えられたとき、範囲[i, j]の合計を取得し、要素を更新するクエリを複数回処理する。

**制約**:
- `1 <= nums.length <= 3 * 10^4`
- クエリ数は最大3 * 10^4

**例**:
```
Input: nums = [1,3,5]
Query: sumRange(0,2) → 9
Update: update(1,2) → nums = [1,2,5]
Query: sumRange(0,2) → 8
```

## ロジックの核心

### なぜセグメント木が有効か？

**累積和（更新がO(n)）**:
- 範囲クエリはO(1)だが、更新がO(n)
- 時間計算量: O(n×q) - qはクエリ数

**セグメント木を使う理由**:
- **範囲クエリ**: O(log n)で範囲の合計を取得
- **点更新**: O(log n)で要素を更新
- **時間計算量**: O(q log n) - 大幅に改善

### 思考プロセス

1. **セグメント木の構築**: 配列を完全二分木として表現
2. **範囲クエリ**: 範囲に含まれるセグメントを統合
3. **点更新**: 葉ノードから根まで更新を伝播

### アルゴリズムのステップ

```
class SegmentTree:
    def __init__(self, nums):
        n = len(nums)
        self.n = n
        self.size = 2 ** (n-1).bit_length()
        self.tree = [0] * (2 * self.size)
        
        // 葉ノードに値を設定
        for i in range(n):
            self.tree[self.size + i] = nums[i]
        
        // 内部ノードを構築
        for i in range(self.size - 1, 0, -1):
            self.tree[i] = self.tree[2*i] + self.tree[2*i+1]
    
    def update(self, index, val):
        index += self.size
        self.tree[index] = val
        
        // 親ノードを更新
        while index > 1:
            index //= 2
            self.tree[index] = self.tree[2*index] + self.tree[2*index+1]
    
    def query(self, left, right):
        left += self.size
        right += self.size
        result = 0
        
        while left <= right:
            if left % 2 == 1:
                result += self.tree[left]
                left += 1
            if right % 2 == 0:
                result += self.tree[right]
                right -= 1
            left //= 2
            right //= 2
        
        return result
```

## 具体例でのトレース

### 例: `nums = [1,3,5]`, `sumRange(0,2)`, `update(1,2)`, `sumRange(0,2)`

```
セグメント木の構築:
  size = 4
  tree = [0,9,4,5,1,3,5,0]
          根
         /  \
       4     5
      / \   / \
     1  3  5  0

sumRange(0,2):
  left=4, right=6
  left%2=0, right%2=0
  result += tree[6]=5
  right=5
  left=2, right=2
  result += tree[2]=4
  結果: 4+5=9

update(1,2):
  index=5
  tree[5]=2
  tree[2]=1+2=3
  tree[1]=3+5=8

sumRange(0,2):
  結果: 8
```

## 現実世界での応用

### 1. データベースのクエリ最適化
- **シナリオ**: データベースで、範囲クエリと更新を効率的に処理
- **実装**: セグメント木で範囲クエリと更新を処理
- **メリット**: クエリの実行時間を短縮

### 2. ゲーム開発
- **シナリオ**: ゲームで、スコアの範囲クエリと更新を処理
- **実装**: セグメント木で範囲クエリと更新を処理
- **メリット**: 効率的なゲーム処理

### 3. 金融取引システム
- **シナリオ**: 金融取引で、価格の範囲クエリと更新を処理
- **実装**: セグメント木で範囲クエリと更新を処理
- **メリット**: 効率的な取引処理

### 4. ログ分析
- **シナリオ**: ログ分析で、時間範囲のクエリと更新を処理
- **実装**: セグメント木で範囲クエリと更新を処理
- **メリット**: 効率的なログ分析

### 5. 画像処理
- **シナリオ**: 画像処理で、矩形領域のクエリと更新を処理
- **実装**: 2次元セグメント木で範囲クエリと更新を処理
- **メリット**: 効率的な画像処理

### 6. ネットワーク監視
- **シナリオ**: ネットワーク監視で、トラフィックの範囲クエリと更新を処理
- **実装**: セグメント木で範囲クエリと更新を処理
- **メリット**: 効率的なネットワーク監視

## 注意点と落とし穴

### 1. 配列のサイズ
- **問題**: セグメント木の配列サイズは2のべき乗に調整
- **解決策**: `size = 2 ** (n-1).bit_length()`でサイズを決定
- **実装**: 完全二分木にするため、サイズを調整
- **注意**: サイズを間違えると、インデックスの計算が複雑になる

### 2. インデックスの計算
- **問題**: 親子関係のインデックスを正確に計算する必要がある
- **解決策**: 
  - 親: `index // 2`
  - 左の子: `2 * index`
  - 右の子: `2 * index + 1`
- **実装**: 1-basedインデックスを使用
- **注意**: 0-basedと1-basedの違いを明確にする

### 3. 範囲クエリの実装
- **問題**: 範囲クエリを効率的に実装する必要がある
- **解決策**: 左右の境界を処理し、セグメントを統合
- **実装**: `while left <= right:`でループ
- **注意**: 境界の処理が重要

### 4. 時間計算量の理解
- **構築**: O(n) - 1回だけ実行
- **更新**: O(log n) - 各更新が対数時間
- **クエリ**: O(log n) - 各クエリが対数時間
- **合計**: O(n + q log n) - qはクエリ数

### 5. 空間計算量
- **問題**: セグメント木の配列を保存する必要がある
- **解決策**: O(n)の追加空間が必要
- **実装**: `tree`配列を保存
- **トレードオフ**: 時間効率と空間効率のトレードオフ

### 6. 累積和との比較
- **問題**: 累積和とセグメント木のどちらを使うべきか？
- **解決策**: 
  - 累積和: 更新がない場合、O(1)クエリ
  - セグメント木: 更新がある場合、O(log n)クエリと更新
- **選択**: 更新がある場合はセグメント木

### 7. 遅延評価
- **問題**: 範囲更新を効率的に処理する必要がある場合
- **解決策**: 遅延評価セグメント木を使用
- **実装**: 更新を遅延させ、必要になったときに適用
- **注意**: 実装が複雑になる

### 8. エッジケースの処理
- **問題**: 空の配列、1つの要素、範囲が無効な場合
- **解決策**: 各操作でエッジケースをチェック
- **実装**: `if not nums: return []`などのチェック
- **注意**: エッジケースを忘れると、エラーが発生

## 関連問題

- [Range Minimum Query](./range_minimum_query_logic.md) - 最小値クエリ
- [Range Sum Query 2D - Mutable](../leetcode/hard/) - 2次元セグメント木
- [Range Sum Query](../19_prefix_sum/range_sum_query_logic.md) - 累積和との比較
- [Fenwick Tree](../leetcode/hard/) - セグメント木の代替

---

**次のステップ**: [Range Minimum Query](./range_minimum_query_logic.md)で最小値クエリを学ぶ

