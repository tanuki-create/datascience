# Fenwick Tree (Binary Indexed Tree) - ロジック解説

## 問題概要

Fenwick Tree（Binary Indexed Tree、BIT）は、配列の範囲クエリ（合計、最小値、最大値など）を効率的に処理するデータ構造です。セグメント木と同様の機能を提供しますが、**実装がよりシンプル**で、**メモリ効率が良い**という利点があります。AtCoderで頻出のテクニックです。

**例**:
```
配列: [1, 3, 5, 7, 9, 11]
範囲クエリ: sum(0, 3) → 16 (1+3+5+7)
点更新: update(2, 10) → インデックス2を10に更新
```

## ロジックの核心

### なぜFenwick Treeが有効か？

**累積和（O(n)更新）**:
- 範囲クエリはO(1)だが、点更新がO(n)
- 時間計算量: 更新でO(n) - 非効率

**セグメント木（O(log n)更新）**:
- 範囲クエリと点更新がO(log n)
- 実装が複雑で、メモリ使用量が多い

**Fenwick Treeを使う理由**:
- **シンプルな実装**: セグメント木より実装が簡単
- **メモリ効率**: セグメント木よりメモリ使用量が少ない
- **時間計算量**: 範囲クエリと点更新がO(log n)
- **空間計算量**: O(n) - セグメント木より少ない

### アルゴリズムのステップ

#### 1. Fenwick Treeの構造

Fenwick Treeは、各インデックスが管理する範囲をビット演算で決定します。

```
インデックス i が管理する範囲:
- i の最下位ビット（LSB）を取得
- i から i - LSB(i) + 1 までの範囲を管理
```

#### 2. 更新操作（update）

```
function update(index, delta):
    i = index + 1  // 1-based indexing
    while i <= n:
        tree[i] += delta
        i += i & -i  // LSBを加算
```

#### 3. 範囲クエリ（query）

```
function query(index):
    sum = 0
    i = index + 1  // 1-based indexing
    while i > 0:
        sum += tree[i]
        i -= i & -i  // LSBを減算
    return sum

function rangeQuery(left, right):
    return query(right) - query(left - 1)
```

### 具体例でのトレース

#### 例: 配列 [1, 3, 5, 7, 9, 11] の構築

**初期状態**:
```
配列: [1, 3, 5, 7, 9, 11]
インデックス: 0  1  2  3  4  5
```

**Fenwick Treeの構築**:
```
update(0, 1): tree[1] += 1
update(1, 3): tree[2] += 3, tree[4] += 3
update(2, 5): tree[3] += 5, tree[4] += 5
update(3, 7): tree[4] += 7, tree[8] += 7
update(4, 9): tree[5] += 9, tree[6] += 9
update(5, 11): tree[6] += 11, tree[8] += 11

最終的なtree配列:
tree[1] = 1
tree[2] = 3
tree[3] = 5
tree[4] = 1+3+5+7 = 16
tree[5] = 9
tree[6] = 9+11 = 20
tree[7] = 0
tree[8] = 1+3+5+7+9+11 = 36
```

**範囲クエリ: sum(0, 3)**:
```
query(3) = tree[4] = 16
query(-1) = 0
sum(0, 3) = 16 - 0 = 16 ✓
```

**点更新: update(2, 10)**:
```
update(2, 10):
  i = 3
  tree[3] += 10 → tree[3] = 15
  i += 3 & -3 = 3 + 1 = 4
  tree[4] += 10 → tree[4] = 26
  i += 4 & -4 = 4 + 4 = 8
  tree[8] += 10 → tree[8] = 46
```

## 現実世界での応用

### 1. データベースのインデックス
- **シナリオ**: データベースで、範囲クエリと更新を効率的に処理
- **実装**: Fenwick Treeで範囲クエリと更新を処理
- **メリット**: 効率的なクエリ処理

### 2. 金融取引システム
- **シナリオ**: 金融取引で、価格の範囲クエリと更新を処理
- **実装**: Fenwick Treeで範囲クエリと更新を処理
- **メリット**: リアルタイムの取引処理

### 3. ゲーム開発
- **シナリオ**: ゲームで、スコアの範囲クエリと更新を処理
- **実装**: Fenwick Treeで範囲クエリと更新を処理
- **メリット**: 効率的なゲーム処理

### 4. ログ分析
- **シナリオ**: ログ分析で、時間範囲のクエリと更新を処理
- **実装**: Fenwick Treeで範囲クエリと更新を処理
- **メリット**: 効率的なログ分析

### 5. 画像処理
- **シナリオ**: 画像処理で、矩形領域のクエリと更新を処理
- **実装**: 2次元Fenwick Treeで範囲クエリと更新を処理
- **メリット**: 効率的な画像処理

### 6. ネットワーク監視
- **シナリオ**: ネットワーク監視で、トラフィックの範囲クエリと更新を処理
- **実装**: Fenwick Treeで範囲クエリと更新を処理
- **メリット**: 効率的なネットワーク監視

## 注意点と落とし穴

### 1. 1-basedインデックス
- **問題**: Fenwick Treeは1-basedインデックスを使用
- **解決策**: 配列のインデックスに1を加算して使用
- **実装**: `i = index + 1`で変換
- **注意**: 0-basedインデックスと混同しない

### 2. LSBの計算
- **問題**: LSB（最下位ビット）の計算が重要
- **解決策**: `i & -i`でLSBを取得
- **実装**: ビット演算でLSBを計算
- **注意**: 負の数の2の補数表現を理解する必要がある

### 3. 範囲クエリの実装
- **問題**: 範囲クエリは2つのクエリの差で計算
- **解決策**: `rangeQuery(left, right) = query(right) - query(left - 1)`
- **実装**: 累積和の差で範囲クエリを計算
- **注意**: left=0の場合の処理に注意

### 4. 更新の実装
- **問題**: 更新は差分（delta）で行う
- **解決策**: `update(index, new_value - old_value)`
- **実装**: 差分を計算して更新
- **注意**: 絶対値ではなく差分を使用

### 5. 配列のサイズ
- **問題**: Fenwick Treeのサイズは元の配列のサイズ以上
- **解決策**: `tree = [0] * (n + 1)`で初期化
- **実装**: 1-basedインデックスのため、n+1のサイズが必要
- **注意**: サイズを間違えるとインデックスエラーが発生

### 6. 負の数の扱い
- **問題**: 負の数を含む配列でも動作する
- **解決策**: 差分の計算で負の数も扱える
- **実装**: 通常の更新と同じ方法で処理
- **注意**: 範囲クエリの結果が負になる可能性がある

### 7. セグメント木との比較
- **問題**: セグメント木とFenwick Treeの選択
- **解決策**: 
  - Fenwick Tree: 範囲合計クエリに最適、実装が簡単
  - セグメント木: 任意の演算（最小値、最大値など）に対応
- **実装**: 問題の要件に応じて選択
- **注意**: 範囲最小値/最大値クエリにはセグメント木が必要

## 関連問題

- [Range Sum Query - Mutable](./range_sum_query_segment_tree_logic.md) - セグメント木との比較
- [Range Minimum Query](./range_minimum_query_logic.md) - 最小値クエリ（セグメント木が必要）
- [累積和テクニック](../19_prefix_sum/README.md) - 更新がない場合の代替

---

**次のステップ**: [遅延評価セグメント木](./lazy_segment_tree_logic.md)で範囲更新を学ぶ

