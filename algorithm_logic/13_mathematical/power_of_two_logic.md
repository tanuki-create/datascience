# Power of Two - ロジック解説

## 問題概要

整数`n`が与えられたとき、`n`が2の累乗かどうかを判定する。

**例**:
```
Input: n = 16
Output: true
説明: 16 = 2^4

Input: n = 3
Output: false
```

## ロジックの核心

### なぜビット操作が有効か？

**除算アプローチ（O(log n)）**:
- 2で割り続けて1になるか確認
- 時間計算量: O(log n)

**ビット操作を使う理由**:
- **2の累乗の特性**: 2の累乗は2進数で1つのビットのみが1
- **ビット操作**: `n & (n-1) == 0`で判定可能
- **時間計算量**: O(1) - 定数時間で高速

### 思考プロセス

1. **2の累乗の特性**: 2の累乗は2進数で`1000...0`の形式
2. **n-1の特性**: `n-1`は`0111...1`の形式
3. **AND演算**: `n & (n-1) == 0`なら2の累乗

### アルゴリズムのステップ

```
1. n <= 0 なら false を返す
2. n & (n-1) == 0 なら true、そうでなければ false
```

## 具体例でのトレース

### 例1: `n = 16`

```
16 = 10000 (2進数)
15 = 01111 (2進数)
16 & 15 = 00000 = 0
→ true
```

### 例2: `n = 3`

```
3 = 0011 (2進数)
2 = 0010 (2進数)
3 & 2 = 0010 ≠ 0
→ false
```

## 現実世界での応用

### 1. メモリ管理
- **シナリオ**: メモリサイズが2の累乗か確認
- **実装**: ビット操作で高速に判定

### 2. データ構造
- **シナリオ**: ハッシュテーブルのサイズが2の累乗か確認
- **実装**: 効率的なハッシュ計算に使用

### 3. 画像処理
- **シナリオ**: 画像サイズが2の累乗か確認
- **実装**: 効率的な画像処理に使用

## 注意点と落とし穴

1. **負の数**: 負の数は2の累乗ではない
2. **0**: 0は2の累乗ではない（2^0=1なので）
3. **ビット操作の理解**: `n & (n-1)`の動作を理解することが重要

## 関連問題

- Power of Three
- Power of Four
- Number of 1 Bits

---

**次のステップ**: [数学的アルゴリズムのREADME](./README.md)に戻る

