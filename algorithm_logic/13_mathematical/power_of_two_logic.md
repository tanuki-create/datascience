# Power of Two - ロジック解説

## 問題概要

整数`n`が与えられたとき、`n`が2の累乗かどうかを判定する。

**例**:
```
Input: n = 16
Output: true
説明: 16 = 2^4

Input: n = 3
Output: false
```

## ロジックの核心

### なぜビット操作が有効か？

**除算アプローチ（O(log n)）**:
- 2で割り続けて1になるか確認
- 時間計算量: O(log n)

**ビット操作を使う理由**:
- **2の累乗の特性**: 2の累乗は2進数で1つのビットのみが1
- **ビット操作**: `n & (n-1) == 0`で判定可能
- **時間計算量**: O(1) - 定数時間で高速

### 思考プロセス

1. **2の累乗の特性**: 2の累乗は2進数で`1000...0`の形式
2. **n-1の特性**: `n-1`は`0111...1`の形式
3. **AND演算**: `n & (n-1) == 0`なら2の累乗

### アルゴリズムのステップ

```
1. n <= 0 なら false を返す
2. n & (n-1) == 0 なら true、そうでなければ false
```

## 具体例でのトレース

### 例1: `n = 16`

```
16 = 10000 (2進数)
15 = 01111 (2進数)
16 & 15 = 00000 = 0
→ true
```

### 例2: `n = 3`

```
3 = 0011 (2進数)
2 = 0010 (2進数)
3 & 2 = 0010 ≠ 0
→ false
```

## 現実世界での応用

### 1. メモリ管理システム
- **シナリオ**: メモリサイズが2の累乗か確認
- **実装**: ビット操作で高速に判定
- **例**: メモリアロケーターで、メモリブロックのサイズが2の累乗か確認
- **メリット**: メモリの効率的な管理とアライメントに使用

### 2. ハッシュテーブルの実装
- **シナリオ**: ハッシュテーブルのサイズが2の累乗か確認
- **実装**: 効率的なハッシュ計算に使用
- **例**: ハッシュテーブルのサイズを2の累乗にすることで、モジュロ演算をビット演算に置き換え可能
- **メリット**: ハッシュ計算の高速化（`hash % size`を`hash & (size-1)`に置き換え）

### 3. 画像処理とGPU計算
- **シナリオ**: 画像サイズが2の累乗か確認
- **実装**: 効率的な画像処理に使用
- **例**: GPUでの画像処理で、テクスチャサイズが2の累乗である必要がある
- **メリット**: GPUの効率的な利用とメモリアクセスの最適化

### 4. ネットワークプロトコル
- **シナリオ**: パケットサイズが2の累乗か確認
- **実装**: ビット操作で高速に判定
- **例**: ネットワークプロトコルで、パケットサイズが2の累乗であることを確認
- **メリット**: パケット処理の効率化

### 5. ファイルシステム
- **シナリオ**: ブロックサイズが2の累乗か確認
- **実装**: ビット操作で高速に判定
- **例**: ファイルシステムで、ブロックサイズが2の累乗であることを確認
- **メリット**: ディスクアクセスの効率化

### 6. 暗号化アルゴリズム
- **シナリオ**: 鍵の長さが2の累乗か確認
- **実装**: ビット操作で高速に判定
- **例**: 暗号化アルゴリズムで、鍵の長さが2の累乗であることを確認
- **メリット**: 暗号化処理の効率化

## 注意点と落とし穴

### 1. 負の数の処理
- **問題**: 負の数は2の累乗ではない
- **解決策**: 最初に`if n <= 0: return False`をチェック
- **理由**: 2の累乗は常に正の数
- **注意**: 負の数を処理しないと、誤った結果が返される

### 2. 0の扱い
- **問題**: 0は2の累乗ではない（2^0=1なので）
- **解決策**: `n <= 0`のチェックで0も除外
- **理由**: 2^0=1であり、0は2の累乗ではない
- **注意**: 0を特別に処理する必要がある

### 3. ビット操作の理解
- **核心**: `n & (n-1) == 0`が2の累乗の判定
- **理由**: 
  - 2の累乗: `1000...0`（1つのビットのみが1）
  - n-1: `0111...1`（1のビットより下位が全て1）
  - AND演算: `1000...0 & 0111...1 = 0000...0 = 0`
- **例**: 
  - 16 = `10000`, 15 = `01111`, 16 & 15 = `00000` = 0 ✓
  - 15 = `01111`, 14 = `01110`, 15 & 14 = `01110` ≠ 0 ✗

### 4. オーバーフローの注意
- **問題**: 大きな値の場合、`n-1`がオーバーフローする可能性
- **解決策**: Pythonでは自動的に大きな整数を扱えるが、他の言語では注意が必要
- **注意**: C++やJavaでは、`n-1`がオーバーフローする可能性がある

### 5. 代替アプローチとの比較
- **除算アプローチ**: `while n > 1: n /= 2` - O(log n)時間
- **ビット操作**: `n & (n-1) == 0` - O(1)時間
- **推奨**: ビット操作が最も高速
- **注意**: 可読性とパフォーマンスのトレードオフ

### 6. 関連するビット操作テクニック
- **最下位ビットの取得**: `n & -n` - 最下位の1ビットのみを残す
- **最下位ビットの削除**: `n & (n-1)` - 最下位の1ビットを削除
- **ビット数のカウント**: `n & (n-1)`を繰り返して1のビット数をカウント
- **応用**: これらのテクニックは他のビット操作問題でも使用

## 関連問題

- Power of Three
- Power of Four
- Number of 1 Bits

---

**次のステップ**: [数学的アルゴリズムのREADME](./README.md)に戻る

