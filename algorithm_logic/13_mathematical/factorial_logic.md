# Factorial - ロジック解説

## 問題概要

整数`n`が与えられたとき、n!（階乗）を計算する。階乗は、1からnまでの全ての正の整数の積です。

**制約**:
- `0 <= n <= 12` (通常の整数型の場合)
- より大きなnの場合はモジュラー演算を使用

**例**:
```
Input: n = 5
Output: 120
説明: 5! = 5 × 4 × 3 × 2 × 1 = 120

Input: n = 0
Output: 1
説明: 0! = 1 (定義)
```

## ロジックの核心

### なぜ反復的なアプローチが有効か？

**再帰的なアプローチ（O(n)時間、O(n)空間）**:
- 再帰関数で階乗を計算
- 時間計算量: O(n)
- 空間計算量: O(n) - 再帰の深さ

**反復的なアプローチを使う理由**:
- **空間効率**: 再帰のオーバーヘッドがない
- **時間計算量**: O(n) - 同じ
- **空間計算量**: O(1) - 定数空間

### アルゴリズムのステップ

#### 方法1: 反復的な実装（推奨）

```
function factorial(n):
    if n <= 1:
        return 1
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result
```

#### 方法2: 再帰的な実装

```
function factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)
```

### 具体例でのトレース

#### 例: n = 5の階乗計算

**反復的な実装**:
```
n = 5
result = 1

i = 2:
  result = 1 * 2 = 2

i = 3:
  result = 2 * 3 = 6

i = 4:
  result = 6 * 4 = 24

i = 5:
  result = 24 * 5 = 120

結果: 120
```

**再帰的な実装**:
```
factorial(5):
  5 * factorial(4):
    4 * factorial(3):
      3 * factorial(2):
        2 * factorial(1):
          return 1
        return 2 * 1 = 2
      return 3 * 2 = 6
    return 4 * 6 = 24
  return 5 * 24 = 120

結果: 120
```

#### 例: n = 0の階乗計算

```
n = 0
if n <= 1: return 1
結果: 1
```

## 現実世界での応用

### 1. 組み合わせ計算
- **シナリオ**: n個からr個を選ぶ組み合わせの数 C(n, r) = n! / (r! × (n-r)!)
- **実装**: 階乗で組み合わせを計算
- **メリット**: 効率的な組み合わせ計算
- **例**: 52枚のカードから5枚を選ぶ方法の数 = 52! / (5! × 47!) = 2,598,960

### 2. 順列計算
- **シナリオ**: n個からr個を選んで並べる順列の数 P(n, r) = n! / (n-r)!
- **実装**: 階乗で順列を計算
- **メリット**: 効率的な順列計算
- **例**: 10人の選手から3人を選んで順位をつける方法の数 = 10! / 7! = 720

### 3. 確率計算
- **シナリオ**: 確率計算で階乗を使用
- **実装**: 階乗で確率を計算
- **メリット**: 効率的な確率計算
- **例**: 52枚のカードをシャッフルしたときの特定の順序の確率 = 1 / 52!

### 4. 統計学
- **シナリオ**: 統計学での分布の計算
- **実装**: 階乗で統計量を計算
- **メリット**: 統計解析の基礎
- **例**: ポアソン分布、二項分布の計算

### 5. 暗号学
- **シナリオ**: 暗号アルゴリズムでの計算
- **実装**: モジュラー階乗を使用
- **メリット**: 暗号化システムの実装
- **例**: RSA暗号での計算

### 6. アルゴリズムの解析
- **シナリオ**: アルゴリズムの計算量の解析
- **実装**: 階乗で計算量を表現
- **メリット**: アルゴリズムの理解
- **例**: 全探索の計算量がO(n!)の場合

## 注意点と落とし穴

### 1. オーバーフロー
- **問題**: 大きなnでオーバーフローが発生する可能性
- **解決策**: モジュラー演算を使用
- **実装**: `result = (result * i) % mod`
- **注意**: オーバーフローに注意、Pythonでは自動的に長整数に変換されるが、他の言語では注意が必要

### 2. 0の階乗
- **問題**: 0! = 1という定義を忘れがち
- **解決策**: ベースケースで0を処理
- **実装**: `if n <= 1: return 1`
- **注意**: 0の階乗は1であることを覚えておく

### 3. 負の数の処理
- **問題**: 負の数の階乗は定義されていない
- **解決策**: エラーハンドリングを追加
- **実装**: `if n < 0: raise ValueError("Factorial is not defined for negative numbers")`
- **注意**: 負の数の場合はエラーを返す

### 4. 再帰の深さ
- **問題**: 大きなnで再帰の深さが増加
- **解決策**: 反復的な実装を使用
- **実装**: ループで階乗を計算
- **注意**: スタックオーバーフローに注意

### 5. メモ化の適用
- **問題**: 同じnの階乗を複数回計算する場合
- **解決策**: メモ化を適用
- **実装**: 計算済みの結果を保存
- **注意**: 通常は1回しか計算しないので不要

### 6. 浮動小数点数の精度
- **問題**: 大きなnで浮動小数点数の精度が失われる
- **解決策**: 整数型を使用
- **実装**: 整数型で計算
- **注意**: 浮動小数点数を使用しない

### 7. モジュラー演算の適用
- **問題**: 大きなnでモジュラー演算が必要
- **解決策**: 各ステップでモジュラー演算を適用
- **実装**: `result = (result * i) % mod`
- **注意**: モジュラー演算の性質を理解する

## 関連問題

- [Combinatorics](../24_advanced_math/combinatorics_logic.md) - 組み合わせ計算
- [Power of Two](./power_of_two_logic.md) - べき乗
- [Fibonacci](./fibonacci_logic.md) - フィボナッチ数
- [Modular Arithmetic](../24_advanced_math/modular_arithmetic_logic.md) - モジュラー演算

---

**次のステップ**: [Fibonacci](./fibonacci_logic.md)でフィボナッチ数を学ぶ

