# Reverse Linked List - ロジック解説

## 問題概要

単方向リンクリストを反転する。

**制約**:
- リンクリストのノード数は0以上5000以下

**例**:
```
Input: 1 -> 2 -> 3 -> 4 -> 5
Output: 5 -> 4 -> 3 -> 2 -> 1
```

## ロジックの核心

### なぜ2つのポインタが有効か？

**再帰的アプローチ（O(n)空間）**:
- 再帰を使って反転
- 空間計算量: O(n) - 再帰スタック

**2つのポインタを使う理由**:
- **インプレース反転**: 追加のメモリを使用せずに反転
- **時間計算量**: O(n) - 1回の走査で完了
- **空間計算量**: O(1) - 定数空間

### 思考プロセス

1. **3つのポインタ**: `prev`, `current`, `next`を使用
2. **反転操作**: `current.next = prev`でリンクを反転
3. **ポインタの移動**: 3つのポインタを1つずつ進める

### アルゴリズムのステップ

```
function reverseList(head):
    prev = None
    current = head
    
    while current:
        next = current.next  // 次のノードを保存
        current.next = prev  // リンクを反転
        prev = current       // prevを進める
        current = next       // currentを進める
    
    return prev  // 新しいhead
```

## 具体例でのトレース

### 例: `1 -> 2 -> 3 -> 4 -> 5`

```
初期状態:
  prev = None
  current = 1 -> 2 -> 3 -> 4 -> 5

ステップ1:
  next = 2 -> 3 -> 4 -> 5
  current.next = None
  prev = 1 -> None
  current = 2 -> 3 -> 4 -> 5

ステップ2:
  next = 3 -> 4 -> 5
  current.next = 1 -> None
  prev = 2 -> 1 -> None
  current = 3 -> 4 -> 5

... 続けて反転

最終状態:
  prev = 5 -> 4 -> 3 -> 2 -> 1 -> None
  current = None

結果: 5 -> 4 -> 3 -> 2 -> 1
```

## 現実世界での応用

### 1. データ構造の操作
- **シナリオ**: データ構造を逆順に処理する必要がある場合
- **実装**: リンクリストを反転して処理
- **メリット**: 効率的なデータ処理

### 2. スタックの実装
- **シナリオ**: スタックをリンクリストで実装する場合
- **実装**: リンクリストを反転してスタック操作を実現
- **メリット**: 効率的なスタック実装

### 3. パリンドロームの検証
- **シナリオ**: リンクリストがパリンドロームか判定
- **実装**: リンクリストを反転して比較
- **メリット**: 効率的なパリンドローム検証

### 4. ブラウザの履歴
- **シナリオ**: ブラウザの履歴を逆順に表示
- **実装**: 履歴リストを反転
- **メリット**: 効率的な履歴管理

### 5. ログの逆順表示
- **シナリオ**: ログを新しい順に表示
- **実装**: ログリストを反転
- **メリット**: 効率的なログ表示

### 6. データの逆順処理
- **シナリオ**: データを逆順に処理する必要がある場合
- **実装**: リンクリストを反転して処理
- **メリット**: 効率的なデータ処理

## 注意点と落とし穴

### 1. ポインタの保存
- **問題**: `current.next`を変更する前に、次のノードを保存する必要がある
- **解決策**: `next = current.next`で次のノードを保存
- **実装**: リンクを変更する前に保存
- **注意**: 保存を忘れると、次のノードにアクセスできなくなる

### 2. 空のリストの処理
- **問題**: 空のリスト（head == None）の場合の処理
- **解決策**: ループが実行されず、Noneが返される
- **実装**: `while current:`で自動的に処理される
- **注意**: エッジケースの処理が重要

### 3. 1つのノードのみ
- **問題**: 1つのノードのみの場合の処理
- **解決策**: ループが1回実行され、そのまま返される
- **実装**: 通常の処理で正しく動作
- **注意**: 特別な処理は不要

### 4. 時間計算量の理解
- **平均**: O(n) - 各ノードを1回ずつ処理
- **最悪**: O(n) - 常に線形時間
- **空間**: O(1) - 定数空間のみ使用
- **メリット**: 再帰より空間効率が良い

### 5. 再帰的実装との比較
- **問題**: 再帰的実装と反復的実装のどちらを使うべきか？
- **解決策**: 
  - 反復的: O(1)空間、実装が簡単
  - 再帰的: O(n)空間、コードが簡潔
- **選択**: 通常は反復的実装を推奨

### 6. ポインタの更新順序
- **問題**: ポインタを更新する順序が重要
- **解決策**: 
  1. 次のノードを保存
  2. リンクを反転
  3. prevを進める
  4. currentを進める
- **注意**: 順序を間違えると、リンクが切れる

### 7. 新しいheadの返却
- **問題**: 反転後のheadを正確に返す必要がある
- **解決策**: `prev`が新しいheadになる
- **実装**: `return prev`で返す
- **注意**: `current`はNoneになっているため、`prev`を返す

### 8. 双方向リンクリスト
- **問題**: 双方向リンクリストの場合は、前後のポインタを両方更新
- **解決策**: `prev`と`next`の両方を更新
- **実装**: 双方向リンクリスト用の実装が必要
- **注意**: 単方向と双方向で実装が異なる

## 関連問題

- [Reverse Linked List II](../leetcode/medium/) - 部分的な反転
- [Swap Nodes in Pairs](../leetcode/medium/) - ペアごとの反転
- [Reverse Nodes in k-Group](../leetcode/hard/) - k個ごとの反転
- [Palindrome Linked List](../leetcode/easy/) - パリンドロームの検証

---

**次のステップ**: [Merge Two Sorted Lists](./merge_two_sorted_lists_logic.md)でマージ操作を学ぶ

