# リンクリスト (Linked List)

## 概要

リンクリストは、要素をノードとして連結したデータ構造です。各ノードは**データと次のノードへのポインタ**を持ちます。配列と異なり、**動的なサイズ変更**が可能で、**挿入・削除がO(1)で実行**できます。メモリ効率が良く、多くのアルゴリズムで使用されます。

## 基本概念

### リンクリストの種類

1. **単方向リンクリスト**: 各ノードが次のノードへのポインタのみを持つ
2. **双方向リンクリスト**: 各ノードが前後のノードへのポインタを持つ
3. **循環リンクリスト**: 最後のノードが最初のノードを指す

### 主な操作と計算量

| 操作 | 時間計算量 | 空間計算量 | 適用場面 |
|------|-----------|-----------|---------|
| 挿入（先頭） | O(1) | O(1) | 先頭への挿入 |
| 挿入（末尾） | O(n) | O(1) | 末尾への挿入（末尾ポインタがあればO(1)） |
| 削除 | O(n) | O(1) | 要素の削除（前のノードを探す必要がある） |
| 検索 | O(n) | O(1) | 要素の検索 |
| 反転 | O(n) | O(1) | リンクリストの反転 |

**注意**: リンクリストはランダムアクセスができないため、特定の位置へのアクセスにはO(n)時間がかかります。

## いつ使うべきか

リンクリストは以下のような場面で威力を発揮します：

### 1. 動的なサイズ変更が必要な場合
- サイズが事前に分からないデータ構造
- 頻繁に挿入・削除が行われる場合

### 2. メモリ効率が重要な場合
- メモリが断片化している環境
- 大きなデータを扱う場合

### 3. スタック・キューの実装
- スタックやキューの内部実装
- LIFO/FIFOの操作

### 4. グラフの表現
- 隣接リストとしてグラフを表現
- スパースグラフに適している

### 5. 多項式の表現
- 多項式の項をノードとして表現
- 多項式の演算

## 現実世界での応用例

### 1. メモリ管理
- **例**: OSのメモリアロケーターで、空きメモリブロックを管理
- **実装**: 空きメモリブロックをリンクリストで管理
- **メリット**: 動的なメモリ割り当てが可能

### 2. ファイルシステム
- **例**: ファイルシステムで、ファイルのブロックを管理
- **実装**: ファイルのブロックをリンクリストで管理
- **メリット**: 断片化したファイルを効率的に管理

### 3. ブラウザの履歴
- **例**: ブラウザの戻る/進む機能
- **実装**: 訪問履歴を双方向リンクリストで管理
- **メリット**: 効率的な履歴管理

### 4. 音楽プレイヤー
- **例**: 音楽プレイヤーのプレイリスト
- **実装**: 曲をリンクリストで管理
- **メリット**: 効率的なプレイリスト管理

### 5. テキストエディタ
- **例**: テキストエディタの行の管理
- **実装**: 各行をリンクリストで管理
- **メリット**: 効率的なテキスト編集

### 6. キャッシュシステム
- **例**: LRUキャッシュの実装
- **実装**: アクセス順序を双方向リンクリストで管理
- **メリット**: 効率的なキャッシュ管理

## 実装時の注意点

### 1. ポインタの管理
- **問題**: ポインタを適切に更新しないと、リンクが切れる
- **解決策**: 操作の順序を慎重に設計
- **実装**: 一時変数を使用してポインタを保存
- **注意**: ポインタを失うと、メモリリークが発生

### 2. エッジケースの処理
- **問題**: 空のリスト、1つの要素のみ、先頭・末尾の処理
- **解決策**: 各操作でエッジケースをチェック
- **実装**: `if head is None:`などのチェック
- **注意**: エッジケースを忘れると、エラーが発生

### 3. ダミーノードの使用
- **問題**: 先頭・末尾の処理が複雑になる場合がある
- **解決策**: ダミーノードを使用して、エッジケースを簡潔に処理
- **実装**: `dummy = ListNode(0)`で開始
- **メリット**: コードが簡潔になる

### 4. サイクルの検出
- **問題**: リンクリストにサイクルがあるか判定
- **解決策**: フロイドの循環検出アルゴリズム（ウサギとカメ）
- **実装**: 2つのポインタを異なる速度で移動
- **メリット**: O(1)空間でサイクルを検出

### 5. 再帰の使用
- **問題**: リンクリストの問題で再帰が有効な場合がある
- **解決策**: 再帰を使って、コードを簡潔に
- **実装**: 再帰的にノードを処理
- **注意**: 深い再帰はスタックオーバーフローのリスク

### 6. 反復的実装
- **問題**: 再帰の代わりに反復的実装を使用
- **解決策**: ループを使ってノードを処理
- **実装**: `while current:`でループ
- **メリット**: スタックオーバーフローのリスクがない

## 関連するLeetCode/AtCoder問題

### Easy
- [Reverse Linked List](./reverse_linked_list_logic.md) - リンクリストの基本操作
- [Merge Two Sorted Lists](./merge_two_sorted_lists_logic.md) - マージ操作

### Medium
- [Detect Cycle](./detect_cycle_logic.md) - サイクルの検出
- [Remove Nth Node From End](./remove_nth_node_logic.md) - 2つのポインタ

### Hard
- [Merge K Sorted Lists](../17_heap/merge_k_sorted_lists_logic.md) - ヒープとの組み合わせ
- [Reverse Nodes in k-Group](../leetcode/hard/) - 複雑な反転操作

## 学習の進め方

1. **Reverse Linked List**から始める: リンクリストの最も基本的な操作
2. **Merge Two Sorted Lists**でマージ操作を学ぶ: 2つのリストの統合
3. **Detect Cycle**でサイクル検出を学ぶ: 2つのポインタテクニック
4. **より複雑な問題**に挑戦: 他のテクニックと組み合わせた使用法を学ぶ

## 次のステップ

- [Reverse Linked List のロジック解説](./reverse_linked_list_logic.md)
- [Merge Two Sorted Lists のロジック解説](./merge_two_sorted_lists_logic.md)
- [二ポインタテクニック](../02_two_pointers/README.md) - リンクリストと組み合わせて使用

---

**重要**: リンクリストは、動的なデータ構造として多くのアルゴリズムの基礎となります。ポインタの操作を正確に理解することが重要です。

