# Detect Cycle in Linked List - ロジック解説

## 問題概要

リンクリストにサイクルがあるか判定する。

**制約**:
- リンクリストのノード数は0以上10^4以下

**例**:
```
Input: head = [3,2,0,-4], pos = 1（posはサイクルの開始位置）
Output: true
説明: ノード2からサイクルが開始
```

## ロジックの核心

### なぜフロイドの循環検出が有効か？

**ハッシュセットアプローチ（O(n)空間）**:
- 訪問済みノードをセットに保存
- 空間計算量: O(n) - 全てのノードを保存

**フロイドの循環検出（ウサギとカメ）を使う理由**:
- **O(1)空間**: 追加のメモリを使用せずにサイクルを検出
- **時間計算量**: O(n) - 1回の走査で完了
- **空間計算量**: O(1) - 定数空間のみ使用

### 思考プロセス

1. **2つのポインタ**: `slow`（1ステップ）と`fast`（2ステップ）
2. **サイクルの検出**: `slow == fast`ならサイクルが存在
3. **サイクルがない場合**: `fast`がNoneに到達

### アルゴリズムのステップ

```
function hasCycle(head):
    if not head or not head.next:
        return False
    
    slow = head
    fast = head.next
    
    while fast and fast.next:
        if slow == fast:
            return True
        slow = slow.next
        fast = fast.next.next
    
    return False
```

## 具体例でのトレース

### 例: `3 -> 2 -> 0 -> -4 -> 2（サイクル）`

```
初期状態:
  slow = 3
  fast = 2

ステップ1:
  slow = 2, fast = 0
  2 != 0 → 続行

ステップ2:
  slow = 0, fast = 2
  0 != 2 → 続行

ステップ3:
  slow = -4, fast = -4
  -4 == -4 → サイクルが検出された ✓

結果: true
```

## 現実世界での応用

### 1. メモリリークの検出
- **シナリオ**: プログラムで、循環参照によるメモリリークを検出
- **実装**: オブジェクトの参照をリンクリストとして扱い、サイクルを検出
- **メリット**: メモリリークの早期発見

### 2. ネットワークのルーティング
- **シナリオ**: ネットワークで、ルーティングループを検出
- **実装**: ルーティングパスをリンクリストとして扱い、サイクルを検出
- **メリット**: ネットワークの障害検出

### 3. 状態マシン
- **シナリオ**: 状態マシンで、無限ループを検出
- **実装**: 状態遷移をリンクリストとして扱い、サイクルを検出
- **メリット**: 無限ループの早期発見

### 4. ゲーム開発
- **シナリオ**: ゲームで、AIの行動パターンにサイクルがあるか検出
- **実装**: AIの行動をリンクリストとして扱い、サイクルを検出
- **メリット**: ゲームのバランス調整

### 5. データベースの整合性チェック
- **シナリオ**: データベースで、循環参照を検出
- **実装**: 参照関係をリンクリストとして扱い、サイクルを検出
- **メリット**: データの整合性を保証

### 6. コンパイラの最適化
- **シナリオ**: コンパイラで、コードの最適化ループを検出
- **実装**: 最適化パスをリンクリストとして扱い、サイクルを検出
- **メリット**: 無限最適化の防止

## 注意点と落とし穴

### 1. 初期状態のチェック
- **問題**: 空のリストや1つのノードのみの場合の処理
- **解決策**: `if not head or not head.next: return False`
- **実装**: サイクルが存在するには少なくとも2つのノードが必要
- **注意**: エッジケースの処理が重要

### 2. ポインタの初期化
- **問題**: `slow`と`fast`の初期位置が重要
- **解決策**: `slow = head`, `fast = head.next`で開始
- **実装**: 異なる位置から開始することで、最初のステップで一致しない
- **注意**: 両方とも`head`から開始すると、最初のステップで一致してしまう

### 3. 高速ポインタの移動
- **問題**: `fast`を2ステップ進める際、`fast.next`がNoneでないか確認
- **解決策**: `while fast and fast.next:`でチェック
- **実装**: Noneチェックを忘れると、エラーが発生
- **注意**: エラーハンドリングが重要

### 4. 時間計算量の理解
- **平均**: O(n) - サイクルがある場合、O(n)で検出
- **最悪**: O(n) - 常に線形時間
- **空間**: O(1) - 定数空間のみ使用
- **メリット**: ハッシュセットより空間効率が良い

### 5. サイクルの開始位置
- **問題**: サイクルの開始位置を見つける必要がある場合
- **解決策**: サイクル検出後、`slow`を`head`に戻し、1ステップずつ進める
- **実装**: `slow = head`として、`slow == fast`になるまで進める
- **注意**: この問題では開始位置は不要

### 6. フロイドの循環検出の証明
- **問題**: なぜこのアルゴリズムが動作するのか？
- **解決策**: 数学的に証明可能（ウサギとカメの比が2:1）
- **実装**: サイクルがある場合、必ず`slow`と`fast`が一致する
- **注意**: アルゴリズムの理解が重要

### 7. サイクルの長さ
- **問題**: サイクルの長さを求める必要がある場合
- **解決策**: サイクル検出後、1つのポインタを固定し、もう1つを1ステップずつ進める
- **実装**: 一致するまでのステップ数がサイクルの長さ
- **注意**: この問題ではサイクルの長さは不要

### 8. 複数のサイクル
- **問題**: 複数のサイクルが存在する場合の処理
- **解決策**: このアルゴリズムは1つのサイクルのみを検出
- **実装**: 通常は1つのサイクルのみを考慮
- **注意**: 複数のサイクルがある場合は、別のアプローチが必要

## 関連問題

- [Linked List Cycle II](../leetcode/medium/) - サイクルの開始位置を見つける
- [Find the Duplicate Number](../leetcode/medium/) - サイクル検出の応用
- [Reverse Linked List](./reverse_linked_list_logic.md) - リンクリストの基本操作
- [Remove Nth Node From End](./remove_nth_node_logic.md) - 2つのポインタ

---

**次のステップ**: [Remove Nth Node From End](./remove_nth_node_logic.md)で2つのポインタテクニックを学ぶ

