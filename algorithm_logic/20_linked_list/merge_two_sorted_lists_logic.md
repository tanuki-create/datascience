# Merge Two Sorted Lists - ロジック解説

## 問題概要

2つのソート済みリンクリストを1つのソート済みリンクリストにマージする。

**制約**:
- 両方のリストはソート済み

**例**:
```
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
```

## ロジックの核心

### なぜ2つのポインタが有効か？

**全要素を配列に集めてソート（O(n log n)）**:
- 全ての要素を配列に集めてソート
- 時間計算量: O(n log n) - 非効率

**2つのポインタを使う理由**:
- **ソート済みの活用**: 2つのリストが既にソート済みであることを利用
- **時間計算量**: O(n + m) - nとmは各リストの長さ
- **空間計算量**: O(1) - 新しいノードを作成する場合を除く

### 思考プロセス

1. **ダミーノード**: 結果リストの構築を簡潔にする
2. **2つのポインタ**: 各リストの現在のノードを追跡
3. **小さい方を選択**: 2つのノードのうち小さい方を結果に追加
4. **ポインタの移動**: 選択したリストのポインタを進める

### アルゴリズムのステップ

```
function mergeTwoLists(list1, list2):
    dummy = ListNode(0)
    current = dummy
    
    while list1 and list2:
        if list1.val <= list2.val:
            current.next = list1
            list1 = list1.next
        else:
            current.next = list2
            list2 = list2.next
        current = current.next
    
    // 残りのノードを追加
    current.next = list1 if list1 else list2
    
    return dummy.next
```

## 具体例でのトレース

### 例: `list1 = [1,2,4], list2 = [1,3,4]`

```
初期状態:
  dummy -> None
  current = dummy
  list1 = 1 -> 2 -> 4
  list2 = 1 -> 3 -> 4

ステップ1: list1.val(1) <= list2.val(1)
  current.next = 1 -> 2 -> 4
  list1 = 2 -> 4
  current = 1 -> 2 -> 4

ステップ2: list2.val(1) < list1.val(2)
  current.next = 1 -> 3 -> 4
  list2 = 3 -> 4
  current = 1 -> 1 -> 3 -> 4

ステップ3: list1.val(2) < list2.val(3)
  current.next = 2 -> 4
  list1 = 4
  current = 1 -> 1 -> 2 -> 4

ステップ4: list2.val(3) < list1.val(4)
  current.next = 3 -> 4
  list2 = 4
  current = 1 -> 1 -> 2 -> 3 -> 4

ステップ5: list1.val(4) <= list2.val(4)
  current.next = 4
  list1 = None
  current = 1 -> 1 -> 2 -> 3 -> 4 -> 4

残り: list2 = 4
  current.next = 4

結果: 1 -> 1 -> 2 -> 3 -> 4 -> 4
```

## 現実世界での応用

### 1. マージソートの実装
- **シナリオ**: マージソートで、2つのソート済みリストをマージ
- **実装**: 2つのポインタを使って効率的にマージ
- **メリット**: マージソートの核心部分

### 2. データベースのクエリ結果のマージ
- **シナリオ**: 複数のクエリ結果を時系列順にマージ
- **実装**: 2つのポインタを使って効率的にマージ
- **メリット**: 効率的なデータ統合

### 3. ログファイルのマージ
- **シナリオ**: 複数のサーバーのログファイルを時系列順にマージ
- **実装**: 2つのポインタを使って効率的にマージ
- **メリット**: 時系列順のログ分析

### 4. ストリーミングデータのマージ
- **シナリオ**: 複数のストリームからデータを時系列順にマージ
- **実装**: 2つのポインタを使って効率的にマージ
- **メリット**: 効率的なストリーム処理

### 5. バージョン管理システム
- **シナリオ**: 複数のブランチの変更履歴を時系列順にマージ
- **実装**: 2つのポインタを使って効率的にマージ
- **メリット**: 効率的なバージョン管理

### 6. 分散システムのデータ統合
- **シナリオ**: 複数のノードからデータを収集し、時系列順にマージ
- **実装**: 2つのポインタを使って効率的にマージ
- **メリット**: 効率的なデータ統合

## 注意点と落とし穴

### 1. ダミーノードの使用
- **問題**: 結果リストの構築を簡潔にする
- **解決策**: ダミーノードを使用して、エッジケースを簡潔に処理
- **実装**: `dummy = ListNode(0)`で開始
- **メリット**: コードが簡潔になる

### 2. 残りのノードの処理
- **問題**: 1つのリストが終了した後、もう1つのリストの残りを追加
- **解決策**: `current.next = list1 if list1 else list2`で追加
- **実装**: 残りのノードをそのまま接続
- **注意**: 残りを追加するのを忘れると、結果が不完全になる

### 3. 等しい値の扱い
- **問題**: 2つのノードの値が等しい場合、どちらを先に追加するか
- **解決策**: 通常は`list1`を優先（安定ソート）
- **実装**: `if list1.val <= list2.val:`で等号を含める
- **注意**: 問題の要件を確認する必要がある

### 4. 時間計算量の理解
- **平均**: O(n + m) - 各ノードを1回ずつ処理
- **最悪**: O(n + m) - 常に線形時間
- **空間**: O(1) - 新しいノードを作成する場合を除く
- **メリット**: O(n log n)からO(n + m)に改善

### 5. 空のリストの処理
- **問題**: 1つまたは両方のリストが空の場合の処理
- **解決策**: ループが実行されず、残りのノードがそのまま返される
- **実装**: `current.next = list1 if list1 else list2`で自動的に処理
- **注意**: エッジケースの処理が重要

### 6. ポインタの移動
- **問題**: ノードを追加した後、ポインタを適切に移動する必要がある
- **解決策**: `current = current.next`でcurrentを進める
- **実装**: ノードを追加した後、必ずcurrentを進める
- **注意**: 移動を忘れると、無限ループが発生

### 7. 新しいノードの作成
- **問題**: 新しいノードを作成する必要があるか？
- **解決策**: 通常は既存のノードを再利用（インプレース）
- **実装**: `current.next = list1`で既存のノードを接続
- **メリット**: メモリ効率が良い

### 8. 再帰的実装
- **問題**: 再帰的実装も可能
- **解決策**: 再帰的にマージ
- **実装**: `mergeTwoLists(list1.next, list2)`など
- **注意**: 再帰の深さに注意が必要

## 関連問題

- [Merge K Sorted Lists](../17_heap/merge_k_sorted_lists_logic.md) - k個のリストのマージ
- [Sort List](../leetcode/medium/) - リンクリストのソート
- [Add Two Numbers](../leetcode/medium/) - 2つの数値の加算
- [Reverse Linked List](./reverse_linked_list_logic.md) - リンクリストの反転

---

**次のステップ**: [Detect Cycle](./detect_cycle_logic.md)でサイクル検出を学ぶ

