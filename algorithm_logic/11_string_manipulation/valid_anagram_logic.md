# Valid Anagram - ロジック解説

## 問題概要

2つの文字列`s`と`t`が与えられたとき、`t`が`s`のアナグラムかどうかを判定する。

**例**:
```
Input: s = "anagram", t = "nagaram"
Output: true
```

## ロジックの核心

### なぜハッシュマップが有効か？

**ソート（O(n log n)）**:
- 両方の文字列をソートして比較
- 時間計算量: O(n log n) - ソートのコスト

**ハッシュマップを使う理由**:
- **文字のカウント**: 各文字の出現回数をカウント
- **時間計算量**: O(n) - 線形時間
- **空間計算量**: O(1) - 固定サイズの配列（26文字）

### アルゴリズムのステップ

```
function isAnagram(s, t):
    if len(s) != len(t):
        return False
    
    count = [0] * 26
    
    for char in s:
        count[ord(char) - ord('a')] += 1
    
    for char in t:
        count[ord(char) - ord('a')] -= 1
        if count[ord(char) - ord('a')] < 0:
            return False
    
    return True
```

## 現実世界での応用

### 1. スペルチェッカー
- **シナリオ**: スペルチェッカーで、アナグラムを検出
- **実装**: 文字のカウントでアナグラムを検出
- **メリット**: 効率的なスペルチェック

### 2. 暗号化
- **シナリオ**: 暗号化で、文字の並び替えを検出
- **実装**: 文字のカウントで並び替えを検出
- **メリット**: 効率的な暗号解析

### 3. データ分析
- **シナリオ**: データ分析で、文字列の類似性を計算
- **実装**: 文字のカウントで類似性を計算
- **メリット**: 効率的なデータ分析

## 注意点と落とし穴

### 1. 長さの一致
- **問題**: 長さが異なる場合はアナグラムではない
- **解決策**: 最初に長さをチェック
- **注意**: 長さチェックを忘れると、誤った結果が返される

### 2. 文字のカウント
- **問題**: 各文字の出現回数を正確にカウントする必要がある
- **解決策**: 配列で各文字の出現回数をカウント
- **注意**: カウントの管理が重要

## 関連問題

- [Group Anagrams](../01_hash_table/group_anagrams_logic.md) - アナグラムのグループ化
- [Find All Anagrams in a String](../leetcode/medium/) - アナグラムの検索

---

**次のステップ**: [Reverse Words in a String](./reverse_words_logic.md)で単語の反転を学ぶ

