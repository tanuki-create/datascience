# Longest Common Prefix - ロジック解説

## 問題概要

文字列の配列が与えられたとき、全ての文字列に共通する最長のプレフィックスを返す。

**例**:
```
Input: strs = ["flower","flow","flight"]
Output: "fl"
```

## ロジックの核心

### なぜ縦方向スキャンが有効か？

**全比較（O(n×m)）**:
- 全ての文字列を比較する
- 時間計算量: O(n×m) - nは文字列数、mは平均長

**縦方向スキャンを使う理由**:
- **文字ごとの比較**: 各位置の文字を比較して、共通する最長のプレフィックスを見つける
- **早期終了**: 1つでも異なる文字があれば終了
- **時間計算量**: O(n×m)だが、実際は早期終了で高速

### 思考プロセス

1. **最初の文字列を基準**: 最初の文字列を基準として使用
2. **文字ごとに比較**: 各位置の文字が全ての文字列で同じか確認
3. **共通部分を構築**: 共通する文字を順に追加
4. **早期終了**: 異なる文字が見つかったら終了

### アルゴリズムのステップ

```
1. 空の配列の場合は "" を返す
2. 最初の文字列を基準として使用
3. i = 0 から最初の文字列の長さまで:
   a. 基準文字列のi番目の文字を取得
   b. 他の全ての文字列でi番目の文字が同じか確認
   c. 異なる文字があれば、i-1番目までを返す
   d. 全て同じなら続行
4. 最初の文字列全体が共通プレフィックス
```

## 具体例でのトレース

### 例: `strs = ["flower","flow","flight"]`

| i | 基準文字 | 比較 | 結果 |
|---|---------|------|------|
| 0 | 'f' | 'f'=='f'=='f' | ✓ 続行 |
| 1 | 'l' | 'l'=='l'=='l' | ✓ 続行 |
| 2 | 'o' | 'o'=='o'≠'i' | ✗ 終了 |

**結果**: `"fl"`

## 現実世界での応用

### 1. ファイルシステムのパス処理
- **シナリオ**: 複数のファイルパスの共通部分を見つける
- **実装**: 同様のアルゴリズムで共通パスを計算
- **例**: 複数のファイルの共通ディレクトリを見つける
- **メリット**: ファイルの整理やバックアップの効率化に使用

### 2. データベースのインデックス最適化
- **シナリオ**: 複数のキーの共通プレフィックスを見つける
- **実装**: インデックスの最適化に使用
- **例**: B-treeインデックスで、共通プレフィックスを圧縮してメモリを節約
- **メリット**: データベースのパフォーマンス向上

### 3. ネットワークルーティング（CIDR）
- **シナリオ**: IPアドレスの共通プレフィックスを見つける
- **実装**: ルーティングテーブルの最適化に使用
- **例**: CIDR（Classless Inter-Domain Routing）で、IPアドレスの共通プレフィックスを計算
- **メリット**: ルーティングテーブルのサイズを削減

### 4. テキストエディタの自動補完
- **シナリオ**: 複数の候補から共通プレフィックスを見つける
- **実装**: 候補文字列の共通プレフィックスを計算
- **例**: IDEの自動補完で、複数の候補から共通部分を表示
- **メリット**: ユーザーの入力効率を向上

### 5. DNA配列解析
- **シナリオ**: 複数のDNA配列の共通プレフィックスを見つける
- **実装**: DNA配列の共通部分を計算
- **例**: 遺伝子解析で、複数の配列の共通部分を特定
- **メリット**: 遺伝子の相同性解析に使用

### 6. バージョン管理システム
- **シナリオ**: 複数のブランチ名の共通プレフィックスを見つける
- **実装**: ブランチ名の共通部分を計算
- **例**: Gitで、複数のブランチ名から共通の命名規則を抽出
- **メリット**: ブランチの整理と管理に使用

## 注意点と落とし穴

### 1. 空の配列の処理
- **問題**: 空の配列の場合は空文字列を返す必要がある
- **解決策**: 最初に`if not strs: return ""`をチェック
- **注意**: 空の配列を処理しないと、インデックスエラーが発生する

### 2. 文字列の長さの制限
- **問題**: 最短の文字列を超えないように注意が必要
- **解決策**: 各位置で、全ての文字列がその位置に文字を持つか確認
- **実装**: 
  ```
  if i >= len(strs[j]) or strs[j][i] != char:
      return strs[0][:i]
  ```
- **注意**: 最短の文字列を事前に確認する方法もあるが、早期終了の方が効率的

### 3. 大文字小文字の扱い
- **問題**: 問題によっては大文字小文字を区別する必要がある
- **解決策**: 問題文に従って、必要に応じて小文字に変換
- **実装**: `char.lower()`で統一
- **注意**: 通常は大文字小文字を区別するが、問題によって異なる

### 4. Unicode文字の扱い
- **問題**: Unicode文字（日本語など）が含まれる場合の処理
- **解決策**: 文字列のインデックスアクセスはUnicode文字にも対応
- **注意**: 絵文字や結合文字の場合は、文字の境界が複雑になる可能性がある

### 5. 時間計算量の理解
- **最悪**: O(n×m) - nは文字列数、mは最短の文字列の長さ
- **平均**: 早期終了により、実際はより高速
- **空間**: O(1) - 追加の空間は定数（結果文字列を除く）
- **最適化**: 最短の文字列を見つけて、その長さまでしかチェックしない方法もある

### 6. 代替アプローチとの比較
- **水平スキャン**: 2つの文字列を順次比較（O(n×m)）
- **縦方向スキャン**: 各位置の文字を比較（O(n×m)だが早期終了で高速）
- **二分探索**: 共通プレフィックスの長さを二分探索（O(n×m×log m)）
- **Trie**: Trie木を構築して共通プレフィックスを検索（O(n×m)）
- **推奨**: 通常は縦方向スキャンが最もシンプルで効率的

## 関連問題

- Longest Common Subsequence
- Implement Trie
- Word Search

---

**次のステップ**: [文字列処理のREADME](./README.md)に戻る

