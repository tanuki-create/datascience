# Longest Common Prefix - ロジック解説

## 問題概要

文字列の配列が与えられたとき、全ての文字列に共通する最長のプレフィックスを返す。

**例**:
```
Input: strs = ["flower","flow","flight"]
Output: "fl"
```

## ロジックの核心

### なぜ縦方向スキャンが有効か？

**全比較（O(n×m)）**:
- 全ての文字列を比較する
- 時間計算量: O(n×m) - nは文字列数、mは平均長

**縦方向スキャンを使う理由**:
- **文字ごとの比較**: 各位置の文字を比較して、共通する最長のプレフィックスを見つける
- **早期終了**: 1つでも異なる文字があれば終了
- **時間計算量**: O(n×m)だが、実際は早期終了で高速

### 思考プロセス

1. **最初の文字列を基準**: 最初の文字列を基準として使用
2. **文字ごとに比較**: 各位置の文字が全ての文字列で同じか確認
3. **共通部分を構築**: 共通する文字を順に追加
4. **早期終了**: 異なる文字が見つかったら終了

### アルゴリズムのステップ

```
1. 空の配列の場合は "" を返す
2. 最初の文字列を基準として使用
3. i = 0 から最初の文字列の長さまで:
   a. 基準文字列のi番目の文字を取得
   b. 他の全ての文字列でi番目の文字が同じか確認
   c. 異なる文字があれば、i-1番目までを返す
   d. 全て同じなら続行
4. 最初の文字列全体が共通プレフィックス
```

## 具体例でのトレース

### 例: `strs = ["flower","flow","flight"]`

| i | 基準文字 | 比較 | 結果 |
|---|---------|------|------|
| 0 | 'f' | 'f'=='f'=='f' | ✓ 続行 |
| 1 | 'l' | 'l'=='l'=='l' | ✓ 続行 |
| 2 | 'o' | 'o'=='o'≠'i' | ✗ 終了 |

**結果**: `"fl"`

## 現実世界での応用

### 1. ファイルシステム
- **シナリオ**: 複数のファイルパスの共通部分を見つける
- **実装**: 同様のアルゴリズムで共通パスを計算

### 2. データベース
- **シナリオ**: 複数のキーの共通プレフィックスを見つける
- **実装**: インデックスの最適化に使用

### 3. ネットワークルーティング
- **シナリオ**: IPアドレスの共通プレフィックスを見つける
- **実装**: ルーティングテーブルの最適化に使用

## 注意点と落とし穴

1. **空の配列**: 空の配列の場合は空文字列を返す
2. **文字列の長さ**: 最短の文字列を超えないように注意
3. **大文字小文字**: 問題によっては大文字小文字を区別する必要がある

## 関連問題

- Longest Common Subsequence
- Implement Trie
- Word Search

---

**次のステップ**: [文字列処理のREADME](./README.md)に戻る

