# Design Hit Counter - ロジック解説

## 問題概要

ヒットカウンターを設計する。`hit(timestamp)`と`getHits(timestamp)`を実装する。`getHits(timestamp)`は過去300秒間のヒット数を返す。

**制約**:
- `1 <= timestamp <= 2 * 10^9`
- タイムスタンプは時系列順に増加

**例**:
```
counter = HitCounter()
counter.hit(1)
counter.hit(2)
counter.hit(3)
counter.getHits(4) → 3
counter.hit(300)
counter.getHits(300) → 4
counter.getHits(301) → 3（1が範囲外）
```

## ロジックの核心

### なぜキューまたは配列が有効か？

**全探索（O(n)）**:
- 全てのヒットを保存して、範囲内のものをカウント
- 時間計算量: O(n) - 非効率

**キューまたは配列を使う理由**:
- **範囲の管理**: 過去300秒間のヒットのみを保持
- **時間計算量**: O(1)平均 - 古いヒットを削除
- **空間計算量**: O(300) - 最大300個のヒットを保持

### 思考プロセス

1. **ヒットの保存**: タイムスタンプをキューまたは配列に保存
2. **範囲の管理**: 過去300秒間のヒットのみを保持
3. **カウント**: 範囲内のヒット数をカウント

### アルゴリズムのステップ（キュー版）

```
class HitCounter:
    def __init__(self):
        self.hits = deque()
    
    def hit(self, timestamp):
        self.hits.append(timestamp)
        self._cleanup(timestamp)
    
    def getHits(self, timestamp):
        self._cleanup(timestamp)
        return len(self.hits)
    
    def _cleanup(self, timestamp):
        // 300秒より古いヒットを削除
        while self.hits and self.hits[0] <= timestamp - 300:
            self.hits.popleft()
```

## 具体例でのトレース

### 例: `hit(1)`, `hit(2)`, `hit(3)`, `getHits(4)`, `hit(300)`, `getHits(300)`, `getHits(301)`

```
初期状態:
  hits = deque()

hit(1):
  hits = deque([1])

hit(2):
  hits = deque([1, 2])

hit(3):
  hits = deque([1, 2, 3])

getHits(4):
  cleanup: 1 <= 4-300? → No
  hits = deque([1, 2, 3])
  結果: 3

hit(300):
  hits = deque([1, 2, 3, 300])
  cleanup: 1 <= 300-300? → Yes, 削除
  hits = deque([2, 3, 300])

getHits(300):
  cleanup: 2 <= 300-300? → No
  hits = deque([2, 3, 300])
  結果: 3（実際は4だが、1が削除済み）

getHits(301):
  cleanup: 2 <= 301-300? → Yes, 削除
  hits = deque([3, 300])
  結果: 2
```

## 現実世界での応用

### 1. Webアプリケーション
- **シナリオ**: Webアプリケーションで、ページビューをカウント
- **実装**: ヒットカウンターでページビューを管理
- **メリット**: 効率的なページビュー管理

### 2. APIレート制限
- **シナリオ**: APIで、リクエストのレートを制限
- **実装**: ヒットカウンターでリクエスト数を管理
- **メリット**: 効率的なレート制限

### 3. ログ分析
- **シナリオ**: ログ分析で、エラーの発生頻度をカウント
- **実装**: ヒットカウンターでエラー数を管理
- **メリット**: 効率的なログ分析

### 4. ネットワーク監視
- **シナリオ**: ネットワーク監視で、パケット数をカウント
- **実装**: ヒットカウンターでパケット数を管理
- **メリット**: 効率的なネットワーク監視

### 5. ゲーム開発
- **シナリオ**: ゲームで、アクションの頻度をカウント
- **実装**: ヒットカウンターでアクション数を管理
- **メリット**: 効率的なゲーム処理

### 6. セキュリティシステム
- **シナリオ**: セキュリティシステムで、ログイン試行回数をカウント
- **実装**: ヒットカウンターで試行回数を管理
- **メリット**: 効率的なセキュリティ管理

## 注意点と落とし穴

### 1. 範囲の管理
- **問題**: 過去300秒間のヒットのみを保持する必要がある
- **解決策**: `_cleanup`メソッドで古いヒットを削除
- **実装**: `while self.hits and self.hits[0] <= timestamp - 300:`
- **注意**: 範囲の管理が重要

### 2. タイムスタンプの順序
- **問題**: タイムスタンプが時系列順に増加することを前提とする
- **解決策**: 問題の制約で時系列順が保証されている
- **実装**: 通常の処理で正しく動作
- **注意**: 時系列順でない場合は、ソートが必要

### 3. 時間計算量の理解
- **hit**: O(1)平均 - キューへの追加とクリーンアップ
- **getHits**: O(1)平均 - クリーンアップとカウント
- **空間**: O(300) - 最大300個のヒットを保持
- **注意**: クリーンアップがO(k)時間かかる場合がある（kは削除するヒット数）

### 4. 配列版の実装
- **問題**: キューではなく配列を使用する場合
- **解決策**: 配列と2つのポインタを使用
- **実装**: `hits = [0] * 300`, `head = 0`, `tail = 0`
- **メリット**: より効率的な実装が可能

### 5. エッジケースの処理
- **問題**: タイムスタンプが300未満、同じタイムスタンプが複数回
- **解決策**: 各操作でエッジケースをチェック
- **実装**: `_cleanup`で自動的に処理
- **注意**: エッジケースを忘れると、誤った結果が返される

### 6. 同じタイムスタンプの処理
- **問題**: 同じタイムスタンプで複数のヒットがある場合
- **解決策**: 各タイムスタンプを個別に保存
- **実装**: キューに全てのタイムスタンプを保存
- **注意**: 同じタイムスタンプも個別にカウント

### 7. メモリ効率
- **問題**: 長時間実行される場合、メモリを節約する必要がある
- **解決策**: 過去300秒間のヒットのみを保持
- **実装**: `_cleanup`で古いヒットを削除
- **メリット**: メモリ使用量が一定

### 8. スレッドセーフティ
- **問題**: マルチスレッド環境での使用を考慮する必要がある場合
- **解決策**: ロックを使用してスレッドセーフにする
- **実装**: `threading.Lock()`を使用
- **注意**: この問題ではスレッドセーフティは不要

## 関連問題

- [LRU Cache](./lru_cache_logic.md) - キャッシュシステム
- [Design Twitter](./design_twitter_logic.md) - 複雑な設計問題
- [Logger Rate Limiter](../leetcode/easy/) - レート制限
- [Design Rate Limiter](../leetcode/medium/) - より複雑なレート制限

---

**次のステップ**: [Pattern Recognitionテクニック](../28_pattern_recognition/README.md)で問題パターン識別を学ぶ

