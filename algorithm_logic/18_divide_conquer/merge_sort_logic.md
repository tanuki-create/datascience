# Merge Sort - ロジック解説

## 問題概要

配列をマージソートでソートする。マージソートは分割統治法を使用した安定ソートアルゴリズム。

**制約**:
- 配列の要素数は任意

**例**:
```
Input: [38, 27, 43, 3, 9, 82, 10]
Output: [3, 9, 10, 27, 38, 43, 82]
```

## ロジックの核心

### なぜ分割統治法が有効か？

**バブルソート（O(n²)）**:
- 全ての要素を比較してソート
- 時間計算量: O(n²) - 非効率

**分割統治法を使う理由**:
- **問題の分割**: 配列を2つに分割し、それぞれをソート
- **統合**: ソート済みの2つの配列をマージ（O(n)）
- **時間計算量**: O(n log n) - 効率的で安定ソート

### 思考プロセス

1. **分割**: 配列を2つに分割（中央で分割）
2. **統治**: それぞれの部分配列を再帰的にソート
3. **統合**: ソート済みの2つの配列をマージ

### アルゴリズムのステップ

```
function mergeSort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = mergeSort(arr[:mid])
    right = mergeSort(arr[mid:])
    
    return merge(left, right)

function merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

## 具体例でのトレース

### 例: `arr = [38, 27, 43, 3]`

```
分割:
  [38, 27, 43, 3]
    /         \
[38, 27]    [43, 3]
  /  \        /  \
[38] [27]  [43] [3]

統合:
[38] [27] → [27, 38]
[43] [3] → [3, 43]
[27, 38] [3, 43] → [3, 27, 38, 43]

結果: [3, 27, 38, 43]
```

## 現実世界での応用

### 1. 大規模データのソート
- **シナリオ**: データベースのクエリ結果のソート
- **実装**: マージソートで安定ソートを実現
- **メリット**: 最悪時間計算量が保証される

### 2. 外部ソート
- **シナリオ**: メモリに収まらない大規模データのソート
- **実装**: データを分割し、それぞれをソートしてマージ
- **メリット**: メモリ効率的なソート

### 3. 並列処理
- **シナリオ**: 複数のプロセッサで並列にソート
- **実装**: 各部分配列を別のプロセッサでソート
- **メリット**: 並列処理による高速化

### 4. 安定ソートが必要な場合
- **シナリオ**: 複数のキーでソートする際、最初のキーの順序を保持
- **実装**: マージソートは安定ソート
- **メリット**: 複数キーでのソートが可能

### 5. リンクリストのソート
- **シナリオ**: リンクリストをソートする場合
- **実装**: マージソートはリンクリストに適している
- **メリット**: インプレースソートが可能

### 6. 逆序数のカウント
- **シナリオ**: 配列の逆序数をカウント
- **実装**: マージソートの過程で逆序数をカウント
- **メリット**: O(n log n)で逆序数をカウント

## 注意点と落とし穴

### 1. ベースケースの処理
- **問題**: 配列のサイズが1以下の場合、そのまま返す
- **解決策**: `if len(arr) <= 1: return arr`
- **注意**: ベースケースを忘れると無限再帰が発生

### 2. マージ操作の実装
- **問題**: 2つのソート済み配列を効率的にマージ
- **解決策**: 2つのポインタを使用して、小さい方を選択
- **実装**: `while i < len(left) and j < len(right):`
- **注意**: 残りの要素も追加する必要がある

### 3. 安定ソートの保証
- **問題**: 同じ値の要素の順序を保持する必要がある
- **解決策**: `left[i] <= right[j]`で、左側を優先
- **実装**: 等号を含めることで安定ソートを保証
- **注意**: 等号を忘れると安定ソートにならない

### 4. 時間計算量の理解
- **平均**: O(n log n) - 常に同じ時間計算量
- **最悪**: O(n log n) - 最悪時間計算量が保証される
- **空間**: O(n) - マージ用の補助配列
- **注意**: クイックソートより空間計算量が大きい

### 5. 再帰の深さ
- **問題**: 深い再帰はスタックオーバーフローを引き起こす可能性がある
- **解決策**: 反復的実装を使用、または再帰の深さを制限
- **実装**: スタックを使った反復的実装
- **注意**: Pythonのデフォルト再帰制限は1000程度

### 6. メモリ使用量
- **問題**: マージ用の補助配列が必要
- **解決策**: 各再帰レベルでO(n)のメモリが必要
- **実装**: 補助配列を作成してマージ
- **注意**: メモリ制約がある場合、インプレースソートを検討

### 7. 小さい配列の処理
- **問題**: 小さい配列では、挿入ソートの方が高速な場合がある
- **解決策**: 配列のサイズが閾値以下の場合、挿入ソートを使用
- **実装**: `if len(arr) <= THRESHOLD: return insertionSort(arr)`
- **メリット**: 実用的な実行時間を改善

### 8. リンクリストへの適用
- **問題**: リンクリストをソートする場合、マージソートが適している
- **解決策**: リンクリストを2つに分割し、マージ
- **実装**: ポインタ操作で分割とマージを実現
- **メリット**: インプレースソートが可能

## 関連問題

- [Quick Sort](./quick_sort_logic.md) - インプレースソート
- [Sort List](../leetcode/medium/) - リンクリストのソート
- [Count of Smaller Numbers After Self](../leetcode/hard/) - マージソートの応用
- [Reverse Pairs](../leetcode/hard/) - マージソートで逆序数をカウント

---

**次のステップ**: [Quick Sort](./quick_sort_logic.md)でインプレースソートを学ぶ

