# Quick Sort - ロジック解説

## 問題概要

配列をクイックソートでソートする。クイックソートは分割統治法を使用したインプレースソートアルゴリズム。

**制約**:
- 配列の要素数は任意

**例**:
```
Input: [38, 27, 43, 3, 9, 82, 10]
Output: [3, 9, 10, 27, 38, 43, 82]
```

## ロジックの核心

### なぜ分割統治法が有効か？

**バブルソート（O(n²)）**:
- 全ての要素を比較してソート
- 時間計算量: O(n²) - 非効率

**分割統治法を使う理由**:
- **ピボットの選択**: 要素をピボットより小さい/大きいで分割
- **再帰的ソート**: 分割された部分配列を再帰的にソート
- **時間計算量**: O(n log n)平均 - 実用的に高速

### 思考プロセス

1. **ピボットの選択**: 配列からピボットを選択
2. **分割**: ピボットより小さい要素を左、大きい要素を右に配置
3. **再帰**: 左右の部分配列を再帰的にソート

### アルゴリズムのステップ

```
function quickSort(arr, low, high):
    if low < high:
        pivot = partition(arr, low, high)
        quickSort(arr, low, pivot - 1)
        quickSort(arr, pivot + 1, high)

function partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1
```

## 具体例でのトレース

### 例: `arr = [38, 27, 43, 3]`

```
初期: [38, 27, 43, 3]
pivot = 3 (最後の要素)

分割:
  j=0: 38 > 3 → スキップ
  j=1: 27 > 3 → スキップ
  j=2: 43 > 3 → スキップ
  j=3: 3 <= 3 → swap → [3, 27, 43, 38]

左: [] (空)
右: [27, 43, 38]

右をソート:
  pivot = 38
  分割: [27, 38, 43]

結果: [3, 27, 38, 43]
```

## 現実世界での応用

### 1. 一般的なソート処理
- **シナリオ**: プログラミング言語の標準ライブラリで使用
- **実装**: クイックソートで高速なソートを実現
- **メリット**: 平均的に高速で、インプレースソート

### 2. データベースのクエリ最適化
- **シナリオ**: データベースで、インデックスの構築に使用
- **実装**: クイックソートでインデックスを構築
- **メリット**: 効率的なインデックス構築

### 3. 数値計算
- **シナリオ**: 数値計算で、データの前処理に使用
- **実装**: クイックソートでデータをソート
- **メリット**: 高速なデータ処理

### 4. ゲーム開発
- **シナリオ**: ゲームで、オブジェクトの描画順序を決定
- **実装**: クイックソートでオブジェクトをソート
- **メリット**: 効率的なレンダリング

### 5. ネットワークルーティング
- **シナリオ**: ネットワークで、パケットの優先度でソート
- **実装**: クイックソートでパケットをソート
- **メリット**: 効率的なパケット処理

### 6. 金融取引システム
- **シナリオ**: 金融取引で、注文を価格順にソート
- **実装**: クイックソートで注文をソート
- **メリット**: 高速な取引処理

## 注意点と落とし穴

### 1. ピボットの選択
- **問題**: ピボットの選択が性能に大きく影響
- **解決策**: ランダム、中央値、または最後の要素を選択
- **実装**: `pivot = arr[high]`（最後の要素）
- **注意**: 最悪の場合、O(n²)になる可能性がある

### 2. パーティション操作
- **問題**: ピボットより小さい/大きい要素を正確に分割
- **解決策**: 2つのポインタを使用して分割
- **実装**: `i`を小さい要素のインデックスとして管理
- **注意**: パーティションの実装が重要

### 3. インプレースソート
- **問題**: 追加のメモリを使用せずにソート
- **解決策**: 配列を直接変更
- **実装**: `arr[i], arr[j] = arr[j], arr[i]`でスワップ
- **メリット**: 空間計算量がO(log n)（再帰スタック）

### 4. 時間計算量の理解
- **平均**: O(n log n) - ランダムなデータで高速
- **最悪**: O(n²) - 既にソート済みの場合
- **空間**: O(log n) - 再帰スタック
- **注意**: 最悪時間計算量に注意が必要

### 5. 安定ソートではない
- **問題**: 同じ値の要素の順序が保証されない
- **解決策**: 安定ソートが必要な場合はマージソートを使用
- **実装**: クイックソートは安定ソートではない
- **注意**: 順序が重要な場合は注意が必要

### 6. 小さい配列の処理
- **問題**: 小さい配列では、挿入ソートの方が高速な場合がある
- **解決策**: 配列のサイズが閾値以下の場合、挿入ソートを使用
- **実装**: `if high - low < THRESHOLD: insertionSort(arr, low, high)`
- **メリット**: 実用的な実行時間を改善

### 7. 再帰の深さ
- **問題**: 深い再帰はスタックオーバーフローを引き起こす可能性がある
- **解決策**: 反復的実装を使用、または再帰の深さを制限
- **実装**: スタックを使った反復的実装
- **注意**: Pythonのデフォルト再帰制限は1000程度

### 8. 3-wayパーティション
- **問題**: 重複要素が多い場合、3-wayパーティションが有効
- **解決策**: ピボットより小さい/等しい/大きいで3分割
- **実装**: 3つのポインタを使用
- **メリット**: 重複要素が多い場合に効率的

## 関連問題

- [Merge Sort](./merge_sort_logic.md) - 安定ソート
- [Sort Colors](../leetcode/medium/) - 3-wayパーティション
- [Kth Largest Element](../17_heap/kth_largest_element_logic.md) - クイックセレクト
- [Wiggle Sort II](../leetcode/medium/) - クイックソートの応用

---

**次のステップ**: [Pow(x, n)](./pow_x_n_logic.md)でべき乗計算を学ぶ

