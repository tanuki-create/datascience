# 分割統治法 (Divide and Conquer)

## 概要

分割統治法は、問題を**より小さな部分問題に分割**し、それぞれを**再帰的に解決**して、結果を**統合**するアルゴリズム手法です。マージソート、クイックソート、バイナリサーチなど、多くの効率的なアルゴリズムの基礎となっています。

## 基本概念

### 分割統治法の3つのステップ

1. **分割（Divide）**: 問題をより小さな部分問題に分割
2. **統治（Conquer）**: 部分問題を再帰的に解決
3. **統合（Combine）**: 部分問題の解を統合して元の問題の解を構築

### 主な操作と計算量

| アルゴリズム | 時間計算量 | 空間計算量 | 適用場面 |
|------------|-----------|-----------|---------|
| マージソート | O(n log n) | O(n) | 安定ソートが必要な場合 |
| クイックソート | O(n log n)平均 | O(log n) | 一般的なソート |
| バイナリサーチ | O(log n) | O(1) | ソート済み配列の検索 |
| べき乗計算 | O(log n) | O(log n) | 大きな数のべき乗 |

**注意**: 分割統治法は再帰的な構造を持つため、再帰の深さに注意が必要です。

## いつ使うべきか

分割統治法は以下のような場面で威力を発揮します：

### 1. ソート問題
- マージソート、クイックソート
- 安定ソートが必要な場合

### 2. 検索問題
- ソート済み配列での検索
- バイナリサーチ

### 3. 数学的問題
- べき乗計算
- 最大部分配列問題

### 4. 幾何学的問題
- 最近点対問題
- 凸包問題

### 5. 文字列問題
- 最長共通部分列
- 文字列のマッチング

## 現実世界での応用例

### 1. マージソートの実装
- **例**: 大規模なデータセットのソート
- **実装**: 配列を2つに分割し、それぞれをソートしてマージ
- **メリット**: 安定ソートで、最悪時間計算量が保証される

### 2. クイックソートの実装
- **例**: 一般的なソート処理
- **実装**: ピボットを選択し、配列を分割して再帰的にソート
- **メリット**: 平均的に高速で、インプレースソート

### 3. バイナリサーチ
- **例**: ソート済みデータベースでの検索
- **実装**: 配列を2つに分割し、目的の値が含まれる方を選択
- **メリット**: 対数時間で検索可能

### 4. べき乗計算
- **例**: 暗号化アルゴリズムでの大きな数のべき乗
- **実装**: 指数を2つに分割し、再帰的に計算
- **メリット**: 線形時間から対数時間に改善

### 5. 画像処理
- **例**: 画像の圧縮や変換
- **実装**: 画像を領域に分割し、それぞれを処理
- **メリット**: 並列処理が可能

### 6. データベースのクエリ最適化
- **例**: 大規模なデータベースでのクエリ処理
- **実装**: データを分割し、それぞれを並列に処理
- **メリット**: クエリの実行時間を短縮

## 実装時の注意点

### 1. ベースケースの定義
- **問題**: 再帰が終了する条件を明確に定義する必要がある
- **解決策**: 問題が十分に小さい場合、直接解決
- **実装**: `if n <= 1: return`などのベースケース
- **注意**: ベースケースを忘れると、無限再帰が発生

### 2. 再帰の深さ
- **問題**: 深い再帰はスタックオーバーフローを引き起こす可能性がある
- **解決策**: 反復的実装を使用、または再帰の深さを制限
- **実装**: スタックを使った反復的実装
- **注意**: Pythonのデフォルト再帰制限は1000程度

### 3. 部分問題の独立性
- **問題**: 部分問題が独立している必要がある
- **解決策**: 部分問題間の依存関係を最小化
- **実装**: データを適切に分割
- **注意**: 依存関係がある場合、動的計画法を検討

### 4. 統合のコスト
- **問題**: 部分問題の解を統合するコストを考慮する必要がある
- **解決策**: 統合のコストが部分問題の解決コストより小さいことを確認
- **実装**: 統合のアルゴリズムを最適化
- **注意**: 統合のコストが大きい場合、分割統治法が非効率になる可能性がある

### 5. メモ化の活用
- **問題**: 同じ部分問題が複数回計算される可能性がある
- **解決策**: メモ化を使って、計算済みの結果を再利用
- **実装**: `@lru_cache`デコレータを使用
- **注意**: メモ化により時間計算量を改善できる場合がある

## 関連するLeetCode/AtCoder問題

### Medium
- [Merge Sort](./merge_sort_logic.md) - 分割統治法の基本
- [Quick Sort](./quick_sort_logic.md) - インプレースソート
- [Pow(x, n)](./pow_x_n_logic.md) - べき乗計算

### Hard
- [Maximum Subarray](../08_greedy/maximum_subarray_logic.md) - 分割統治法アプローチ
- [Count of Smaller Numbers After Self](../leetcode/hard/) - マージソートの応用

## 学習の進め方

1. **Merge Sort**から始める: 分割統治法の最も基本的な例
2. **Quick Sort**でインプレースソートを学ぶ: 実用的なソートアルゴリズム
3. **より複雑な問題**に挑戦: 他のテクニックと組み合わせた使用法を学ぶ

## 次のステップ

- [Merge Sort のロジック解説](./merge_sort_logic.md)
- [Quick Sort のロジック解説](./quick_sort_logic.md)
- [動的計画法テクニック](../07_dynamic_programming/README.md) - 分割統治法と比較

---

**重要**: 分割統治法は、多くの効率的なアルゴリズムの基礎です。問題を適切に分割し、部分問題を解決して統合する思考プロセスを理解することが重要です。

