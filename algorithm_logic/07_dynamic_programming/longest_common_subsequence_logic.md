# Longest Common Subsequence - ロジック解説

## 問題概要

2つの文字列`text1`と`text2`が与えられたとき、最長共通部分列（LCS）の長さを返す。

**制約**:
- `1 <= text1.length, text2.length <= 1000`

**例**:
```
Input: text1 = "abcde", text2 = "ace"
Output: 3
説明: "ace"が最長共通部分列
```

## ロジックの核心

### なぜ動的計画法が有効か？

**全探索（O(2^m × 2^n)）**:
- 全ての部分列を生成してチェック
- 時間計算量: 指数時間 - 非効率

**動的計画法を使う理由**:
- **部分問題の重複**: 同じ部分文字列のLCSが複数回計算される
- **時間計算量**: O(m×n) - 各文字のペアを1回ずつ処理
- **空間計算量**: O(m×n) - 2次元DPテーブル

### 思考プロセス

1. **状態の定義**: `dp[i][j]` = text1[0..i-1]とtext2[0..j-1]のLCSの長さ
2. **遷移**: 
   - 文字が同じ: `dp[i][j] = dp[i-1][j-1] + 1`
   - 文字が異なる: `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`
3. **結果**: `dp[m][n]`が答え

### アルゴリズムのステップ

```
function longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]
```

## 具体例でのトレース

### 例: `text1 = "abcde", text2 = "ace"`

```
初期状態:
  dp[0][*] = [0,0,0,0]
  dp[*][0] = [0,0,0,0,0,0]

i=1, j=1: text1[0]='a', text2[0]='a'
  'a' == 'a' → dp[1][1] = dp[0][0] + 1 = 1

i=1, j=2: text1[0]='a', text2[1]='c'
  'a' != 'c' → dp[1][2] = max(dp[0][2], dp[1][1]) = max(0,1) = 1

i=1, j=3: text1[0]='a', text2[2]='e'
  'a' != 'e' → dp[1][3] = max(dp[0][3], dp[1][2]) = max(0,1) = 1

i=2, j=1: text1[1]='b', text2[0]='a'
  'b' != 'a' → dp[2][1] = max(dp[1][1], dp[2][0]) = max(1,0) = 1

i=2, j=2: text1[1]='b', text2[1]='c'
  'b' != 'c' → dp[2][2] = max(dp[1][2], dp[2][1]) = max(1,1) = 1

i=2, j=3: text1[1]='b', text2[2]='e'
  'b' != 'e' → dp[2][3] = max(dp[1][3], dp[2][2]) = max(1,1) = 1

i=3, j=2: text1[2]='c', text2[1]='c'
  'c' == 'c' → dp[3][2] = dp[2][1] + 1 = 2

... 続けて計算

最終: dp[5][3] = 3
```

## 現実世界での応用

### 1. バージョン管理システム
- **シナリオ**: Gitで、ファイルの差分を計算
- **実装**: LCSでファイルの共通部分を計算
- **メリット**: 効率的なバージョン管理

### 2. DNA配列解析
- **シナリオ**: バイオインフォマティクスで、DNA配列の類似性を計算
- **実装**: LCSで配列の類似性を計算
- **メリット**: 効率的なDNA解析

### 3. 自然言語処理
- **シナリオ**: NLPで、文の類似性を計算
- **実装**: LCSで文の類似性を計算
- **メリット**: 効率的な自然言語処理

### 4. データベース
- **シナリオ**: データベースで、レコードの類似性を計算
- **実装**: LCSでレコードの類似性を計算
- **メリット**: 効率的なデータベース操作

### 5. 画像処理
- **シナリオ**: 画像処理で、画像の類似性を計算
- **実装**: LCSの概念を画像に適用
- **メリット**: 効率的な画像処理

### 6. テキスト比較
- **シナリオ**: テキストエディタで、ファイルの差分を表示
- **実装**: LCSでファイルの差分を計算
- **メリット**: 効率的なテキスト比較

## 注意点と落とし穴

### 1. ベースケースの設定
- **問題**: 空文字列とのLCSは0
- **解決策**: `dp[0][*] = 0`と`dp[*][0] = 0`で設定
- **実装**: 空文字列とのLCSは0
- **注意**: ベースケースを忘れると、誤った結果が返される

### 2. インデックスの扱い
- **問題**: 文字列のインデックスとDPテーブルのインデックスの対応
- **解決策**: `text1[i-1]`と`text2[j-1]`でアクセス（DPは1-based）
- **実装**: DPテーブルは1-based、文字列は0-based
- **注意**: インデックスのずれに注意

### 3. 2つの遷移の理解
- **問題**: 文字が同じ場合と異なる場合の遷移を正確に理解
- **解決策**: 
  - 同じ: `dp[i][j] = dp[i-1][j-1] + 1`（両方の文字を使用）
  - 異なる: `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`（どちらか一方を使用）
- **注意**: 遷移を正確に実装する必要がある

### 4. 時間計算量の理解
- **平均**: O(m×n) - 各文字のペアを1回ずつ処理
- **最悪**: O(m×n) - 常に同じ時間計算量
- **空間**: O(m×n) - 2次元DPテーブル
- **最適化**: 空間をO(min(m,n))に削減可能

### 5. 空間最適化
- **問題**: 2次元DPテーブルでメモリを大量に消費
- **解決策**: 1次元DPテーブルを使用（前の行のみを保持）
- **実装**: `dp_prev`と`dp_curr`で管理
- **メリット**: 空間計算量をO(min(m,n))に削減

### 6. 部分列の復元
- **問題**: LCSの長さだけでなく、部分列自体を取得する必要がある場合
- **解決策**: DPテーブルを逆に辿って部分列を復元
- **実装**: `dp[i][j]`から`dp[i-1][j-1]`、`dp[i-1][j]`、`dp[i][j-1]`を確認
- **注意**: 部分列の復元には追加の時間が必要

### 7. 複数のLCS
- **問題**: LCSが複数存在する可能性がある
- **解決策**: 通常は長さのみを返すが、全てのLCSが必要な場合は別の実装
- **実装**: 全てのLCSを追跡する必要がある
- **注意**: この問題では長さのみが必要

### 8. エッジケースの処理
- **問題**: 空の文字列、同じ文字列、共通部分がない場合
- **解決策**: 各操作でエッジケースをチェック
- **実装**: `if not text1 or not text2: return 0`などのチェック
- **注意**: エッジケースを忘れると、エラーが発生

## 関連問題

- [Edit Distance](./edit_distance_logic.md) - 文字列の編集距離
- [Longest Increasing Subsequence](./longest_increasing_subsequence_logic.md) - 部分列の問題
- [Coin Change](./coin_change_logic.md) - 最適化問題
- [Delete Operation for Two Strings](../leetcode/medium/) - LCSの応用

---

**次のステップ**: [Unique Paths](./unique_paths_logic.md)で経路の問題を学ぶ

