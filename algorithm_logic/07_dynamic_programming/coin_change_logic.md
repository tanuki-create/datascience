# Coin Change - ロジック解説

## 問題概要

異なる額面のコイン`coins`と金額`amount`が与えられたとき、`amount`を構成するのに必要な最小のコイン数を返す。不可能な場合は-1を返す。

**制約**:
- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 2^31 - 1`
- `0 <= amount <= 10^4`

**例**:
```
Input: coins = [1,2,5], amount = 11
Output: 3
説明: 11 = 5 + 5 + 1
```

## ロジックの核心

### なぜ動的計画法が有効か？

**全探索（O(amount^coins.length)）**:
- 全ての可能な組み合わせを試す
- 時間計算量: 指数時間 - 非効率

**動的計画法を使う理由**:
- **部分問題の重複**: 同じ金額が複数回計算される
- **時間計算量**: O(amount × coins.length) - 効率的
- **空間計算量**: O(amount) - 1次元DPテーブル

### 思考プロセス

1. **状態の定義**: `dp[i]` = 金額iを構成する最小コイン数
2. **遷移**: `dp[i] = min(dp[i], dp[i-coin] + 1)` for all coins
3. **結果**: `dp[amount]`が答え（不可能な場合は-1）

### アルゴリズムのステップ

```
function coinChange(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    
    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin:
                dp[i] = min(dp[i], dp[i-coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1
```

## 具体例でのトレース

### 例: `coins = [1,2,5], amount = 11`

```
初期状態:
  dp = [0, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf]

i=1: coin=1
  dp[1] = min(inf, dp[0]+1) = 1

i=2: coin=1,2
  coin=1: dp[2] = min(inf, dp[1]+1) = 2
  coin=2: dp[2] = min(2, dp[0]+1) = 1

i=3: coin=1,2
  coin=1: dp[3] = min(inf, dp[2]+1) = 2
  coin=2: dp[3] = min(2, dp[1]+1) = 2

i=4: coin=1,2
  coin=1: dp[4] = min(inf, dp[3]+1) = 3
  coin=2: dp[4] = min(3, dp[2]+1) = 2

i=5: coin=1,2,5
  coin=1: dp[5] = min(inf, dp[4]+1) = 3
  coin=2: dp[5] = min(3, dp[3]+1) = 3
  coin=5: dp[5] = min(3, dp[0]+1) = 1

... 続けて計算

最終: dp[11] = 3
```

## 現実世界での応用

### 1. 金融システム
- **シナリオ**: 金融システムで、おつりの計算を最適化
- **実装**: コイン変更問題で最小コイン数を計算
- **メリット**: 効率的なおつり計算

### 2. 在庫管理
- **シナリオ**: 在庫管理で、商品の組み合わせを最適化
- **実装**: コイン変更問題で最小組み合わせを計算
- **メリット**: 効率的な在庫管理

### 3. リソース割り当て
- **シナリオ**: リソース割り当てで、リソースの組み合わせを最適化
- **実装**: コイン変更問題で最小組み合わせを計算
- **メリット**: 効率的なリソース割り当て

### 4. パッケージング
- **シナリオ**: パッケージングで、パッケージの組み合わせを最適化
- **実装**: コイン変更問題で最小組み合わせを計算
- **メリット**: 効率的なパッケージング

### 5. ネットワークルーティング
- **シナリオ**: ネットワークルーティングで、パスの組み合わせを最適化
- **実装**: コイン変更問題で最小組み合わせを計算
- **メリット**: 効率的なルーティング

### 6. データ圧縮
- **シナリオ**: データ圧縮で、圧縮ブロックの組み合わせを最適化
- **実装**: コイン変更問題で最小組み合わせを計算
- **メリット**: 効率的なデータ圧縮

## 注意点と落とし穴

### 1. 初期値の設定
- **問題**: 金額0は0コインで構成可能
- **解決策**: `dp[0] = 0`で設定
- **実装**: 他の金額は`inf`で初期化
- **注意**: 初期値を0にすると、誤った結果が返される

### 2. 不可能な場合の処理
- **問題**: 金額を構成できない場合、-1を返す必要がある
- **解決策**: `dp[amount] == inf`の場合、-1を返す
- **実装**: `return dp[amount] if dp[amount] != float('inf') else -1`
- **注意**: 不可能な場合の処理が重要

### 3. コインの順序
- **問題**: コインの順序は関係ない
- **解決策**: どの順序でも同じ結果
- **実装**: コインを順番に処理
- **注意**: コインの順序を気にする必要はない

### 4. 時間計算量の理解
- **平均**: O(amount × coins.length) - 各金額について、各コインをチェック
- **最悪**: O(amount × coins.length) - 常に同じ時間計算量
- **空間**: O(amount) - 1次元DPテーブル
- **メリット**: 指数時間から多項式時間に改善

### 5. 貪欲法との比較
- **問題**: 貪欲法では解けない場合がある
- **解決策**: 動的計画法を使用
- **例**: coins=[3,4], amount=6の場合、貪欲法は失敗
- **注意**: 貪欲法が使えるのは特殊な場合のみ

### 6. 組み合わせの数
- **問題**: 最小コイン数だけでなく、組み合わせの数が必要な場合
- **解決策**: 別のDPテーブルで組み合わせの数を計算
- **実装**: `count[i] = sum(count[i-coin])` for all coins
- **注意**: 組み合わせの数は重複を考慮する必要がある

### 7. エッジケースの処理
- **問題**: amount=0、コインがない、全てのコインがamountより大きい
- **解決策**: 各操作でエッジケースをチェック
- **実装**: `if amount == 0: return 0`などのチェック
- **注意**: エッジケースを忘れると、エラーが発生

### 8. 無限コインの前提
- **問題**: 各コインを無限回使用できることを前提とする
- **解決策**: 各コインを何度でも使用可能
- **実装**: 内側のループで各コインをチェック
- **注意**: 各コインを1回だけ使用する場合は、別の実装が必要

## 関連問題

- [Coin Change II](../leetcode/medium/) - 組み合わせの数
- [Longest Increasing Subsequence](./longest_increasing_subsequence_logic.md) - 部分列の問題
- [Edit Distance](./edit_distance_logic.md) - 文字列の編集距離
- [Partition Equal Subset Sum](../leetcode/medium/) - 部分和問題

---

**次のステップ**: [Longest Common Subsequence](./longest_common_subsequence_logic.md)で共通部分列を学ぶ

