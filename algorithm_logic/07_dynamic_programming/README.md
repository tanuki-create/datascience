# 動的計画法 (Dynamic Programming)

## 概要

動的計画法（DP）は、**最適化問題**を効率的に解くための強力な手法です。大きな問題を小さな部分問題に分割し、部分問題の解を再利用することで、計算量を大幅に削減します。

## 基本概念

### 動的計画法の特徴

1. **部分問題の重複**: 同じ部分問題が複数回出現する
2. **最適部分構造**: 最適解が部分問題の最適解から構成される
3. **メモ化**: 計算済みの結果を保存して再利用

### アプローチの種類

1. **トップダウン（メモ化再帰）**: 再帰関数にメモ化を追加
2. **ボトムアップ（反復的DP）**: 小さな問題から順に解いていく

### 主な操作と計算量

| アプローチ | 時間計算量 | 空間計算量 | 適用場面 |
|-----------|-----------|-----------|---------|
| メモ化再帰 | O(n) | O(n) | 直感的だが再帰のオーバーヘッド |
| 反復的DP | O(n) | O(n) | 効率的で推奨 |
| 空間最適化 | O(n) | O(1) | 一部の問題で可能 |

## いつ使うべきか

動的計画法は以下のような場面で威力を発揮します：

### 1. 最適化問題
- 「最大/最小の値を求める」
- 「最適な組み合わせを見つける」
- **利点**: 全探索を避けて効率的に最適解を見つける

### 2. カウント問題
- 「特定の条件を満たす組み合わせの数を数える」
- 「パターンの数を計算する」
- **利点**: 重複計算を避けて効率的にカウント

### 3. 判定問題
- 「特定の条件を満たす解が存在するか判定」
- 「目標を達成できるか判定」
- **利点**: 効率的に判定可能

### 4. 経路問題
- 「グリッド上の経路の数を数える」
- 「最短経路を見つける」
- **利点**: 重複する経路を効率的に処理

## 現実世界での応用例

### 1. 株式取引の最適化
- **例**: 複数の取引から最大利益を求める
- **実装**: DPで各時点での最適な戦略を計算
- **メリット**: 複雑な取引戦略を効率的に最適化

### 2. リソース配分の最適化
- **例**: 限られた予算で最大の価値を得る
- **実装**: ナップサック問題としてDPで解く
- **メリット**: 最適なリソース配分を効率的に計算

### 3. テキスト処理（編集距離）
- **例**: 2つの文字列の類似度を計算
- **実装**: DPで編集距離を計算
- **メリット**: スペルチェッカーや検索エンジンで使用

### 4. ゲーム開発（AI）
- **例**: ゲームAIの意思決定
- **実装**: DPで最適な手を計算
- **メリット**: 複雑なゲーム木を効率的に探索

### 5. ネットワーク最適化
- **例**: ネットワーク上の最短経路を計算
- **実装**: DPで経路を最適化
- **メリット**: ルーティングアルゴリズムで使用

## 実装時の注意点

### 1. 状態の定義
- **問題**: DPテーブルの次元と意味を正確に定義する必要がある
- **解決策**: 「dp[i]は何を表すか？」を明確にする
- **例**: `dp[i]` = i番目の要素までの最適解

### 2. 遷移式の導出
- **問題**: 状態間の遷移を正確に表現する必要がある
- **解決策**: 「現在の状態はどの状態から遷移できるか？」を考える
- **例**: `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`

### 3. 初期値の設定
- **問題**: ベースケースを正確に設定する必要がある
- **解決策**: 最小の部分問題の解を設定
- **例**: `dp[0] = 0`, `dp[1] = 1`

### 4. 空間最適化
- **問題**: 全ての状態を保存するとメモリを消費
- **解決策**: 必要な状態のみを保存（例: 直前の2つの状態のみ）
- **メリット**: O(n)からO(1)に空間計算量を削減

## 関連するLeetCode/AtCoder問題

### Easy
- [Climbing Stairs](./climbing_stairs_logic.md) - DPの基本
- [House Robber](./house_robber_logic.md) - 1次元DP
- [Fibonacci Number](../leetcode/easy/) - DPの典型例

### Medium
- [Coin Change](../leetcode/medium/) - ナップサック型DP
- [Longest Increasing Subsequence](../leetcode/medium/) - LIS問題
- [Unique Paths](../leetcode/medium/) - 2次元DP

### Hard
- [Edit Distance](../leetcode/hard/) - 文字列DP
- [Regular Expression Matching](../leetcode/hard/) - 複雑なDP
- [Word Break II](../leetcode/hard/) - 高度なDP

## 学習の進め方

1. **Climbing Stairs**から始める: DPの最も基本的な例
2. **House Robber**で1次元DPを学ぶ: より複雑な状態遷移
3. **2次元DP**で応用を学ぶ: グリッド上の問題

## 次のステップ

- [Climbing Stairs のロジック解説](./climbing_stairs_logic.md)
- [House Robber のロジック解説](./house_robber_logic.md)
- [貪欲法テクニック](../08_greedy/README.md) - 次のPhase 3のテクニック

---

**重要**: 動的計画法は、最適化問題を効率的に解く強力な手法です。部分問題の重複を利用することで、指数時間から多項式時間に改善できます。

