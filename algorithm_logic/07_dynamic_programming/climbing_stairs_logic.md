# Climbing Stairs - ロジック解説

## 問題概要

n段の階段があり、1回に1段または2段登れる。頂上に到達する方法の数を求める。

**制約**:
- `1 <= n <= 45`

**例**:
```
Input: n = 3
Output: 3
説明: 
1. 1 + 1 + 1
2. 1 + 2
3. 2 + 1
```

## ロジックの核心

### なぜ動的計画法が有効か？

**再帰的アプローチ（O(2^n)）**:
- 各段階で2つの選択肢がある
- 時間計算量: O(2^n) - 指数時間で非効率

**動的計画法を使う理由**:
- **部分問題の重複**: 同じ段数への到達方法が複数回計算される
- **フィボナッチ数列**: この問題は実質的にフィボナッチ数列
- **時間計算量**: O(n) - 線形時間で効率的

### 思考プロセス

1. **状態の定義**: `dp[i]` = i段目に到達する方法の数
2. **遷移式**: 
   - i段目に到達するには、`(i-1)`段目から1段登る、または`(i-2)`段目から2段登る
   - `dp[i] = dp[i-1] + dp[i-2]`
3. **初期値**: `dp[1] = 1`, `dp[2] = 2`

### アルゴリズムのステップ

```
1. dp[1] = 1, dp[2] = 2 を設定
2. i = 3 から n まで:
   dp[i] = dp[i-1] + dp[i-2]
3. dp[n] を返す
```

### 疑似コード

```
function climbStairs(n):
    if n <= 2:
        return n
    
    prev2 = 1  // dp[1]
    prev1 = 2  // dp[2]
    
    for i from 3 to n:
        current = prev1 + prev2
        prev2 = prev1
        prev1 = current
    
    return prev1
```

## 具体例でのトレース

### 例: `n = 5`

| i | dp[i] | 計算 | 説明 |
|---|-------|------|------|
| 1 | 1 | - | 1段目への方法は1通り |
| 2 | 2 | - | 2段目への方法は2通り（1+1, 2） |
| 3 | 3 | dp[2] + dp[1] = 2 + 1 | 3段目への方法は3通り |
| 4 | 5 | dp[3] + dp[2] = 3 + 2 | 4段目への方法は5通り |
| 5 | 8 | dp[4] + dp[3] = 5 + 3 | 5段目への方法は8通り |

**結果**: `8`

## 現実世界での応用

### 1. パスワード生成
- **シナリオ**: 特定の長さのパスワードを生成する方法の数を計算
- **実装**: 同様のDPアプローチで組み合わせの数を計算

### 2. ゲーム開発
- **シナリオ**: ゲーム内で特定の位置に到達する方法の数を計算
- **実装**: 移動パターンの組み合わせをDPで計算

## 注意点と落とし穴

1. **フィボナッチ数列**: この問題はフィボナッチ数列と同じ
2. **空間最適化**: 直前の2つの値のみを保存すればO(1)空間で解ける
3. **オーバーフロー**: nが大きい場合、整数のオーバーフローに注意

## 関連問題

- Fibonacci Number
- House Robber
- Decode Ways

---

**次のステップ**: [House Robber](./house_robber_logic.md)でより複雑なDPを学ぶ

