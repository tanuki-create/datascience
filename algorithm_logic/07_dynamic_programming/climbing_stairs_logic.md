# Climbing Stairs - ロジック解説

## 問題概要

n段の階段があり、1回に1段または2段登れる。頂上に到達する方法の数を求める。

**制約**:
- `1 <= n <= 45`

**例**:
```
Input: n = 3
Output: 3
説明: 
1. 1 + 1 + 1
2. 1 + 2
3. 2 + 1
```

## ロジックの核心

### なぜ動的計画法が有効か？

**再帰的アプローチ（O(2^n)）**:
- 各段階で2つの選択肢がある
- 時間計算量: O(2^n) - 指数時間で非効率

**動的計画法を使う理由**:
- **部分問題の重複**: 同じ段数への到達方法が複数回計算される
- **フィボナッチ数列**: この問題は実質的にフィボナッチ数列
- **時間計算量**: O(n) - 線形時間で効率的

### 思考プロセス

1. **状態の定義**: `dp[i]` = i段目に到達する方法の数
2. **遷移式**: 
   - i段目に到達するには、`(i-1)`段目から1段登る、または`(i-2)`段目から2段登る
   - `dp[i] = dp[i-1] + dp[i-2]`
3. **初期値**: `dp[1] = 1`, `dp[2] = 2`

### アルゴリズムのステップ

```
1. dp[1] = 1, dp[2] = 2 を設定
2. i = 3 から n まで:
   dp[i] = dp[i-1] + dp[i-2]
3. dp[n] を返す
```

### 疑似コード

```
function climbStairs(n):
    if n <= 2:
        return n
    
    prev2 = 1  // dp[1]
    prev1 = 2  // dp[2]
    
    for i from 3 to n:
        current = prev1 + prev2
        prev2 = prev1
        prev1 = current
    
    return prev1
```

## 具体例でのトレース

### 例: `n = 5`

| i | dp[i] | 計算 | 説明 |
|---|-------|------|------|
| 1 | 1 | - | 1段目への方法は1通り |
| 2 | 2 | - | 2段目への方法は2通り（1+1, 2） |
| 3 | 3 | dp[2] + dp[1] = 2 + 1 | 3段目への方法は3通り |
| 4 | 5 | dp[3] + dp[2] = 3 + 2 | 4段目への方法は5通り |
| 5 | 8 | dp[4] + dp[3] = 5 + 3 | 5段目への方法は8通り |

**結果**: `8`

## 現実世界での応用

### 1. パスワード生成システム
- **シナリオ**: 特定の長さのパスワードを生成する方法の数を計算
- **実装**: 同様のDPアプローチで組み合わせの数を計算
- **例**: 8文字のパスワードで、各文字が1種類または2種類の文字セットから選べる場合の組み合わせ数を計算

### 2. ゲーム開発（パス探索）
- **シナリオ**: ゲーム内で特定の位置に到達する方法の数を計算
- **実装**: 移動パターンの組み合わせをDPで計算
- **例**: チェスや将棋で、特定のマスに到達する方法の数を計算

### 3. ロボットの経路計画
- **シナリオ**: ロボットが階段を登る経路の数を計算
- **実装**: 各ステップでの選択肢をDPで管理
- **例**: 倉庫ロボットが棚の段を登る際の経路数を計算

### 4. ネットワークルーティング
- **シナリオ**: ネットワーク上で特定のノードに到達する経路の数を計算
- **実装**: 各ホップでの選択肢をDPで管理
- **例**: パケットが特定のルーターに到達する経路数を計算

### 5. 金融商品の組み合わせ
- **シナリオ**: 投資ポートフォリオの組み合わせ数を計算
- **実装**: 各投資選択での組み合わせをDPで計算
- **例**: 1単位または2単位の投資から、目標金額に到達する組み合わせ数を計算

## 注意点と落とし穴

### 1. フィボナッチ数列との関係
- **問題**: この問題は実質的にフィボナッチ数列と同じ
- **理解**: `dp[i] = dp[i-1] + dp[i-2]`はフィボナッチ数列の漸化式
- **応用**: フィボナッチ数列の性質（黄金比など）を理解すると、この問題の本質が見える

### 2. 空間最適化の重要性
- **問題**: 全ての状態を保存するとO(n)の空間が必要
- **解決策**: 直前の2つの値のみを保存すればO(1)空間で解ける
- **実装**: `prev2`と`prev1`の2つの変数のみを使用
- **メリット**: メモリ使用量を大幅に削減

### 3. オーバーフローの注意
- **問題**: nが大きい場合、整数のオーバーフローが発生する可能性
- **解決策**: 言語によっては大きな整数型を使用する必要がある
- **注意**: Pythonでは自動的に大きな整数を扱えるが、他の言語では注意が必要

### 4. 初期値の設定
- **問題**: `dp[1]`と`dp[2]`の初期値を正確に設定する必要がある
- **確認**: 
  - 1段目: 1通り（1段登る）
  - 2段目: 2通り（1+1、または2段登る）
- **注意**: 0段目の扱いを明確にする必要がある

### 5. 再帰的実装との比較
- **問題**: 再帰的実装は直感的だが、O(2^n)の時間計算量
- **解決策**: メモ化再帰を使えばO(n)になるが、反復的DPの方が効率的
- **選択**: 通常は反復的DPを推奨（スタックオーバーフローのリスクがない）

### 6. 問題の拡張
- **3段登れる場合**: `dp[i] = dp[i-1] + dp[i-2] + dp[i-3]`に拡張可能
- **k段まで登れる場合**: 一般化して`dp[i] = sum(dp[i-j] for j in range(1, k+1))`
- **応用**: より複雑な制約にも対応可能

## 関連問題

- Fibonacci Number
- House Robber
- Decode Ways

---

**次のステップ**: [House Robber](./house_robber_logic.md)でより複雑なDPを学ぶ

