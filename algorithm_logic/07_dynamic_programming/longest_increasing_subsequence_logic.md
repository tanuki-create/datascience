# Longest Increasing Subsequence - ロジック解説

## 問題概要

整数配列`nums`が与えられたとき、最長増加部分列（LIS）の長さを返す。

**制約**:
- `1 <= nums.length <= 2500`
- `-10^4 <= nums[i] <= 10^4`

**例**:
```
Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
説明: [2,3,7,18]が最長増加部分列
```

## ロジックの核心

### なぜ動的計画法が有効か？

**全探索（O(2^n)）**:
- 全ての部分列を生成してチェック
- 時間計算量: O(2^n) - 非効率

**動的計画法を使う理由**:
- **部分問題の重複**: 同じ部分列が複数回計算される
- **時間計算量**: O(n²) - 各要素について、以前の要素をチェック
- **最適化**: 二分探索でO(n log n)に改善可能

### 思考プロセス

1. **状態の定義**: `dp[i]` = インデックスiで終わる最長増加部分列の長さ
2. **遷移**: `dp[i] = max(dp[j] + 1)` for all j < i where nums[j] < nums[i]
3. **結果**: `max(dp)`が答え

### アルゴリズムのステップ

```
function lengthOfLIS(nums):
    n = len(nums)
    dp = [1] * n
    
    for i in range(1, n):
        for j in range(i):
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    
    return max(dp)
```

## 具体例でのトレース

### 例: `nums = [10,9,2,5,3,7,101,18]`

```
初期状態:
  dp = [1,1,1,1,1,1,1,1]

i=1: nums[1]=9
  j=0: nums[0]=10 > 9 → スキップ
  dp = [1,1,1,1,1,1,1,1]

i=2: nums[2]=2
  j=0: nums[0]=10 > 2 → スキップ
  j=1: nums[1]=9 > 2 → スキップ
  dp = [1,1,1,1,1,1,1,1]

i=3: nums[3]=5
  j=0: nums[0]=10 > 5 → スキップ
  j=1: nums[1]=9 > 5 → スキップ
  j=2: nums[2]=2 < 5 → dp[3] = max(1, 1+1) = 2
  dp = [1,1,1,2,1,1,1,1]

i=4: nums[4]=3
  j=2: nums[2]=2 < 3 → dp[4] = max(1, 1+1) = 2
  dp = [1,1,1,2,2,1,1,1]

i=5: nums[5]=7
  j=2: nums[2]=2 < 7 → dp[5] = max(1, 1+1) = 2
  j=3: nums[3]=5 < 7 → dp[5] = max(2, 2+1) = 3
  j=4: nums[4]=3 < 7 → dp[5] = max(3, 2+1) = 3
  dp = [1,1,1,2,2,3,1,1]

i=6: nums[6]=101
  j=5: nums[5]=7 < 101 → dp[6] = max(1, 3+1) = 4
  dp = [1,1,1,2,2,3,4,1]

i=7: nums[7]=18
  j=5: nums[5]=7 < 18 → dp[7] = max(1, 3+1) = 4
  dp = [1,1,1,2,2,3,4,4]

結果: max(dp) = 4
```

## 現実世界での応用

### 1. データ分析
- **シナリオ**: 時系列データで、増加傾向の最長期間を分析
- **実装**: LISで増加傾向の期間を検出
- **メリット**: 効率的なデータ分析

### 2. 金融取引
- **シナリオ**: 株価データで、上昇トレンドの最長期間を分析
- **実装**: LISで上昇トレンドを検出
- **メリット**: 効率的な金融分析

### 3. ゲーム開発
- **シナリオ**: ゲームで、スコアの増加傾向を分析
- **実装**: LISでスコアの増加傾向を検出
- **メリット**: 効率的なゲーム分析

### 4. ログ分析
- **シナリオ**: ログで、エラーの増加傾向を分析
- **実装**: LISでエラーの増加傾向を検出
- **メリット**: 効率的なログ分析

### 5. 遺伝子解析
- **シナリオ**: DNA配列で、特定のパターンの増加を検出
- **実装**: LISでパターンの増加を検出
- **メリット**: 効率的な遺伝子解析

### 6. ネットワーク分析
- **シナリオ**: ネットワークで、トラフィックの増加傾向を分析
- **実装**: LISでトラフィックの増加傾向を検出
- **メリット**: 効率的なネットワーク分析

## 注意点と落とし穴

### 1. 初期値の設定
- **問題**: 各要素は少なくとも長さ1の部分列
- **解決策**: `dp = [1] * n`で初期化
- **実装**: 全ての要素を1で初期化
- **注意**: 初期値を0にすると、誤った結果が返される

### 2. 条件の確認
- **問題**: `nums[j] < nums[i]`の条件を正確に確認
- **解決策**: 増加部分列なので、`nums[j] < nums[i]`が必要
- **実装**: 等号を含めない（`nums[j] <= nums[i]`は非減少）
- **注意**: 等号を含めると、非減少部分列になる

### 3. 時間計算量の理解
- **平均**: O(n²) - 各要素について、以前の要素をチェック
- **最悪**: O(n²) - 常に同じ時間計算量
- **空間**: O(n) - dp配列
- **最適化**: 二分探索でO(n log n)に改善可能

### 4. 二分探索による最適化
- **問題**: O(n²)からO(n log n)に改善可能
- **解決策**: 各長さの最小末尾要素を追跡
- **実装**: `tails[i]` = 長さi+1の増加部分列の最小末尾要素
- **メリット**: 時間計算量を改善

### 5. エッジケースの処理
- **問題**: 空の配列、1つの要素、全て減少する場合
- **解決策**: 各操作でエッジケースをチェック
- **実装**: `if not nums: return 0`などのチェック
- **注意**: エッジケースを忘れると、エラーが発生

### 6. 部分列の復元
- **問題**: 最長増加部分列自体を取得する必要がある場合
- **解決策**: `parent`配列で親を記録
- **実装**: `parent[i] = j`で記録し、後で復元
- **注意**: 部分列の復元には追加の空間が必要

### 7. 非減少部分列
- **問題**: 非減少部分列（等号を許容）が必要な場合
- **解決策**: 条件を`nums[j] <= nums[i]`に変更
- **実装**: 等号を含めることで非減少部分列
- **注意**: 問題の要件を確認する必要がある

### 8. 複数の最長部分列
- **問題**: 最長増加部分列が複数存在する可能性がある
- **解決策**: 通常は長さのみを返すが、全ての部分列が必要な場合は別の実装
- **実装**: 全ての最長部分列を追跡する必要がある
- **注意**: この問題では長さのみが必要

## 関連問題

- [Edit Distance](./edit_distance_logic.md) - 文字列の編集距離
- [Coin Change](./coin_change_logic.md) - コインの組み合わせ
- [Longest Common Subsequence](./longest_common_subsequence_logic.md) - 最長共通部分列
- [Russian Doll Envelopes](../leetcode/hard/) - LISの応用

---

**次のステップ**: [Edit Distance](./edit_distance_logic.md)で文字列の編集距離を学ぶ

