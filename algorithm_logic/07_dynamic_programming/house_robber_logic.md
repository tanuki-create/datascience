# House Robber - ロジック解説

## 問題概要

家が一列に並んでおり、各家には一定の金額がある。隣接する家を同時に強盗すると警報が鳴る。最大の金額を盗む方法を求める。

**制約**:
- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

**例**:
```
Input: nums = [2,7,9,3,1]
Output: 12
説明: 家1(2), 家3(9), 家5(1)を強盗 → 2+9+1=12
```

## ロジックの核心

### なぜ動的計画法が有効か？

**全探索（O(2^n)）**:
- 各家について強盗する/しないの2択
- 時間計算量: O(2^n) - 非効率

**動的計画法を使う理由**:
- **最適部分構造**: i番目の家までの最適解が、それ以前の最適解から構成される
- **重複部分問題**: 同じ部分問題が複数回出現
- **時間計算量**: O(n) - 線形時間で効率的

### 思考プロセス

1. **状態の定義**: `dp[i]` = i番目の家までの最大金額
2. **選択**: i番目の家を強盗するか、しないか
   - 強盗する: `dp[i-2] + nums[i]`（1つ前の家は強盗できない）
   - 強盗しない: `dp[i-1]`（1つ前の家までの最大）
3. **遷移式**: `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`

### アルゴリズムのステップ

```
1. dp[0] = nums[0], dp[1] = max(nums[0], nums[1]) を設定
2. i = 2 から n-1 まで:
   dp[i] = max(dp[i-1], dp[i-2] + nums[i])
3. dp[n-1] を返す
```

## 具体例でのトレース

### 例: `nums = [2,7,9,3,1]`

| i | nums[i] | dp[i] | 計算 | 選択 |
|---|---------|-------|------|------|
| 0 | 2 | 2 | - | 強盗 |
| 1 | 7 | 7 | max(2, 7) | 強盗 |
| 2 | 9 | 11 | max(7, 2+9) | 強盗 |
| 3 | 3 | 11 | max(11, 7+3) | 強盗しない |
| 4 | 1 | 12 | max(11, 11+1) | 強盗 |

**結果**: `12`

## 現実世界での応用

### 1. リソース配分
- **シナリオ**: 互いに排他的な選択肢から最大の価値を得る
- **実装**: 同様のDPアプローチで最適化

### 2. スケジューリング
- **シナリオ**: 互いに競合するタスクから最大の価値を得る
- **実装**: 制約を考慮したDPで最適化

## 注意点と落とし穴

1. **境界条件**: 配列の長さが1または2の場合の処理
2. **空間最適化**: 直前の2つの値のみを保存すればO(1)空間で解ける
3. **選択の追跡**: どの家を強盗したかも追跡したい場合は、パスを保存する必要がある

## 関連問題

- House Robber II（円形の配列）
- House Robber III（木構造）
- Maximum Subarray

---

**次のステップ**: [貪欲法テクニック](../08_greedy/README.md)で別の最適化手法を学ぶ

