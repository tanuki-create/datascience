# House Robber - ロジック解説

## 問題概要

家が一列に並んでおり、各家には一定の金額がある。隣接する家を同時に強盗すると警報が鳴る。最大の金額を盗む方法を求める。

**制約**:
- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

**例**:
```
Input: nums = [2,7,9,3,1]
Output: 12
説明: 家1(2), 家3(9), 家5(1)を強盗 → 2+9+1=12
```

## ロジックの核心

### なぜ動的計画法が有効か？

**全探索（O(2^n)）**:
- 各家について強盗する/しないの2択
- 時間計算量: O(2^n) - 非効率

**動的計画法を使う理由**:
- **最適部分構造**: i番目の家までの最適解が、それ以前の最適解から構成される
- **重複部分問題**: 同じ部分問題が複数回出現
- **時間計算量**: O(n) - 線形時間で効率的

### 思考プロセス

1. **状態の定義**: `dp[i]` = i番目の家までの最大金額
2. **選択**: i番目の家を強盗するか、しないか
   - 強盗する: `dp[i-2] + nums[i]`（1つ前の家は強盗できない）
   - 強盗しない: `dp[i-1]`（1つ前の家までの最大）
3. **遷移式**: `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`

### アルゴリズムのステップ

```
1. dp[0] = nums[0], dp[1] = max(nums[0], nums[1]) を設定
2. i = 2 から n-1 まで:
   dp[i] = max(dp[i-1], dp[i-2] + nums[i])
3. dp[n-1] を返す
```

## 具体例でのトレース

### 例: `nums = [2,7,9,3,1]`

| i | nums[i] | dp[i] | 計算 | 選択 |
|---|---------|-------|------|------|
| 0 | 2 | 2 | - | 強盗 |
| 1 | 7 | 7 | max(2, 7) | 強盗 |
| 2 | 9 | 11 | max(7, 2+9) | 強盗 |
| 3 | 3 | 11 | max(11, 7+3) | 強盗しない |
| 4 | 1 | 12 | max(11, 11+1) | 強盗 |

**結果**: `12`

## 現実世界での応用

### 1. リソース配分の最適化
- **シナリオ**: 互いに排他的な選択肢から最大の価値を得る
- **実装**: 同様のDPアプローチで最適化
- **例**: 予算配分で、互いに競合するプロジェクトから最大の価値を得る組み合わせを選択
- **メリット**: 限られたリソースを最適に配分

### 2. タスクスケジューリング
- **シナリオ**: 互いに競合するタスクから最大の価値を得る
- **実装**: 制約を考慮したDPで最適化
- **例**: 会議室の予約で、時間が重複しない会議の組み合わせから最大の価値を得る
- **メリット**: リソースの効率的な利用

### 3. 投資ポートフォリオの最適化
- **シナリオ**: 互いに排他的な投資機会から最大のリターンを得る
- **実装**: 各投資機会のリターンをDPで最適化
- **例**: 複数の投資機会があり、同時に投資できない場合の最適な組み合わせを選択
- **メリット**: 投資リターンを最大化

### 4. 在庫管理の最適化
- **シナリオ**: 互いに競合する在庫配置から最大の利益を得る
- **実装**: 各配置の利益をDPで最適化
- **例**: 倉庫の配置で、隣接する倉庫を同時に使用できない場合の最適な配置を選択
- **メリット**: 在庫コストを最小化しながら利益を最大化

### 5. ネットワークリソースの割り当て
- **シナリオ**: ネットワーク上で互いに競合するリソース要求から最大の価値を得る
- **実装**: 各要求の価値をDPで最適化
- **例**: クラウドリソースの割り当てで、競合する要求から最適な組み合わせを選択
- **メリット**: リソースの効率的な利用

## 注意点と落とし穴

### 1. 境界条件の処理
- **問題**: 配列の長さが1または2の場合の処理が重要
- **解決策**: 
  - 長さ1: `dp[0] = nums[0]`を返す
  - 長さ2: `max(nums[0], nums[1])`を返す
- **注意**: これらのケースを忘れるとエラーが発生する

### 2. 空間最適化の実装
- **問題**: 全ての状態を保存するとO(n)の空間が必要
- **解決策**: 直前の2つの値のみを保存すればO(1)空間で解ける
- **実装**: `prev2`と`prev1`の2つの変数のみを使用
- **メリット**: メモリ使用量を大幅に削減

### 3. 選択の追跡（パスの保存）
- **問題**: どの家を強盗したかも知りたい場合がある
- **解決策**: 各状態で選択を記録し、最後に逆順にたどる
- **実装**: 
  ```
  choice[i] = True if dp[i-2] + nums[i] > dp[i-1] else False
  ```
- **応用**: 最適解のパスを返す場合に使用

### 4. 遷移式の理解
- **核心**: 「現在の家を強盗するか、しないか」の2択
- **判断基準**: 
  - 強盗する場合: `dp[i-2] + nums[i]`（2つ前までの最大 + 現在の家）
  - 強盗しない場合: `dp[i-1]`（1つ前までの最大）
- **理由**: 隣接する家を同時に強盗できないため、2つ前までの最大を使う

### 5. 負の値の扱い
- **問題**: 家の金額が負の場合（損失がある家）の処理
- **解決策**: アルゴリズムは自動的に負の値を避ける（強盗しない選択を選ぶ）
- **注意**: 全ての家が負の場合、1つも強盗しないのが最適（0を返す）

### 6. 問題の拡張（House Robber II）
- **円形の配列**: 最初と最後の家が隣接している場合
- **解決策**: 最初の家を含む場合と含まない場合の2通りを計算し、最大値を取る
- **実装**: `max(rob(nums[1:]), rob(nums[:-1]))`

## 関連問題

- House Robber II（円形の配列）
- House Robber III（木構造）
- Maximum Subarray

---

**次のステップ**: [貪欲法テクニック](../08_greedy/README.md)で別の最適化手法を学ぶ

