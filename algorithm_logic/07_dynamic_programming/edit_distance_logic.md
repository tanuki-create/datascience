# Edit Distance - ロジック解説

## 問題概要

2つの文字列`word1`と`word2`が与えられたとき、`word1`を`word2`に変換するのに必要な最小の操作回数（編集距離）を返す。操作は挿入、削除、置換。

**制約**:
- `0 <= word1.length, word2.length <= 500`

**例**:
```
Input: word1 = "horse", word2 = "ros"
Output: 3
説明: 
- horse → rorse (hをrに置換)
- rorse → rose (rを削除)
- rose → ros (eを削除)
```

## ロジックの核心

### なぜ動的計画法が有効か？

**全探索（O(3^(m+n))）**:
- 全ての可能な操作を試す
- 時間計算量: O(3^(m+n)) - 非効率

**動的計画法を使う理由**:
- **部分問題の重複**: 同じ部分文字列の編集距離が複数回計算される
- **時間計算量**: O(m×n) - 各文字のペアを1回ずつ処理
- **空間計算量**: O(m×n) - 2次元DPテーブル

### 思考プロセス

1. **状態の定義**: `dp[i][j]` = word1[0..i-1]をword2[0..j-1]に変換する最小操作回数
2. **遷移**: 
   - 文字が同じ: `dp[i][j] = dp[i-1][j-1]`
   - 文字が異なる: `dp[i][j] = min(挿入, 削除, 置換) + 1`
3. **結果**: `dp[m][n]`が答え

### アルゴリズムのステップ

```
function minDistance(word1, word2):
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    // ベースケース: 空文字列への変換
    for i in range(m + 1):
        dp[i][0] = i  // i文字を削除
    for j in range(n + 1):
        dp[0][j] = j  // j文字を挿入
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]  // 変更不要
            else:
                dp[i][j] = min(
                    dp[i-1][j] + 1,      // 削除
                    dp[i][j-1] + 1,      // 挿入
                    dp[i-1][j-1] + 1    // 置換
                )
    
    return dp[m][n]
```

## 具体例でのトレース

### 例: `word1 = "horse", word2 = "ros"`

```
初期状態:
  dp[0][*] = [0,1,2,3]
  dp[*][0] = [0,1,2,3,4,5]

i=1, j=1: word1[0]='h', word2[0]='r'
  'h' != 'r' → dp[1][1] = min(1+1, 1+1, 0+1) = 1

i=1, j=2: word1[0]='h', word2[1]='o'
  'h' != 'o' → dp[1][2] = min(2+1, 1+1, 1+1) = 2

i=1, j=3: word1[0]='h', word2[2]='s'
  'h' != 's' → dp[1][3] = min(3+1, 2+1, 2+1) = 3

i=2, j=1: word1[1]='o', word2[0]='r'
  'o' != 'r' → dp[2][1] = min(1+1, 2+1, 1+1) = 2

i=2, j=2: word1[1]='o', word2[1]='o'
  'o' == 'o' → dp[2][2] = dp[1][1] = 1

i=2, j=3: word1[1]='o', word2[2]='s'
  'o' != 's' → dp[2][3] = min(3+1, 2+1, 1+1) = 2

... 続けて計算

最終: dp[5][3] = 3
```

## 現実世界での応用

### 1. スペルチェッカー
- **シナリオ**: スペルチェッカーで、誤字を正しい単語に修正
- **実装**: 編集距離で最も近い単語を提案
- **メリット**: 効率的なスペルチェック

### 2. DNA配列解析
- **シナリオ**: バイオインフォマティクスで、DNA配列の類似性を計算
- **実装**: 編集距離で配列の類似性を計算
- **メリット**: 効率的なDNA解析

### 3. バージョン管理システム
- **シナリオ**: Gitで、ファイルの差分を計算
- **実装**: 編集距離でファイルの差分を計算
- **メリット**: 効率的なバージョン管理

### 4. 自然言語処理
- **シナリオ**: NLPで、単語の類似性を計算
- **実装**: 編集距離で単語の類似性を計算
- **メリット**: 効率的な自然言語処理

### 5. データベース
- **シナリオ**: データベースで、クエリの類似性を計算
- **実装**: 編集距離でクエリの類似性を計算
- **メリット**: 効率的なクエリ最適化

### 6. 画像処理
- **シナリオ**: 画像処理で、画像の類似性を計算
- **実装**: 編集距離の概念を画像に適用
- **メリット**: 効率的な画像処理

## 注意点と落とし穴

### 1. ベースケースの設定
- **問題**: 空文字列への変換を正確に処理する必要がある
- **解決策**: `dp[i][0] = i`と`dp[0][j] = j`で設定
- **実装**: 空文字列への変換は全ての文字を削除/挿入
- **注意**: ベースケースを忘れると、誤った結果が返される

### 2. インデックスの扱い
- **問題**: 文字列のインデックスとDPテーブルのインデックスの対応
- **解決策**: `word1[i-1]`と`word2[j-1]`でアクセス（DPは1-based）
- **実装**: DPテーブルは1-based、文字列は0-based
- **注意**: インデックスのずれに注意

### 3. 3つの操作の理解
- **問題**: 挿入、削除、置換の3つの操作を正確に理解
- **解決策**: 
  - 削除: `dp[i-1][j] + 1`（word1の文字を削除）
  - 挿入: `dp[i][j-1] + 1`（word2の文字を挿入）
  - 置換: `dp[i-1][j-1] + 1`（word1の文字をword2の文字に置換）
- **注意**: 3つの操作を正確に実装する必要がある

### 4. 時間計算量の理解
- **平均**: O(m×n) - 各文字のペアを1回ずつ処理
- **最悪**: O(m×n) - 常に同じ時間計算量
- **空間**: O(m×n) - 2次元DPテーブル
- **最適化**: 空間をO(min(m,n))に削減可能

### 5. 空間最適化
- **問題**: 2次元DPテーブルでメモリを大量に消費
- **解決策**: 1次元DPテーブルを使用（前の行のみを保持）
- **実装**: `dp_prev`と`dp_curr`で管理
- **メリット**: 空間計算量をO(min(m,n))に削減

### 6. 操作の復元
- **問題**: 最小操作回数だけでなく、操作自体を取得する必要がある場合
- **解決策**: `parent`配列で親を記録
- **実装**: 各セルで、どの操作が選択されたかを記録
- **注意**: 操作の復元には追加の空間が必要

### 7. 重み付き編集距離
- **問題**: 各操作に異なるコストがある場合
- **解決策**: コストを考慮して最小値を計算
- **実装**: `min(削除コスト, 挿入コスト, 置換コスト)`
- **注意**: コストの設定が重要

### 8. エッジケースの処理
- **問題**: 空の文字列、同じ文字列、1文字の違い
- **解決策**: 各操作でエッジケースをチェック
- **実装**: `if not word1: return len(word2)`などのチェック
- **注意**: エッジケースを忘れると、エラーが発生

## 関連問題

- [Longest Increasing Subsequence](./longest_increasing_subsequence_logic.md) - 部分列の問題
- [Coin Change](./coin_change_logic.md) - 最適化問題
- [Longest Common Subsequence](./longest_common_subsequence_logic.md) - 共通部分列
- [One Edit Distance](../leetcode/medium/) - 編集距離1の判定

---

**次のステップ**: [Coin Change](./coin_change_logic.md)でコインの組み合わせを学ぶ

