# 区間DP (Interval DP) - ロジック解説

## 問題概要

区間DPは、**配列や文字列の連続する部分区間に関する最適化問題**を解く動的計画法のパターンです。`dp[i][j]`が区間`[i, j]`に関する最適解を表し、より小さな区間の結果を組み合わせて解を構築します。回文、括弧のマッチング、行列の連鎖積などで使用されます。

**例**: 最長回文部分列
```
文字列: "bbbab"
最長回文部分列: "bbbb" (長さ4)
```

## ロジックの核心

### なぜ区間DPが有効か？

**全探索（O(2^n)）**:
- 全ての可能な部分列を試す
- 時間計算量: 指数時間 - 非効率

**区間DPを使う理由**:
- **部分区間の再利用**: 小さな区間の結果を組み合わせ
- **時間計算量**: O(n²) または O(n³) - 多項式時間
- **空間計算量**: O(n²) - 2次元DPテーブル

### アルゴリズムのステップ

#### 基本的な構造

```
function intervalDP(array):
    n = len(array)
    dp = [[0] * n for _ in range(n)]
    
    // 長さ1の区間の初期化
    for i in range(n):
        dp[i][i] = base_case
    
    // 区間の長さを2からnまで
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            
            // 区間[i, j]の最適解を計算
            for k in range(i, j):
                dp[i][j] = max/min(
                    dp[i][j],
                    combine(dp[i][k], dp[k+1][j])
                )
    
    return dp[0][n-1]
```

### 具体例でのトレース

#### 例1: 最長回文部分列

**文字列**: "bbbab"

**DPテーブルの構築**:
```
長さ1の区間:
dp[0][0] = 1  // "b"
dp[1][1] = 1  // "b"
dp[2][2] = 1  // "b"
dp[3][3] = 1  // "a"
dp[4][4] = 1  // "b"

長さ2の区間:
dp[0][1]: s[0]='b', s[1]='b' → 同じ → dp[0][1] = 2
dp[1][2]: s[1]='b', s[2]='b' → 同じ → dp[1][2] = 2
dp[2][3]: s[2]='b', s[3]='a' → 異なる → dp[2][3] = max(dp[2][2], dp[3][3]) = 1
dp[3][4]: s[3]='a', s[4]='b' → 異なる → dp[3][4] = max(dp[3][3], dp[4][4]) = 1

長さ3の区間:
dp[0][2]: s[0]='b', s[2]='b' → 同じ → dp[0][2] = dp[1][1] + 2 = 3
dp[1][3]: s[1]='b', s[3]='a' → 異なる → dp[1][3] = max(dp[1][2], dp[2][3]) = 2
dp[2][4]: s[2]='b', s[4]='b' → 同じ → dp[2][4] = dp[3][3] + 2 = 3

長さ4の区間:
dp[0][3]: s[0]='b', s[3]='a' → 異なる → dp[0][3] = max(dp[0][2], dp[1][3]) = 3
dp[1][4]: s[1]='b', s[4]='b' → 同じ → dp[1][4] = dp[2][3] + 2 = 3

長さ5の区間:
dp[0][4]: s[0]='b', s[4]='b' → 同じ → dp[0][4] = dp[1][3] + 2 = 4

最終結果: dp[0][4] = 4
```

#### 例2: 行列の連鎖積

**問題**: 行列の連鎖A₁×A₂×...×Aₙの最小計算コスト

**行列のサイズ**: A₁(10×30), A₂(30×5), A₃(5×60)

**DPテーブルの構築**:
```
dp[i][j] = 区間[i, j]の最小計算コスト

長さ1の区間:
dp[0][0] = 0
dp[1][1] = 0
dp[2][2] = 0

長さ2の区間:
dp[0][1]: A₀×A₁
  コスト = 10×30×5 = 1500
dp[1][2]: A₁×A₂
  コスト = 30×5×60 = 9000

長さ3の区間:
dp[0][2]: (A₀×A₁)×A₂ または A₀×(A₁×A₂)
  分割点k=1:
    (A₀×A₁)×A₂: dp[0][1] + dp[2][2] + 10×5×60 = 1500 + 0 + 3000 = 4500
    A₀×(A₁×A₂): dp[0][0] + dp[1][2] + 10×30×60 = 0 + 9000 + 18000 = 27000
  dp[0][2] = min(4500, 27000) = 4500

最終結果: dp[0][2] = 4500
```

## 現実世界での応用

### 1. 回文の問題
- **シナリオ**: 文字列の最長回文部分列を求める
- **実装**: 区間DPで回文を検出
- **メリット**: 効率的な回文検出

### 2. 括弧のマッチング
- **シナリオ**: 括弧の最大マッチング数を求める
- **実装**: 区間DPで括弧をマッチング
- **メリット**: 効率的な括弧マッチング

### 3. 行列の連鎖積
- **シナリオ**: 行列の連鎖積の最小計算コストを求める
- **実装**: 区間DPで最適な分割点を見つける
- **メリット**: 効率的な行列計算

### 4. 石取りゲーム
- **シナリオ**: 2人が交互に石を取り、得点を最大化
- **実装**: 区間DPで最適戦略を計算
- **メリット**: ゲーム理論の応用

### 5. 文字列の編集距離
- **シナリオ**: 2つの文字列の編集距離を計算
- **実装**: 区間DPで編集距離を計算
- **メリット**: 効率的な文字列比較

### 6. 最適な分割
- **シナリオ**: 配列を最適に分割してコストを最小化
- **実装**: 区間DPで最適な分割点を見つける
- **メリット**: 効率的な分割アルゴリズム

## 注意点と落とし穴

### 1. 区間の長さの順序
- **問題**: 区間の長さを小さい順に処理する必要がある
- **解決策**: 外側のループで長さを2からnまで
- **実装**: `for length in range(2, n + 1):`
- **注意**: 順序を間違えると正しい結果が得られない

### 2. インデックスの範囲
- **問題**: インデックスの範囲を正確に管理
- **解決策**: `j = i + length - 1`で終点を計算
- **実装**: 範囲外アクセスを避ける
- **注意**: インデックスエラーに注意

### 3. ベースケースの初期化
- **問題**: 長さ1の区間を適切に初期化
- **解決策**: `dp[i][i] = base_case`で初期化
- **実装**: 問題に応じて適切な値を設定
- **注意**: ベースケースを間違えると結果が間違う

### 4. 分割点の選択
- **問題**: 区間をどこで分割するかが重要
- **解決策**: 全ての可能な分割点を試す
- **実装**: `for k in range(i, j):`で分割点を試す
- **注意**: 分割点を漏らさない

### 5. 遷移式の構築
- **問題**: 小さな区間の結果を組み合わせる方法
- **解決策**: 問題に応じて適切な演算を選択
- **実装**: `max`, `min`, `sum`など
- **注意**: 遷移式を間違えると結果が間違う

### 6. メモリ使用量
- **問題**: O(n²)のメモリが必要
- **解決策**: 必要に応じて空間最適化
- **実装**: 一部の問題では1次元DPに最適化可能
- **注意**: メモリ制約がある場合は注意

### 7. 時間計算量
- **問題**: O(n³)になる場合がある
- **解決策**: 分割点の探索を最適化
- **実装**: モノトニック性を利用して最適化
- **注意**: 時間制約がある場合は最適化が必要

## 関連問題

- [Longest Palindromic Subsequence](../leetcode/medium/) - 回文の問題
- [Matrix Chain Multiplication](../leetcode/hard/) - 行列の連-chain積
- [Burst Balloons](../leetcode/hard/) - 区間DPの応用
- [Edit Distance](./edit_distance_logic.md) - 文字列DP

---

**次のステップ**: [ビットDP](./bit_dp_logic.md)でビットマスクを使ったDPを学ぶ

