# Unique Paths - ロジック解説

## 問題概要

m×nのグリッドが与えられたとき、左上から右下への経路の数を返す。右または下にのみ移動できる。

**制約**:
- `1 <= m, n <= 100`

**例**:
```
Input: m = 3, n = 7
Output: 28
説明: 左上から右下への経路は28通り
```

## ロジックの核心

### なぜ動的計画法が有効か？

**全探索（O(2^(m+n))）**:
- 全ての可能な経路を探索
- 時間計算量: 指数時間 - 非効率

**動的計画法を使う理由**:
- **部分問題の重複**: 同じ位置への経路が複数回計算される
- **時間計算量**: O(m×n) - 各セルを1回ずつ処理
- **空間計算量**: O(m×n) - 2次元DPテーブル

### 思考プロセス

1. **状態の定義**: `dp[i][j]` = 位置(i,j)への経路の数
2. **遷移**: `dp[i][j] = dp[i-1][j] + dp[i][j-1]`（上と左からの経路の和）
3. **結果**: `dp[m-1][n-1]`が答え

### アルゴリズムのステップ

```
function uniquePaths(m, n):
    dp = [[0] * n for _ in range(m)]
    
    // ベースケース: 最初の行と列は1
    for i in range(m):
        dp[i][0] = 1
    for j in range(n):
        dp[0][j] = 1
    
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    
    return dp[m-1][n-1]
```

## 具体例でのトレース

### 例: `m = 3, n = 3`

```
初期状態:
  dp[0][*] = [1,1,1]
  dp[*][0] = [1,1,1]

i=1, j=1:
  dp[1][1] = dp[0][1] + dp[1][0] = 1 + 1 = 2

i=1, j=2:
  dp[1][2] = dp[0][2] + dp[1][1] = 1 + 2 = 3

i=2, j=1:
  dp[2][1] = dp[1][1] + dp[2][0] = 2 + 1 = 3

i=2, j=2:
  dp[2][2] = dp[1][2] + dp[2][1] = 3 + 3 = 6

結果: 6
```

## 現実世界での応用

### 1. ロボットの経路計画
- **シナリオ**: ロボットがグリッド上を移動する経路を計画
- **実装**: Unique Pathsで経路の数を計算
- **メリット**: 効率的な経路計画

### 2. ゲーム開発
- **シナリオ**: ゲームで、キャラクターの移動経路を計算
- **実装**: Unique Pathsで経路の数を計算
- **メリット**: 効率的なゲーム処理

### 3. ネットワークルーティング
- **シナリオ**: ネットワークで、パケットの経路を計算
- **実装**: Unique Pathsで経路の数を計算
- **メリット**: 効率的なルーティング

### 4. 物流システム
- **シナリオ**: 物流で、配送経路を計算
- **実装**: Unique Pathsで経路の数を計算
- **メリット**: 効率的な物流管理

### 5. 画像処理
- **シナリオ**: 画像処理で、ピクセルの経路を計算
- **実装**: Unique Pathsで経路の数を計算
- **メリット**: 効率的な画像処理

### 6. データ分析
- **シナリオ**: データ分析で、データの経路を計算
- **実装**: Unique Pathsで経路の数を計算
- **メリット**: 効率的なデータ分析

## 注意点と落とし穴

### 1. ベースケースの設定
- **問題**: 最初の行と列は1通りの経路のみ
- **解決策**: `dp[i][0] = 1`と`dp[0][j] = 1`で設定
- **実装**: 最初の行と列を1で初期化
- **注意**: ベースケースを忘れると、誤った結果が返される

### 2. 組み合わせ数学との関係
- **問題**: この問題は組み合わせ数学で解ける
- **解決策**: C(m+n-2, m-1) = (m+n-2)! / ((m-1)! × (n-1)!)
- **実装**: 組み合わせ計算でO(min(m,n))時間
- **注意**: 大きな値でオーバーフローに注意

### 3. 時間計算量の理解
- **平均**: O(m×n) - 各セルを1回ずつ処理
- **最悪**: O(m×n) - 常に同じ時間計算量
- **空間**: O(m×n) - 2次元DPテーブル
- **最適化**: 空間をO(min(m,n))に削減可能

### 4. 空間最適化
- **問題**: 2次元DPテーブルでメモリを大量に消費
- **解決策**: 1次元DPテーブルを使用（前の行のみを保持）
- **実装**: `dp[j] = dp[j] + dp[j-1]`で更新
- **メリット**: 空間計算量をO(min(m,n))に削減

### 5. 障害物がある場合
- **問題**: グリッドに障害物がある場合（Unique Paths II）
- **解決策**: 障害物のセルは0通り
- **実装**: `if obstacleGrid[i][j] == 1: dp[i][j] = 0`
- **注意**: 障害物の処理が重要

### 6. エッジケースの処理
- **問題**: m=1またはn=1の場合、経路は1通り
- **解決策**: 各操作でエッジケースをチェック
- **実装**: `if m == 1 or n == 1: return 1`などのチェック
- **注意**: エッジケースを忘れると、エラーが発生

### 7. オーバーフローの注意
- **問題**: 大きなm,nで経路の数がオーバーフローする可能性
- **解決策**: 言語によっては大きな整数型を使用
- **実装**: Pythonでは自動的に大きな整数を扱える
- **注意**: 他の言語では注意が必要

### 8. 経路の復元
- **問題**: 経路の数だけでなく、経路自体を取得する必要がある場合
- **解決策**: DPテーブルを逆に辿って経路を復元
- **実装**: `parent[i][j]`で親を記録
- **注意**: 経路の復元には追加の空間が必要

## 関連問題

- [Unique Paths II](../leetcode/medium/) - 障害物がある場合
- [Minimum Path Sum](../leetcode/medium/) - 最小コストの経路
- [Longest Increasing Subsequence](./longest_increasing_subsequence_logic.md) - 部分列の問題
- [Climbing Stairs](./climbing_stairs_logic.md) - 1次元版

---

**次のステップ**: [Treeテクニック](../09_tree_traversal/README.md)で木の問題を学ぶ

