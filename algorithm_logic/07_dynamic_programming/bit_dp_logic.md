# ビットDP (Bit DP) - ロジック解説

## 問題概要

ビットDPは、**集合をビットマスクで表現し、部分集合に関する最適化問題**を解く動的計画法のパターンです。`dp[mask]`が集合`mask`に関する最適解を表し、O(2^n × n)やO(3^n)で解を計算します。巡回セールスマン問題、集合被覆問題、順列の問題などで使用されます。

**例**: 巡回セールスマン問題
```
都市: 0, 1, 2, 3
距離行列:
    0  1  2  3
0   0  2  9  5
1   2  0  6  3
2   9  6  0  7
3   5  3  7  0

最短経路: 0→1→3→2→0 (コスト: 2+3+7+9=21)
```

## ロジックの核心

### なぜビットDPが有効か？

**全探索（O(n!)）**:
- 全ての可能な順列を試す
- 時間計算量: 階乗時間 - 非効率

**ビットDPを使う理由**:
- **集合の表現**: ビットマスクで集合を効率的に表現
- **時間計算量**: O(2^n × n) または O(3^n) - 指数時間だが実用的
- **空間計算量**: O(2^n) - ビットマスクの数

### アルゴリズムのステップ

#### 基本的な構造

```
function bitDP(n, costs):
    // dp[mask][last] = maskの集合を訪問し、最後にlastにいる場合の最小コスト
    dp = [[float('inf')] * n for _ in range(1 << n)]
    
    // 初期状態: 各都市から開始
    for i in range(n):
        dp[1 << i][i] = 0
    
    // 全ての可能な集合を試す
    for mask in range(1 << n):
        for last in range(n):
            if dp[mask][last] == float('inf'):
                continue
            
            // 次の都市を選択
            for next_city in range(n):
                if mask & (1 << next_city):  // 既に訪問済み
                    continue
                
                new_mask = mask | (1 << next_city)
                dp[new_mask][next_city] = min(
                    dp[new_mask][next_city],
                    dp[mask][last] + costs[last][next_city]
                )
    
    // 全ての都市を訪問した場合の最小コスト
    result = float('inf')
    for last in range(n):
        result = min(result, dp[(1 << n) - 1][last])
    
    return result
```

### 具体例でのトレース

#### 例: 巡回セールスマン問題（4都市）

**距離行列**:
```
    0  1  2  3
0   0  2  9  5
1   2  0  6  3
2   9  6  0  7
3   5  3  7  0
```

**DPテーブルの構築**:
```
初期状態:
dp[0001][0] = 0  // 都市0から開始
dp[0010][1] = 0  // 都市1から開始
dp[0100][2] = 0  // 都市2から開始
dp[1000][3] = 0  // 都市3から開始

mask=0001 (都市0を訪問):
  last=0:
    next=1: dp[0011][1] = min(inf, 0+2) = 2
    next=2: dp[0101][2] = min(inf, 0+9) = 9
    next=3: dp[1001][3] = min(inf, 0+5) = 5

mask=0011 (都市0,1を訪問):
  last=1:
    next=2: dp[0111][2] = min(inf, 2+6) = 8
    next=3: dp[1011][3] = min(inf, 2+3) = 5

mask=0111 (都市0,1,2を訪問):
  last=2:
    next=3: dp[1111][3] = min(inf, 8+7) = 15

mask=1011 (都市0,1,3を訪問):
  last=3:
    next=2: dp[1111][2] = min(inf, 5+7) = 12

mask=1111 (全都市を訪問):
  last=2: コスト = 15
  last=3: コスト = 12
  → 最小コスト = 12

経路の復元:
  1111, last=3 → 1011, last=1 → 0011, last=0 → 0001, last=0
  経路: 0→1→3→2→0 (コスト: 2+3+7+0=12)
```

#### 例2: 集合被覆問題

**問題**: 最小の集合で全ての要素をカバー

**集合**: 
- S₀ = {0, 1}
- S₁ = {1, 2}
- S₂ = {2, 3}
- S₃ = {0, 3}

**DPテーブルの構築**:
```
dp[mask] = maskの要素をカバーする最小集合数

初期状態:
dp[0000] = 0  // 空集合

mask=0000:
  S₀を追加: new_mask = 0000 | 0011 = 0011
    dp[0011] = min(inf, 0+1) = 1
  S₁を追加: new_mask = 0000 | 0110 = 0110
    dp[0110] = min(inf, 0+1) = 1
  S₂を追加: new_mask = 0000 | 1100 = 1100
    dp[1100] = min(inf, 0+1) = 1
  S₃を追加: new_mask = 0000 | 1001 = 1001
    dp[1001] = min(inf, 0+1) = 1

mask=0011:
  S₁を追加: new_mask = 0011 | 0110 = 0111
    dp[0111] = min(inf, 1+1) = 2
  S₂を追加: new_mask = 0011 | 1100 = 1111
    dp[1111] = min(inf, 1+1) = 2
  S₃を追加: new_mask = 0011 | 1001 = 1011
    dp[1011] = min(inf, 1+1) = 2

最終結果: dp[1111] = 2
  集合: {S₀, S₂} または {S₁, S₃}
```

## 現実世界での応用

### 1. 巡回セールスマン問題
- **シナリオ**: 複数の都市を最短経路で訪問
- **実装**: ビットDPで最適経路を計算
- **メリット**: 効率的な経路最適化

### 2. 集合被覆問題
- **シナリオ**: 最小の集合で全ての要素をカバー
- **実装**: ビットDPで最適な集合を選択
- **メリット**: 効率的な集合選択

### 3. 順列の問題
- **シナリオ**: 条件を満たす順列の数を数える
- **実装**: ビットDPで順列を生成
- **メリット**: 効率的な順列生成

### 4. ゲーム理論
- **シナリオ**: 2人ゲームの最適戦略
- **実装**: ビットDPでゲーム状態を管理
- **メリット**: 効率的なゲーム解析

### 5. スケジューリング
- **シナリオ**: タスクの最適なスケジューリング
- **実装**: ビットDPでタスクの組み合わせを最適化
- **メリット**: 効率的なスケジューリング

### 6. グラフの問題
- **シナリオ**: ハミルトン経路の検出
- **実装**: ビットDPで経路を探索
- **メリット**: 効率的な経路探索

## 注意点と落とし穴

### 1. ビットマスクの操作
- **問題**: ビット演算を正確に理解する必要がある
- **解決策**: 
  - 集合に追加: `mask | (1 << i)`
  - 集合から削除: `mask & ~(1 << i)`
  - 要素の確認: `mask & (1 << i)`
- **実装**: ビット演算を正確に使用
- **注意**: ビット演算を間違えると結果が間違う

### 2. 状態の定義
- **問題**: DPテーブルの次元と意味を明確に定義
- **解決策**: `dp[mask][last]`など、状態を明確に定義
- **実装**: 問題に応じて適切な次元を選択
- **注意**: 状態の定義を間違えると結果が間違う

### 3. 初期状態の設定
- **問題**: 初期状態を適切に設定
- **解決策**: 空集合や単一要素から開始
- **実装**: `dp[1 << i][i] = 0`など
- **注意**: 初期状態を間違えると結果が間違う

### 4. メモリ使用量
- **問題**: O(2^n)のメモリが必要
- **解決策**: nが大きい場合はメモ化再帰を使用
- **実装**: 必要な状態のみを計算
- **注意**: メモリ制約がある場合は注意

### 5. 時間計算量
- **問題**: O(2^n × n)やO(3^n)になる
- **解決策**: nが小さい場合（n ≤ 20）に使用
- **実装**: 問題の制約を確認
- **注意**: nが大きい場合は他のアプローチを検討

### 6. 遷移の順序
- **問題**: 状態の遷移順序が重要
- **解決策**: 小さい集合から大きい集合へ
- **実装**: `for mask in range(1 << n):`
- **注意**: 順序を間違えると正しい結果が得られない

### 7. 経路の復元
- **問題**: 最適解だけでなく経路も必要
- **解決策**: 親ポインタを保存
- **実装**: `parent[mask][last]`で前の状態を記録
- **注意**: 経路の復元が必要な場合は親ポインタを追加

## 関連問題

- [Traveling Salesman Problem](../leetcode/hard/) - 巡回セールスマン問題
- [Partition to K Equal Sum Subsets](../leetcode/medium/) - 集合分割
- [Count Arrangements](../leetcode/hard/) - 順列の問題

---

**次のステップ**: [木DP](./tree_dp_logic.md)で木構造でのDPを学ぶ

