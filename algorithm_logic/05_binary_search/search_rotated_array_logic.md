# Search in Rotated Sorted Array - ロジック解説

## 問題概要

回転されたソート済み配列`nums`と整数`target`が与えられたとき、`target`が存在する場合はそのインデックスを返し、存在しない場合は`-1`を返す。

**回転の定義**: 配列が回転されているとは、元の配列`[0,1,2,4,5,6,7]`が、例えば`[4,5,6,7,0,1,2]`のように回転されていることを意味する。

**制約**:
- `1 <= nums.length <= 5000`
- `-10^4 <= nums[i], target <= 10^4`
- `nums`の全ての値は一意
- `nums`は回転前は昇順にソートされていた

**例**:
```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

## ロジックの核心

### なぜ修正された二分探索が有効か？

**素朴なアプローチ（O(n)）**:
- 配列を線形探索
- 時間計算量: O(n) - 回転を考慮する必要がないが非効率

**修正された二分探索を使う理由**:
- **回転点の検出**: 配列の半分がソートされていることを利用
- **条件分岐**: どちらの半分がソートされているかを判定し、適切な半分を選択
- **時間計算量**: O(log n) - 通常の二分探索と同様の効率

### 思考プロセス

1. **回転の理解**: 配列は2つのソート済み部分に分かれている
   - 左半分: `[4,5,6,7]` - ソート済み
   - 右半分: `[0,1,2]` - ソート済み

2. **中央要素の確認**: `nums[mid]`を確認
3. **どちらの半分がソートされているか判定**:
   - `nums[left] <= nums[mid]`: 左半分がソート済み
   - そうでなければ: 右半分がソート済み

4. **ターゲットの位置を判定**:
   - ソート済みの半分内に`target`があるか確認
   - あればその半分を探索、なければもう一方の半分を探索

### アルゴリズムのステップ

```
1. left = 0、right = len(nums) - 1 を初期化
2. left <= right の間、以下を繰り返す:
   a. mid = (left + right) // 2 を計算
   b. nums[mid] == target なら mid を返す
   c. 左半分がソート済みか判定: nums[left] <= nums[mid]
      - 左半分がソート済みの場合:
        * nums[left] <= target < nums[mid] なら右半分を探索 (right = mid - 1)
        * そうでなければ左半分を探索 (left = mid + 1)
      - 右半分がソート済みの場合:
        * nums[mid] < target <= nums[right] なら左半分を探索 (left = mid + 1)
        * そうでなければ右半分を探索 (right = mid - 1)
3. ループが終了したら -1 を返す
```

### 疑似コード

```
function search(nums, target):
    left = 0
    right = len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] == target:
            return mid
        
        // 左半分がソート済みか判定
        if nums[left] <= nums[mid]:
            // 左半分がソート済み
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            // 右半分がソート済み
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return -1
```

## 具体例でのトレース

### 例1: `nums = [4,5,6,7,0,1,2], target = 0`

| ステップ | left | right | mid | nums[mid] | ソート済み | 判定 | アクション |
|---------|------|-------|-----|-----------|-----------|------|-----------|
| 初期 | 0 | 6 | - | - | - | - | - |
| 1 | 0 | 6 | 3 | 7 | 左半分 | 0不在 | left = 4 |
| 2 | 4 | 6 | 5 | 1 | 右半分 | 0不在 | right = 4 |
| 3 | 4 | 4 | 4 | 0 | - | 0 == 0 | **4を返す** |

**結果**: `4` ✓

### 可視化

```
配列: [4, 5, 6, 7, 0, 1, 2]
インデックス: 0  1  2  3  4  5  6
target: 0

回転点: インデックス4（値0）

ステップ1: left=0, right=6, mid=3
  nums[3] = 7
  左半分[0-3]がソート済み: [4,5,6,7]
  0は[4,7]の範囲外 → 右半分を探索
  探索範囲: [0,1,2]

ステップ2: left=4, right=6, mid=5
  nums[5] = 1
  右半分[4-6]がソート済み: [0,1,2]
  0は[0,2]の範囲内だが、1より小さい → 左半分を探索
  探索範囲: [0]

ステップ3: left=4, right=4, mid=4
  nums[4] = 0 == 0 → 見つかった！
  結果: 4
```

### 例2: `nums = [4,5,6,7,0,1,2], target = 3`

| ステップ | left | right | mid | nums[mid] | ソート済み | 判定 | アクション |
|---------|------|-------|-----|-----------|-----------|------|-----------|
| 初期 | 0 | 6 | - | - | - | - | - |
| 1 | 0 | 6 | 3 | 7 | 左半分 | 3不在 | left = 4 |
| 2 | 4 | 6 | 5 | 1 | 右半分 | 3不在 | left = 6 |
| 3 | 6 | 6 | 6 | 2 | 右半分 | 3不在 | left = 7 |
| 終了 | 7 | 6 | - | - | - | - | **-1を返す** |

**結果**: `-1` - 見つからなかった

## 現実世界での応用

### 1. 時系列データの検索
- **シナリオ**: 回転された時系列データ（例: 1年のデータが途中から始まる）から特定の値を検索
- **実装**: 回転点を考慮しながら二分探索で検索
- **例**: ログファイルがローテーションされた後、特定のタイムスタンプを検索

### 2. 循環バッファの検索
- **シナリオ**: 循環バッファ（リングバッファ）内の要素を検索
- **実装**: 回転を考慮しながら二分探索で検索
- **例**: リングバッファ内のデータから、特定の値を検索

### 3. ローテーションファイルの検索
- **シナリオ**: ローテーションされたログファイルから特定のエントリを検索
- **実装**: 回転点を検出してから二分探索で検索
- **例**: サーバーログがローテーションされた後、特定のエントリを検索

### 4. ゲーム開発（スコアボード）
- **シナリオ**: 回転されたスコアボードから特定のスコアを検索
- **実装**: 回転を考慮しながら二分探索で検索
- **例**: ゲームのスコアボードが更新された後、特定のスコアの位置を検索

### 5. データベースのパーティション検索
- **シナリオ**: パーティションされたテーブルで、回転された順序でデータを検索
- **実装**: 回転点を考慮しながら二分探索で検索
- **例**: シャーディングされたデータベースで、特定のキーを検索

## 注意点と落とし穴

### 1. ソート済みの判定
- **問題**: どちらの半分がソート済みかを正確に判定する必要がある
- **解決策**: `nums[left] <= nums[mid]`で左半分がソート済みか判定
- **注意**: 等号（`<=`）を含めることが重要（`left == mid`の場合を考慮）

### 2. ターゲットの範囲判定
- **問題**: ソート済みの半分内に`target`があるかを正確に判定する必要がある
- **解決策**: 
  - 左半分がソート済み: `nums[left] <= target < nums[mid]`
  - 右半分がソート済み: `nums[mid] < target <= nums[right]`
- **注意**: 境界条件（`<=`と`<`）を正確に扱う

### 3. 回転点が存在しない場合
- **問題**: 配列が回転されていない場合（完全にソート済み）の処理
- **解決策**: アルゴリズムは回転されていない場合も正しく動作する
- **理由**: `nums[left] <= nums[mid]`が常に真になり、通常の二分探索と同じ動作

### 4. 重複要素の扱い
- **問題**: この問題では全ての値が一意と仮定されている
- **解決策**: 重複がある場合は、判定が複雑になる
- **注意**: 重複がある場合は、線形探索が必要になる場合がある

### 5. 時間計算量の理解
- **平均**: O(log n) - 各ステップで探索範囲が半分になる
- **最悪**: O(log n) - 常に対数時間
- **空間**: O(1) - 追加の空間は定数

### 6. 境界条件のテスト
- **問題**: 回転点が先頭や末尾にある場合の動作
- **解決策**: 様々な回転点でテストする
- **例**: 
  - 回転なし: `[0,1,2,3,4,5]`
  - 回転点が中央: `[3,4,5,0,1,2]`
  - 回転点が先頭: `[0,1,2,3,4,5]`（回転なし）
  - 回転点が末尾: `[5,0,1,2,3,4]`

## 関連問題

同じテクニック（回転済み配列での二分探索）を使う問題：

1. **Find Minimum in Rotated Sorted Array** - 回転済み配列の最小値を見つける
2. **Search in Rotated Sorted Array II** - 重複要素がある場合の検索
3. **Find Peak Element** - ピーク要素を探す（条件付き二分探索）
4. **Search a 2D Matrix** - 2次元配列での検索

## まとめ

Search in Rotated Sorted Arrayは、回転済み配列での二分探索の典型例です。重要なポイントは：

1. **回転の理解**: 配列は2つのソート済み部分に分かれている
2. **ソート済みの判定**: どちらの半分がソート済みかを判定
3. **条件分岐**: ソート済みの半分内に`target`があるかを判定して、適切な半分を選択
4. **O(log n)時間**: 通常の二分探索と同様の効率を維持

この問題を理解することで、回転済み配列での二分探索が身につきます。

---

**次のステップ**: 
- [二分探索のREADME](./README.md)に戻って他の問題も確認
- [動的計画法テクニック](../07_dynamic_programming/README.md) - 次のPhase 3のテクニック

