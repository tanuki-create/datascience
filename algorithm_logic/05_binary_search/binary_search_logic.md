# Binary Search - ロジック解説

## 問題概要

ソート済みの整数配列`nums`と整数`target`が与えられたとき、`target`が存在する場合はそのインデックスを返し、存在しない場合は`-1`を返す。

**制約**:
- `1 <= nums.length <= 10^4`
- `-10^4 < nums[i], target < 10^4`
- `nums`は昇順にソートされている
- 全ての要素は一意

**例**:
```
Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4

Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
```

## ロジックの核心

### なぜ二分探索が有効か？

**線形探索（O(n)）**:
- 配列を先頭から順に走査
- 時間計算量: O(n) - 最悪の場合、全ての要素をチェック

**二分探索を使う理由**:
- **ソート済みの活用**: ソート済みという性質を利用して、不要な半分を排除
- **対数的な時間**: 各ステップで探索範囲が半分になるため、O(log n)の時間計算量
- **効率的**: 大量のデータでも高速に検索可能

### 思考プロセス

1. **配列の中央を確認**: `mid = (left + right) // 2`
2. **比較**:
   - `nums[mid] == target`: 見つかった！
   - `nums[mid] < target`: 右半分を探索（`left = mid + 1`）
   - `nums[mid] > target`: 左半分を探索（`right = mid - 1`）
3. **繰り返し**: `left <= right`の間、上記を繰り返す
4. **見つからない場合**: ループが終了したら`-1`を返す

### アルゴリズムのステップ

```
1. left = 0、right = len(nums) - 1 を初期化
2. left <= right の間、以下を繰り返す:
   a. mid = (left + right) // 2 を計算
   b. nums[mid] == target なら mid を返す
   c. nums[mid] < target なら left = mid + 1
   d. nums[mid] > target なら right = mid - 1
3. ループが終了したら -1 を返す（見つからなかった）
```

### 疑似コード

```
function binarySearch(nums, target):
    left = 0
    right = len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1
```

## 具体例でのトレース

### 例1: `nums = [-1,0,3,5,9,12], target = 9`

| ステップ | left | right | mid | nums[mid] | 比較 | アクション |
|---------|------|-------|-----|-----------|------|-----------|
| 初期 | 0 | 5 | - | - | - | - |
| 1 | 0 | 5 | 2 | 3 | 3 < 9 | left = 3 |
| 2 | 3 | 5 | 4 | 9 | 9 == 9 | **4を返す** |

**結果**: `4` ✓

### 可視化

```
配列: [-1, 0, 3, 5, 9, 12]
インデックス: 0  1  2  3  4   5
target: 9

ステップ1: left=0, right=5, mid=2
  nums[2] = 3 < 9 → 右半分を探索
  探索範囲: [5, 9, 12]

ステップ2: left=3, right=5, mid=4
  nums[4] = 9 == 9 → 見つかった！
  結果: 4
```

### 例2: `nums = [-1,0,3,5,9,12], target = 2`

| ステップ | left | right | mid | nums[mid] | 比較 | アクション |
|---------|------|-------|-----|-----------|------|-----------|
| 初期 | 0 | 5 | - | - | - | - |
| 1 | 0 | 5 | 2 | 3 | 3 > 2 | right = 1 |
| 2 | 0 | 1 | 0 | -1 | -1 < 2 | left = 1 |
| 3 | 1 | 1 | 1 | 0 | 0 < 2 | left = 2 |
| 終了 | 2 | 1 | - | - | - | left > right → **-1を返す** |

**結果**: `-1` - 見つからなかった

### 可視化

```
配列: [-1, 0, 3, 5, 9, 12]
target: 2

ステップ1: left=0, right=5, mid=2
  nums[2] = 3 > 2 → 左半分を探索
  探索範囲: [-1, 0]

ステップ2: left=0, right=1, mid=0
  nums[0] = -1 < 2 → 右半分を探索
  探索範囲: [0]

ステップ3: left=1, right=1, mid=1
  nums[1] = 0 < 2 → left = 2

終了: left=2 > right=1 → 見つからなかった
結果: -1
```

## 現実世界での応用

### 1. データベースのインデックス検索
- **シナリオ**: B-treeインデックスでの主キー検索
- **実装**: データベースエンジンが内部的に二分探索を使用
- **例**: SQLクエリで`WHERE id = 123`を実行する際、インデックスから二分探索で検索

### 2. 辞書アプリケーション
- **シナリオ**: 単語の検索機能
- **実装**: ソート済みの単語リストから二分探索で検索
- **例**: 電子辞書で単語を検索する際、アルファベット順にソートされたリストから検索

### 3. ゲーム開発（当たり判定）
- **シナリオ**: ソート済みのオブジェクトリストから、特定範囲内のオブジェクトを検索
- **実装**: 二分探索で範囲の境界を特定
- **例**: 2Dゲームで、x座標でソートされたオブジェクトリストから、特定のx範囲内のオブジェクトを検索

### 4. 金融取引システム
- **シナリオ**: ソート済みの価格リストから、特定の価格帯の取引を検索
- **実装**: 二分探索で価格範囲を効率的に特定
- **例**: 株価データから、特定の価格帯の取引履歴を検索

### 5. コンパイラの最適化
- **シナリオ**: シンボルテーブルでの変数名の検索
- **実装**: ソート済みのシンボルテーブルから二分探索で検索
- **例**: コンパイラが変数名を検索する際、シンボルテーブルから二分探索で検索

## 注意点と落とし穴

### 1. オーバーフローの回避（重要）
- **問題**: `mid = (left + right) // 2`で、`left + right`がオーバーフローする可能性
- **解決策**: `mid = left + (right - left) // 2`を使用
- **理由**: `(right - left)`は`right`より小さいため、オーバーフローのリスクが低い
- **注意**: Pythonでは整数のオーバーフローはないが、他の言語（C++、Java）では重要
- **実装**: 常に`left + (right - left) // 2`を使用する習慣をつける

### 2. ループの終了条件の選択
- **問題**: `left <= right`と`left < right`のどちらを使うべきか？
- **解決策**: この問題では`left <= right`を使用
- **理由**: 要素が見つかるまで、または探索範囲がなくなるまで続ける
- **違い**: 
  - `left <= right`: 要素が見つかるまで続ける（この問題に適している）
  - `left < right`: 探索範囲が1要素になった時点で終了（挿入位置を探す場合に適している）
- **注意**: `left < right`を使うと、最後の要素をチェックしない可能性がある

### 3. 境界の更新の正確性
- **問題**: `left = mid + 1`と`right = mid - 1`で、`mid`を含めない理由
- **解決策**: `nums[mid]`は既にチェック済みなので、探索範囲から除外
- **理由**: `mid`を含めると無限ループになる可能性がある
- **例**: 
  - `left = 3, right = 4, mid = 3`
  - `nums[3] < target`の場合、`left = mid`とすると`left = 3`のまま（無限ループ）
  - `left = mid + 1`とすると`left = 4`となり、ループが進行

### 4. 空配列の扱い
- **問題**: 配列が空の場合、`right = -1`となり、ループが実行されない
- **解決策**: これは正しい動作（空配列では要素が見つからない）
- **確認**: `left = 0, right = -1`の場合、`left <= right`は`False`となり、ループは実行されない
- **注意**: 問題の要件に応じて、エラーハンドリングを追加する場合もある

### 5. 重複要素の扱い
- **問題**: 同じ値が複数回出現する場合、どの要素を返すべきか？
- **解決策**: この問題では「任意のインデックス」を返せばよい
- **拡張**: 
  - 最初の出現: `right = mid`（`mid`を含める）を使用
  - 最後の出現: `left = mid + 1`（`mid`を含めない）を使用し、最後に`left - 1`を返す
- **注意**: 最初/最後の出現を返す必要がある場合は、条件を調整する必要がある

### 6. 時間計算量の詳細な理解
- **平均**: O(log n) - 各ステップで探索範囲が半分になる
- **最悪**: O(log n) - 常に対数時間
- **空間**: O(1) - 追加の空間は定数（変数のみ）
- **比較**: 
  - 線形探索: O(n) - 最悪の場合、全ての要素をチェック
  - 二分探索: O(log n) - 常に対数時間
- **メリット**: 大きな配列では、二分探索が圧倒的に高速

### 7. ソートの前提条件とコスト
- **問題**: 配列がソート済みでない場合、二分探索は使えない
- **解決策**: 事前にソートする必要がある（O(n log n)のコスト）
- **トレードオフ**: 
  - 検索が1回だけ: 線形探索の方が効率的（O(n) vs O(n log n)）
  - 検索が複数回: ソートのコストを払っても二分探索が有利
- **判断**: 検索の回数と配列のサイズを考慮して選択

### 8. 整数除算の扱い
- **問題**: `(left + right) // 2`で、整数除算が正しく動作するか？
- **解決策**: Pythonでは`//`が整数除算（切り捨て）
- **注意**: 負の数の場合、`//`の動作を確認する必要がある
- **実装**: 通常は問題ないが、負の数が含まれる場合は注意

### 9. 要素が見つからない場合の処理
- **問題**: 要素が見つからない場合、`-1`を返す
- **解決策**: ループが終了したら`-1`を返す
- **拡張**: 挿入位置を返す場合は、`left`を返す（要素が挿入されるべき位置）
- **注意**: 問題の要件に応じて、返り値を変更する必要がある

## 関連問題

同じテクニック（二分探索）を使う問題：

1. **Search Insert Position** - 要素が見つからない場合の挿入位置を返す
2. **First Bad Version** - 条件を満たす最初の要素を探す
3. **Find Peak Element** - ピーク要素を探す（条件付き二分探索）
4. **Search in Rotated Sorted Array** - 回転済み配列での検索
5. **Find Minimum in Rotated Sorted Array** - 回転済み配列の最小値

## まとめ

Binary Searchは、二分探索の最も基本的な実装です。重要なポイントは：

1. **ソート済みの活用**: ソート済みという性質を利用して、不要な半分を排除
2. **対数的な時間**: O(log n)の時間計算量で高速に検索
3. **ループの終了条件**: `left <= right`で、要素が見つかるまで続ける
4. **境界の更新**: `mid`を含めずに更新することで、無限ループを防ぐ

この問題を理解することで、二分探索の基本が身につきます。

---

**次のステップ**: 
- [Search in Rotated Sorted Array](./search_rotated_array_logic.md)で、回転済み配列での二分探索を学ぶ
- [二分探索のREADME](./README.md)に戻って他の問題も確認

