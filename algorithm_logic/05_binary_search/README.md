# 二分探索 (Binary Search)

## 概要

二分探索は、**ソート済み配列**から特定の要素を効率的に検索するアルゴリズムです。線形探索のO(n)に対して、O(log n)の時間計算量を達成できる強力な手法です。

## 基本概念

### 二分探索の原理

1. **分割統治**: 配列を半分に分割し、どちらの半分に目的の要素があるかを判断
2. **ソート済みの活用**: ソート済みという性質を利用して、不要な半分を排除
3. **対数的な時間**: 各ステップで探索範囲が半分になるため、O(log n)の時間計算量

### 主な操作と計算量

| 操作 | 時間計算量 | 空間計算量 | 前提条件 |
|------|-----------|-----------|---------|
| 要素の検索 | O(log n) | O(1) | ソート済み配列 |
| 挿入位置の検索 | O(log n) | O(1) | ソート済み配列 |
| 範囲の検索 | O(log n) | O(1) | ソート済み配列 |

**特徴**: ソート済み配列に対して、非常に効率的な検索が可能。

## いつ使うべきか

二分探索は以下のような場面で威力を発揮します：

### 1. ソート済み配列での検索
- 「配列内に特定の値が存在するか？」
- 「配列内で特定の値の位置は？」
- **利点**: O(log n)で高速に検索可能

### 2. 境界の探索
- 「条件を満たす最小/最大の値は？」
- 「条件を満たす要素の範囲は？」
- **利点**: 境界を効率的に特定

### 3. 最適化問題
- 「条件を満たす最大/最小の値は？」
- 「条件を満たす解の存在確認」
- **利点**: 解の空間を効率的に探索

### 4. 回転済み配列
- 「回転されたソート済み配列で要素を検索」
- 「回転点を見つける」
- **利点**: 回転を考慮しながら効率的に検索

## 現実世界での応用例

### 1. データベースのインデックス検索
- **例**: B-treeインデックスでの検索
- **実装**: データベースエンジンが内部的に二分探索を使用
- **メリット**: 大量のデータからもO(log n)でアクセス可能

### 2. 辞書アプリケーション
- **例**: 単語の検索機能
- **実装**: ソート済みの単語リストから二分探索で検索
- **メリット**: 大量の単語からも高速に検索

### 3. ゲーム開発（当たり判定）
- **例**: ソート済みのオブジェクトリストから、特定範囲内のオブジェクトを検索
- **実装**: 二分探索で範囲の境界を特定
- **メリット**: 空間分割の効率化

### 4. 金融取引システム
- **例**: ソート済みの価格リストから、特定の価格帯の取引を検索
- **実装**: 二分探索で価格範囲を効率的に特定
- **メリット**: リアルタイム取引で高速な検索が必要な場合に有効

### 5. コンパイラの最適化
- **例**: シンボルテーブルでの変数名の検索
- **実装**: ソート済みのシンボルテーブルから二分探索で検索
- **メリット**: コード解析中に変数情報を高速に参照

## 実装時の注意点

### 1. オーバーフローの回避
- **問題**: `mid = (left + right) // 2`で、`left + right`がオーバーフローする可能性
- **解決策**: `mid = left + (right - left) // 2`を使用
- **注意**: Pythonでは整数のオーバーフローはないが、他の言語では重要

### 2. ループの終了条件
- **問題**: `left < right`と`left <= right`のどちらを使うべきか？
- **解決策**: 問題に応じて選択
  - `left < right`: 要素が見つからない場合の処理が異なる
  - `left <= right`: 要素が見つかるまで続ける
- **注意**: 無限ループを避けるため、必ず`left`または`right`を更新

### 3. 境界の扱い
- **問題**: 要素が見つからない場合、どのインデックスを返すべきか？
- **解決策**: 問題の要件に応じて選択
  - 挿入位置: 要素が挿入されるべき位置を返す
  - 存在確認: `-1`や`None`を返す
- **注意**: 境界条件を明確に定義する

### 4. 重複要素の扱い
- **問題**: 同じ値が複数回出現する場合、どの要素を返すべきか？
- **解決策**: 問題の要件に応じて選択
  - 最初の出現: `left`を更新する条件を調整
  - 最後の出現: `right`を更新する条件を調整
- **注意**: 問題文をよく読んで要件を確認

### 5. 回転済み配列の処理
- **問題**: 配列が回転している場合、通常の二分探索が使えない
- **解決策**: 回転点を見つけて、適切な半分を選択
- **注意**: 回転点の検出も二分探索で可能

## 関連するLeetCode/AtCoder問題

### Easy
- [Binary Search](./binary_search_logic.md) - 二分探索の基本
- [Search Insert Position](../leetcode/easy/) - 挿入位置の検索
- [First Bad Version](../leetcode/easy/) - 境界の探索

### Medium
- [Search in Rotated Sorted Array](./search_rotated_array_logic.md) - 回転済み配列での検索
- [Find First and Last Position](../leetcode/medium/) - 範囲の検索
- [Search a 2D Matrix](../leetcode/medium/) - 2次元配列での検索

### Hard
- [Median of Two Sorted Arrays](../leetcode/hard/) - 2つのソート済み配列の中央値
- [Find Minimum in Rotated Sorted Array](../leetcode/hard/) - 回転済み配列の最小値
- [Split Array Largest Sum](../leetcode/hard/) - 最適化問題への応用

## 学習の進め方

1. **Binary Search**から始める: 二分探索の最も基本的な実装
2. **Search in Rotated Sorted Array**で回転を学ぶ: より複雑な条件での二分探索
3. **最適化問題**で応用を学ぶ: 二分探索を最適化問題に適用

## 次のステップ

- [Binary Search のロジック解説](./binary_search_logic.md)
- [Search in Rotated Sorted Array のロジック解説](./search_rotated_array_logic.md)
- [動的計画法テクニック](../07_dynamic_programming/README.md) - 次のPhase 3のテクニック

---

**重要**: 二分探索は、ソート済み配列での検索をO(log n)に改善する強力な手法です。条件を満たす解を探す最適化問題にも応用できます。

