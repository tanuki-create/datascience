# Two Sum - ロジック解説

## 問題概要

配列`nums`と整数`target`が与えられたとき、合計が`target`になる2つの数のインデックスを返す。

**制約**:
- 各入力には正確に1つの解が存在する
- 同じ要素を2回使うことはできない
- 答えは任意の順序で返してよい

**例**:
```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
説明: nums[0] + nums[1] = 2 + 7 = 9
```

## ロジックの核心

### なぜハッシュテーブルが有効か？

**素朴なアプローチ（O(n²)）**:
- 全てのペアをチェック: `nums[i] + nums[j] == target` を全ての`i, j`で確認
- 時間計算量: O(n²) - 2重ループが必要

**ハッシュテーブルを使う理由**:
- 「補数（complement）が既に存在するか？」をO(1)で確認できる
- `target - nums[i]`が既にハッシュテーブルに存在すれば、答えが見つかった
- 時間計算量: O(n) - 1回のループで完了

### 思考プロセス

1. **目標の明確化**: `nums[i] + nums[j] = target` を満たす`i, j`を見つける
2. **式の変形**: `nums[j] = target - nums[i]` と書き換える
3. **補数の概念**: 各`nums[i]`に対して、その「補数」`target - nums[i]`を探す
4. **ハッシュテーブルの活用**: 既に見た要素をハッシュテーブルに保存し、補数の存在をO(1)で確認

### アルゴリズムのステップ

```
1. 空のハッシュテーブル（辞書）を作成: seen = {}
2. 配列を1回だけ走査:
   a. 現在の要素 nums[i] の補数を計算: complement = target - nums[i]
   b. 補数がハッシュテーブルに存在するか確認
   c. 存在すれば: [seen[complement], i] を返す（答えが見つかった）
   d. 存在しなければ: seen[nums[i]] = i として保存し、次の要素へ
3. ループが終了しても見つからなければ、解が存在しない（制約上は起こらない）
```

### 疑似コード

```
function twoSum(nums, target):
    seen = {}  // 値 -> インデックスのマッピング
    
    for i from 0 to len(nums) - 1:
        complement = target - nums[i]
        
        if complement in seen:
            return [seen[complement], i]
        
        seen[nums[i]] = i
    
    return []  // 解が見つからない（制約上は起こらない）
```

## 具体例でのトレース

### 例1: `nums = [2,7,11,15], target = 9`

| ステップ | i | nums[i] | complement (9 - nums[i]) | seen | アクション |
|---------|---|---------|-------------------------|------|-----------|
| 初期状態 | - | - | - | {} | - |
| 1 | 0 | 2 | 7 | {} | 7は存在しない → seen[2] = 0 |
| 2 | 1 | 7 | 2 | {2: 0} | 2が存在する！ → [0, 1]を返す |

**結果**: `[0, 1]` - `nums[0] + nums[1] = 2 + 7 = 9` ✓

### 例2: `nums = [3,2,4], target = 6`

| ステップ | i | nums[i] | complement (6 - nums[i]) | seen | アクション |
|---------|---|---------|-------------------------|------|-----------|
| 初期状態 | - | - | - | {} | - |
| 1 | 0 | 3 | 3 | {} | 3は存在しない → seen[3] = 0 |
| 2 | 1 | 2 | 4 | {3: 0} | 4は存在しない → seen[2] = 1 |
| 3 | 2 | 4 | 2 | {3: 0, 2: 1} | 2が存在する！ → [1, 2]を返す |

**結果**: `[1, 2]` - `nums[1] + nums[2] = 2 + 4 = 6` ✓

### 例3: `nums = [3,3], target = 6`

| ステップ | i | nums[i] | complement (6 - nums[i]) | seen | アクション |
|---------|---|---------|-------------------------|------|-----------|
| 初期状態 | - | - | - | {} | - |
| 1 | 0 | 3 | 3 | {} | 3は存在しない → seen[3] = 0 |
| 2 | 1 | 3 | 3 | {3: 0} | 3が存在する！ → [0, 1]を返す |

**結果**: `[0, 1]` - `nums[0] + nums[1] = 3 + 3 = 6` ✓

**重要なポイント**: 同じ値が複数回出現しても、最初に出現したインデックスがハッシュテーブルに保存されているため、2回目に同じ値を見たときに補数として認識できる。

## 現実世界での応用

### 1. 在庫管理システム
- **シナリオ**: 2つの商品の価格の合計が予算内か確認
- **実装**: 商品価格の配列から、予算に合う2つの商品の組み合わせを探す
- **例**: 1000円の予算で、価格リスト`[200, 300, 500, 800]`から合計1000円になる組み合わせを探す

### 2. 金融取引のマッチング
- **シナリオ**: 2つの取引の金額の合計が特定の値になる組み合わせを探す
- **実装**: 取引履歴から、合計が目標金額になる2つの取引を特定
- **例**: 100万円の資金調達のために、50万円と50万円の取引をマッチング

### 3. ゲーム開発（スコアシステム）
- **シナリオ**: 2つのアイテムのスコアの合計が目標スコアになる組み合わせを探す
- **実装**: アイテムスコアのリストから、目標スコアを達成する2つのアイテムを探す
- **例**: 100ポイントを獲得するために、スコアリスト`[20, 30, 50, 80]`から合計100になる組み合わせを探す

### 4. レコメンデーションシステム
- **シナリオ**: 2つの商品の価格の合計がユーザーの予算に合う組み合わせを推薦
- **実装**: 商品カタログから、予算内で購入できる2つの商品のペアを探す
- **例**: 5000円の予算で、商品価格リストから合計5000円になる2つの商品を推薦

## 注意点と落とし穴

### 1. 同じ要素を2回使えない
- **問題**: `nums[i] + nums[i] == target`の場合、同じインデックスを2回返してしまう可能性
- **解決策**: ハッシュテーブルに保存してから補数をチェックすることで、同じ要素を2回使うことを防ぐ
- **例**: `nums = [3, 2, 4], target = 6`の場合、`nums[0] = 3`を見た時点では`complement = 3`はまだ`seen`に存在しないため、`seen[3] = 0`を保存。次に`nums[1] = 2`を見た時点で`complement = 4`を探すが、まだ存在しない。最後に`nums[2] = 4`を見た時点で`complement = 2`が`seen`に存在するため、正しく`[1, 2]`を返す。

### 2. ハッシュテーブルの更新タイミング
- **問題**: 補数をチェックする前にハッシュテーブルを更新すると、同じ要素を2回使ってしまう
- **解決策**: **必ず補数をチェックしてから**ハッシュテーブルを更新する
- **正しい順序**: `if complement in seen` → `return` → `seen[nums[i]] = i`

### 3. インデックスの順序
- **問題**: 返すインデックスの順序が重要かどうか
- **解決策**: 問題文では「任意の順序で返してよい」とあるため、`[i, j]`でも`[j, i]`でも可
- **実装**: `[seen[complement], i]`の順序で返す（補数が先に見つかったインデックス、現在のインデックス）

### 4. 負の数や0の扱い
- **問題**: 負の数や0が含まれる場合の動作
- **解決策**: アルゴリズムは負の数や0にも対応可能（`target - nums[i]`の計算は問題なく動作）
- **例**: `nums = [-1, -2, -3, -4], target = -3`の場合、`nums[0] + nums[1] = -1 + (-2) = -3`が正しく見つかる

### 5. 時間計算量の理解
- **平均**: O(n) - ハッシュテーブルの操作は平均O(1)
- **最悪**: O(n) - ハッシュテーブルの衝突が最悪でもO(n)で処理される
- **空間**: O(n) - 最悪の場合、全ての要素をハッシュテーブルに保存

## 関連問題

同じテクニック（ハッシュテーブル）を使う問題：

1. **3Sum** - Two Sumを拡張して3つの要素を探す
2. **4Sum** - さらに拡張して4つの要素を探す
3. **Two Sum II - Input array is sorted** - ソート済み配列でのTwo Sum（二ポインタでも解ける）
4. **Contains Duplicate** - ハッシュテーブルで重複を検出
5. **Valid Anagram** - 文字の出現回数をハッシュテーブルで管理

## まとめ

Two Sumはハッシュテーブルの最も基本的な応用例です。重要なポイントは：

1. **補数の概念**: `target - nums[i]`を探すことで、2重ループを1重ループに削減
2. **O(1)の検索**: ハッシュテーブルを使うことで、補数の存在確認がO(1)で可能
3. **更新タイミング**: 補数をチェックしてからハッシュテーブルを更新することで、同じ要素を2回使うことを防ぐ

この問題を理解することで、ハッシュテーブルを使った他の問題にも応用できるようになります。

---

**次のステップ**: [Group Anagrams](./group_anagrams_logic.md)で、ハッシュテーブルを使ったグループ化のテクニックを学びましょう。

