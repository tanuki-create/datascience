# ハッシュテーブル (Hash Table)

## 概要

ハッシュテーブル（ハッシュマップ、辞書）は、キーと値のペアを効率的に保存・検索するデータ構造です。平均的に**O(1)**の時間計算量で要素の挿入、削除、検索が可能なため、アルゴリズム問題で最も頻繁に使用されるデータ構造の一つです。

## 基本概念

### ハッシュテーブルの仕組み

1. **ハッシュ関数**: キーを配列のインデックスに変換する関数
2. **バケット**: 実際にデータを格納する配列の要素
3. **衝突処理**: 異なるキーが同じインデックスにマッピングされた場合の処理方法

### 主な操作と計算量

| 操作 | 平均時間計算量 | 最悪時間計算量 | 空間計算量 |
|------|--------------|--------------|-----------|
| 検索 | O(1) | O(n) | O(n) |
| 挿入 | O(1) | O(n) | O(n) |
| 削除 | O(1) | O(n) | O(n) |

**注意**: 最悪時間計算量は衝突が頻繁に発生する場合（例：全てのキーが同じハッシュ値になる）にO(n)になりますが、実用的にはO(1)として扱えます。

## いつ使うべきか

ハッシュテーブルは以下のような場面で威力を発揮します：

### 1. 高速な検索が必要な場合
- 「この要素は存在するか？」をO(1)で確認
- 「このキーに対応する値は何か？」をO(1)で取得

### 2. 要素の出現回数をカウントする場合
- 文字列内の文字の出現頻度
- 配列内の要素の出現回数

### 3. 要素をグループ化する場合
- 同じ特性を持つ要素をまとめる
- アナグラムのグループ化

### 4. 補助データ構造として使用
- 他のアルゴリズムの補助として、中間結果を保存
- 訪問済みノードの記録（グラフ探索など）

## 現実世界での応用例

### 1. データベースのインデックス
- **例**: ユーザーIDからユーザー情報を高速に取得
- **実装**: データベースエンジンが内部的にハッシュテーブルを使用
- **メリット**: 大量のデータからもO(1)でアクセス可能

### 2. ブラウザのキャッシュ
- **例**: 訪問済みのWebページのURLを記録
- **実装**: URLをキー、ページ内容を値として保存
- **メリット**: 同じページへの再訪問を高速化

### 3. プログラミング言語の辞書型
- **例**: Pythonの`dict`、JavaScriptの`Map`、Javaの`HashMap`
- **実装**: 言語の標準ライブラリとして提供
- **メリット**: キーと値のペアを効率的に管理

### 4. コンパイラのシンボルテーブル
- **例**: 変数名から変数の情報（型、スコープなど）を取得
- **実装**: コンパイラが変数名をキーとして使用
- **メリット**: コード解析中に変数情報を高速に参照

### 5. セッション管理（Webアプリケーション）
- **例**: セッションIDからユーザーセッション情報を取得
- **実装**: セッションIDをキー、セッション情報を値として保存
- **メリット**: ユーザーの状態を効率的に管理

## 実装時の注意点

### 1. キーの型
- **可変オブジェクトは避ける**: リストや辞書をキーにすると、変更時にハッシュ値が変わり予期しない動作を引き起こす
- **推奨**: イミュータブルな型（文字列、数値、タプル）をキーに使用

### 2. 衝突の処理
- **チェイニング**: 同じインデックスに複数の要素を連結リストで保存
- **オープンアドレッシング**: 別の空きスロットを探す
- **実装の選択**: 言語の標準ライブラリが適切に処理してくれるため、通常は意識する必要がない

### 3. 空間計算量
- **メモリ使用量**: 要素数に比例してメモリを消費
- **リサイズ**: 要素数が増えると内部配列をリサイズする必要がある（通常は自動）
- **トレードオフ**: 時間計算量の改善と引き換えに空間計算量が増える

### 4. 順序の保持
- **Python 3.7+**: `dict`は挿入順序を保持
- **それ以前**: 順序が保証されない
- **注意**: 順序が重要な場合は`collections.OrderedDict`を使用

## 関連するLeetCode/AtCoder問題

### Easy
- [Two Sum](../leetcode/easy/001_two_sum/) - ハッシュテーブルの基本
- [Valid Anagram](../leetcode/easy/007_valid_anagram/) - 文字の出現回数カウント
- [Contains Duplicate](../leetcode/easy/) - 要素の存在確認

### Medium
- [Group Anagrams](./group_anagrams_logic.md) - グループ化の典型例
- [Longest Substring Without Repeating Characters](../03_sliding_window/longest_substring_no_repeat_logic.md) - スライディングウィンドウと組み合わせ
- [Find All Anagrams in String](../leetcode/easy/033_find_all_anagrams_in_string/) - パターンマッチング

### Hard
- [Minimum Window Substring](../03_sliding_window/) - 高度なスライディングウィンドウ
- [Substring with Concatenation of All Words](../leetcode/hard/) - 複雑な文字列マッチング

## 学習の進め方

1. **Two Sum**から始める: ハッシュテーブルの最も基本的な使い方を理解
2. **Group Anagrams**でグループ化を学ぶ: キーを工夫して要素を分類
3. **より複雑な問題**に挑戦: 他のテクニックと組み合わせた使用法を学ぶ

## 次のステップ

- [Two Sum のロジック解説](./two_sum_logic.md)
- [Group Anagrams のロジック解説](./group_anagrams_logic.md)
- [二ポインタテクニック](../02_two_pointers/README.md) - ハッシュテーブルと組み合わせて使用

---

**重要**: ハッシュテーブルは多くのアルゴリズムの基礎となるデータ構造です。まずはこのテクニックをしっかり理解することで、他の高度なアルゴリズムの理解も深まります。

