# Group Anagrams - ロジック解説

## 問題概要

文字列の配列`strs`が与えられたとき、アナグラム（文字を並び替えて作れる別の単語）をグループ化して返す。

**アナグラムの定義**: 文字を並び替えることで別の単語を作れる関係。例: "eat", "tea", "ate"は全てアナグラム。

**制約**:
- `1 <= strs.length <= 10^4`
- `0 <= strs[i].length <= 100`
- `strs[i]`は小文字の英字のみ

**例**:
```
Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

## ロジックの核心

### なぜハッシュテーブルが有効か？

**素朴なアプローチ（O(n² × m log m)）**:
- 全てのペアを比較: 各文字列を他の全ての文字列と比較
- アナグラム判定: 文字列をソートして比較（O(m log m)）
- 時間計算量: O(n² × m log m) - 非常に非効率

**ハッシュテーブルを使う理由**:
- **キーの工夫**: ソート済み文字列をキーとして使用することで、アナグラムを自動的にグループ化
- **1回の走査**: 各文字列を1回だけ処理すればよい
- **時間計算量**: O(n × m log m) - 各文字列をソートするだけ

### 思考プロセス

1. **アナグラムの特性**: アナグラムは、文字をソートすると同じ文字列になる
   - "eat" → ソート → "aet"
   - "tea" → ソート → "aet"
   - "ate" → ソート → "aet"
   - これらは全て同じキー"aet"を持つ

2. **キーの設計**: ソート済み文字列をキーとして使用
   - 同じアナグラムは必ず同じキーを持つ
   - 異なるアナグラムは異なるキーを持つ

3. **グループ化**: ハッシュテーブルで同じキーの文字列をまとめる
   - キー → 文字列のリストのマッピング

### アルゴリズムのステップ

```
1. 空のハッシュテーブルを作成: groups = {}
2. 各文字列を1回だけ走査:
   a. 文字列の文字をソート: sorted_str = sort(s)
   b. ソート済み文字列をキーとして使用
   c. キーが存在しなければ: groups[sorted_str] = [s]
   d. キーが存在すれば: groups[sorted_str].append(s)
3. ハッシュテーブルの全ての値をリストとして返す
```

### 疑似コード

```
function groupAnagrams(strs):
    groups = {}  // ソート済み文字列 -> 元の文字列のリスト
    
    for each s in strs:
        sorted_key = sort(s)  // 文字列をソートしてキーを作成
        
        if sorted_key not in groups:
            groups[sorted_key] = []
        
        groups[sorted_key].append(s)
    
    return list(groups.values())
```

## 具体例でのトレース

### 例: `strs = ["eat","tea","tan","ate","nat","bat"]`

| ステップ | 文字列 | ソート済みキー | groupsの状態 | アクション |
|---------|--------|---------------|-------------|-----------|
| 初期状態 | - | - | {} | - |
| 1 | "eat" | "aet" | {} | "aet"は存在しない → groups["aet"] = ["eat"] |
| 2 | "tea" | "aet" | {"aet": ["eat"]} | "aet"が存在 → groups["aet"].append("tea") |
| 3 | "tan" | "ant" | {"aet": ["eat","tea"]} | "ant"は存在しない → groups["ant"] = ["tan"] |
| 4 | "ate" | "aet" | {"aet": ["eat","tea"], "ant": ["tan"]} | "aet"が存在 → groups["aet"].append("ate") |
| 5 | "nat" | "ant" | {"aet": ["eat","tea","ate"], "ant": ["tan"]} | "ant"が存在 → groups["ant"].append("nat") |
| 6 | "bat" | "abt" | {"aet": ["eat","tea","ate"], "ant": ["tan","nat"]} | "abt"は存在しない → groups["abt"] = ["bat"] |

**最終的なgroups**:
```
{
    "aet": ["eat", "tea", "ate"],
    "ant": ["tan", "nat"],
    "abt": ["bat"]
}
```

**結果**: `[["eat","tea","ate"], ["tan","nat"], ["bat"]]`

### キーの可視化

```
"eat"  → ソート → "aet" ─┐
"tea"  → ソート → "aet" ─┼─→ 同じグループ ["eat","tea","ate"]
"ate"  → ソート → "aet" ─┘

"tan"  → ソート → "ant" ─┐
"nat"  → ソート → "ant" ─┼─→ 同じグループ ["tan","nat"]
                          ┘

"bat"  → ソート → "abt" ───→ 単独グループ ["bat"]
```

## 現実世界での応用

### 1. 辞書アプリケーション
- **シナリオ**: アナグラム検索機能
- **実装**: ユーザーが入力した文字列のアナグラムを検索
- **例**: "listen"を入力すると、"silent"などのアナグラムを表示

### 2. 単語ゲーム（スクラブル、クロスワード）
- **シナリオ**: 与えられた文字から作れる単語を全て見つける
- **実装**: 文字の組み合わせをソートして、辞書内のアナグラムと照合
- **例**: 文字"aet"から"eat", "tea", "ate"を作れることを検出

### 3. データベースのインデックス作成
- **シナリオ**: アナグラム検索を高速化するためのインデックス
- **実装**: 単語をソートした文字列をインデックスキーとして使用
- **例**: 全文検索エンジンで、アナグラムクエリを高速に処理

### 4. セキュリティ（パスワード解析）
- **シナリオ**: 辞書攻撃で、文字を並び替えたパスワードを試行
- **実装**: 既知のパスワードのアナグラムを生成して試行
- **注意**: これは攻撃手法の例であり、防御側の観点から理解することが重要

### 5. 自然言語処理
- **シナリオ**: テキスト内のアナグラムを検出
- **実装**: 文書内の単語をグループ化して、アナグラムのパターンを発見
- **例**: 文学作品で、作者が意図的にアナグラムを使っている箇所を発見

## 注意点と落とし穴

### 1. ソートのコスト
- **問題**: 各文字列をソートするのにO(m log m)の時間がかかる
- **影響**: 文字列が長い場合、ソートがボトルネックになる
- **最適化**: 文字の出現回数をカウントしてキーを作る方法もある（後述）

### 2. 空文字列の扱い
- **問題**: 空文字列`""`のソート結果は`""`（空文字列）
- **解決策**: 空文字列も通常の文字列として処理可能
- **例**: `strs = [""]`の場合、`groups[""] = [""]`となり、`[[""]]`を返す

### 3. 大文字・小文字の区別
- **問題**: 問題文では「小文字のみ」とあるが、実際の応用では大文字小文字の扱いが重要
- **解決策**: 必要に応じて全て小文字に変換してからソート
- **例**: "Eat"と"eat"は通常は異なる単語だが、アナグラムとして扱う場合は統一が必要

### 4. 文字コードの扱い（Unicode対応）
- **問題**: Unicode文字（日本語など）が含まれる場合のソート
- **解決策**: 言語の標準ソート機能を使用（通常は適切に処理される）
- **注意**: フォローアップ問題として「Unicode文字を含む場合はどうするか？」が問われることがある

### 5. メモリ使用量
- **問題**: 各文字列のソート済みコピーを保存するため、メモリ使用量が増える
- **影響**: 文字列が長い場合や、文字列数が多い場合にメモリが問題になる可能性
- **トレードオフ**: 時間計算量の改善と引き換えに空間計算量が増える

### 6. 代替アプローチ: 文字カウント

ソートの代わりに、文字の出現回数をカウントしてキーを作る方法：

```
function groupAnagrams(strs):
    groups = {}
    
    for each s in strs:
        count = [0] * 26  // 26文字分のカウント配列
        for char in s:
            count[ord(char) - ord('a')] += 1
        
        key = tuple(count)  // タプルに変換してキーとして使用
        
        if key not in groups:
            groups[key] = []
        groups[key].append(s)
    
    return list(groups.values())
```

**比較**:
- **ソート方式**: O(m log m) - シンプルだが、文字列が長いと遅い
- **カウント方式**: O(m) - 文字列が長い場合に有利だが、実装が複雑

**選択**: 通常はソート方式で十分。文字列が非常に長い場合のみカウント方式を検討。

## 関連問題

同じテクニック（ハッシュテーブル + キーの工夫）を使う問題：

1. **Valid Anagram** - 2つの文字列がアナグラムか判定
2. **Find All Anagrams in String** - 文字列内のアナグラムを全て見つける
3. **Group Shifted Strings** - シフトした文字列をグループ化（アナグラムの拡張）
4. **Isomorphic Strings** - 文字のマッピング関係をハッシュテーブルで管理

## まとめ

Group Anagramsは、ハッシュテーブルで**キーを工夫する**典型例です。重要なポイントは：

1. **キーの設計**: ソート済み文字列をキーとして使用することで、アナグラムを自動的にグループ化
2. **1回の走査**: 各文字列を1回だけ処理すればよい（O(n)の走査）
3. **時間計算量**: O(n × m log m) - 各文字列のソートがボトルネック
4. **空間計算量**: O(n × m) - 全ての文字列を保存

この問題を理解することで、ハッシュテーブルで「キーを工夫してグループ化する」テクニックが身につきます。

---

**次のステップ**: 
- [ハッシュテーブルのREADME](./README.md)に戻って他の問題も確認
- [二ポインタテクニック](../02_two_pointers/README.md)で、配列処理の別のアプローチを学ぶ

