# ヒープ (Heap / Priority Queue)

## 概要

ヒープ（優先度付きキュー）は、要素を優先度順に管理するデータ構造です。**最小値（または最大値）をO(1)で取得**し、**要素の挿入・削除をO(log n)で実行**できます。ダイクストラ法、トップK問題、マージソートなどで広く使用されています。

## 基本概念

### ヒープの種類

1. **最小ヒープ**: 親ノードが子ノードより小さい（または等しい）
2. **最大ヒープ**: 親ノードが子ノードより大きい（または等しい）

### 主な操作と計算量

| 操作 | 時間計算量 | 空間計算量 | 適用場面 |
|------|-----------|-----------|---------|
| 挿入 | O(log n) | O(n) | 要素の追加 |
| 最小値取得 | O(1) | O(1) | 最小値の取得 |
| 最小値削除 | O(log n) | O(1) | 最小値の削除 |
| ヒープ構築 | O(n) | O(n) | 配列からヒープを構築 |

**注意**: Pythonの`heapq`モジュールは最小ヒープを実装しています。最大ヒープが必要な場合は、値を負にして使用します。

## いつ使うべきか

ヒープは以下のような場面で威力を発揮します：

### 1. トップK問題
- K個の最大（最小）要素を見つける
- 頻度の高い要素を取得

### 2. ダイクストラ法
- 最短経路問題で、未訪問ノードから最小コストのノードを選択

### 3. マージK個のソート済みリスト
- 複数のソート済みリストを1つにマージ

### 4. スケジューリング
- 優先度の高いタスクを優先的に処理

### 5. メディアン（中央値）の追跡
- ストリーミングデータから動的に中央値を計算

## 現実世界での応用例

### 1. タスクスケジューラー
- **例**: OSのプロセススケジューラーで、優先度の高いプロセスを優先的に実行
- **実装**: プロセスの優先度をヒープで管理
- **メリット**: 効率的なリソース管理

### 2. ネットワークルーティング
- **例**: ルーターが、パケットの優先度に基づいて転送順序を決定
- **実装**: パケットの優先度をヒープで管理
- **メリット**: 重要なパケットを優先的に処理

### 3. イベント駆動システム
- **例**: ゲームエンジンで、イベントを時間順に処理
- **実装**: イベントのタイムスタンプをヒープで管理
- **メリット**: 時系列順のイベント処理

### 4. データストリームの分析
- **例**: リアルタイムデータから、トップKの要素を追跡
- **実装**: データをヒープで管理し、K個の最大（最小）要素を保持
- **メリット**: メモリ効率的なデータ分析

### 5. 医療システム
- **例**: 病院の救急外来で、患者の緊急度に基づいて診察順序を決定
- **実装**: 患者の緊急度をヒープで管理
- **メリット**: 緊急患者を優先的に診察

### 6. 金融取引システム
- **例**: 株式取引で、注文の優先度に基づいて処理順序を決定
- **実装**: 注文の優先度をヒープで管理
- **メリット**: 重要な注文を優先的に処理

## 実装時の注意点

### 1. 最小ヒープと最大ヒープ
- **問題**: Pythonの`heapq`は最小ヒープのみをサポート
- **解決策**: 最大ヒープが必要な場合、値を負にして使用
- **実装**: `heapq.heappush(heap, -value)`で最大ヒープを実現
- **注意**: 値を取得する際に、再度負にする必要がある

### 2. カスタム比較関数
- **問題**: 複雑なオブジェクトをヒープで管理する場合、比較方法を定義する必要がある
- **解決策**: `__lt__`メソッドを実装、またはタプルを使用
- **実装**: `(priority, item)`のタプルを使用
- **注意**: タプルの最初の要素で比較される

### 3. ヒープのサイズ制限
- **問題**: トップK問題で、ヒープのサイズをKに制限する必要がある
- **解決策**: ヒープのサイズがKを超えた場合、最小値を削除
- **実装**: `if len(heap) > k: heapq.heappop(heap)`
- **メリット**: メモリ使用量を削減

### 4. ヒープの構築
- **問題**: 配列からヒープを構築する場合、効率的な方法がある
- **解決策**: `heapq.heapify()`を使用（O(n)時間）
- **実装**: `heapq.heapify(arr)`で配列をヒープに変換
- **注意**: 既存の配列を直接変更する

### 5. 空のヒープの処理
- **問題**: 空のヒープから要素を取得しようとするとエラーが発生
- **解決策**: ヒープが空かどうかをチェック
- **実装**: `if heap: value = heapq.heappop(heap)`
- **注意**: エラーハンドリングが重要

## 関連するLeetCode/AtCoder問題

### Medium
- [Kth Largest Element](./kth_largest_element_logic.md) - トップK問題の基本
- [Merge K Sorted Lists](./merge_k_sorted_lists_logic.md) - マージ問題
- [Top K Frequent Elements](./top_k_frequent_elements_logic.md) - 頻度問題

### Hard
- [Find Median from Data Stream](../leetcode/hard/) - メディアンの追跡
- [Sliding Window Maximum](../leetcode/hard/) - スライディングウィンドウ + ヒープ

## 学習の進め方

1. **Kth Largest Element**から始める: ヒープの最も基本的な使い方
2. **Merge K Sorted Lists**でマージ問題を学ぶ: 複数のリストの統合
3. **より複雑な問題**に挑戦: 他のテクニックと組み合わせた使用法を学ぶ

## 次のステップ

- [Kth Largest Element のロジック解説](./kth_largest_element_logic.md)
- [Merge K Sorted Lists のロジック解説](./merge_k_sorted_lists_logic.md)
- [動的計画法テクニック](../07_dynamic_programming/README.md) - ヒープと組み合わせて使用

---

**重要**: ヒープは、優先度に基づいた処理が必要な場合に強力なデータ構造です。特にトップK問題やダイクストラ法で頻繁に使用されます。

