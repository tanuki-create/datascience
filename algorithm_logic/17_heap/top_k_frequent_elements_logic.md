# Top K Frequent Elements - ロジック解説

## 問題概要

整数配列`nums`と整数`k`が与えられたとき、最も頻繁に出現するk個の要素を返す。

**制約**:
- `1 <= nums.length <= 10^5`
- `1 <= k <= ユニークな要素の数`

**例**:
```
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
説明: 1が3回、2が2回出現
```

## ロジックの核心

### なぜヒープが有効か？

**全要素をソート（O(n log n)）**:
- 頻度をカウントし、頻度でソート
- 時間計算量: O(n log n) - ソートのコスト

**ヒープを使う理由**:
- **トップKの保持**: k個の最大頻度要素のみを保持
- **時間計算量**: O(n + u log k) - uはユニークな要素数
- **空間計算量**: O(u + k) - 頻度マップとヒープ

### 思考プロセス

1. **頻度のカウント**: 各要素の出現回数をカウント
2. **最小ヒープの使用**: k個の最大頻度要素を保持するために、最小ヒープを使用
3. **サイズの制限**: ヒープのサイズをkに制限
4. **結果の取得**: ヒープからk個の要素を取得

### アルゴリズムのステップ

```
function topKFrequent(nums, k):
    // 1. 頻度をカウント
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    
    // 2. 最小ヒープでトップKを保持
    heap = []
    for num, count in freq.items():
        heapq.heappush(heap, (count, num))
        if len(heap) > k:
            heapq.heappop(heap)  // 最小頻度を削除
    
    // 3. 結果を返す
    return [num for count, num in heap]
```

## 具体例でのトレース

### 例: `nums = [1,1,1,2,2,3], k = 2`

```
ステップ1: 頻度のカウント
  freq = {1: 3, 2: 2, 3: 1}

ステップ2: ヒープの構築
  num=1, count=3: heap = [(3,1)]
  num=2, count=2: heap = [(2,2), (3,1)], len=2 <= k=2
  num=3, count=1: heap = [(1,3), (2,2), (3,1)], len=3 > k=2
    → pop → heap = [(2,2), (3,1)]

ステップ3: 結果の取得
  result = [2, 1]

結果: [1, 2] (頻度順)
```

## 現実世界での応用

### 1. トレンド分析
- **シナリオ**: ソーシャルメディアで、最も人気のあるトピックを追跡
- **実装**: トピックの出現頻度をカウントし、トップKをヒープで管理
- **例**: Twitterのトレンド分析
- **メリット**: リアルタイムのトレンド追跡

### 2. レコメンデーションシステム
- **シナリオ**: 商品レコメンデーションで、最も人気のある商品を推薦
- **実装**: 商品の購入頻度をカウントし、トップKをヒープで管理
- **例**: アマゾンの商品推薦
- **メリット**: 効率的なレコメンデーション

### 3. ログ分析
- **シナリオ**: サーバーログで、最も頻繁に発生するエラーを識別
- **実装**: エラーの出現頻度をカウントし、トップKをヒープで管理
- **例**: システム監視ツール
- **メリット**: 問題の早期発見

### 4. 検索エンジン
- **シナリオ**: 検索エンジンで、最も頻繁に検索されるキーワードを追跡
- **実装**: キーワードの検索頻度をカウントし、トップKをヒープで管理
- **例**: Googleの検索トレンド
- **メリット**: 検索の最適化

### 5. ネットワークトラフィック分析
- **シナリオ**: ネットワークトラフィックで、最も頻繁にアクセスされるIPアドレスを識別
- **実装**: IPアドレスのアクセス頻度をカウントし、トップKをヒープで管理
- **例**: ネットワークセキュリティ監視
- **メリット**: 異常トラフィックの検出

### 6. データマイニング
- **シナリオ**: データマイニングで、最も頻繁に出現するパターンを発見
- **実装**: パターンの出現頻度をカウントし、トップKをヒープで管理
- **例**: マーケットバスケット分析
- **メリット**: 隠れたパターンの発見

## 注意点と落とし穴

### 1. 頻度のカウント
- **問題**: 各要素の出現回数を正確にカウントする必要がある
- **解決策**: ハッシュマップ（辞書）を使用して頻度をカウント
- **実装**: `freq[num] = freq.get(num, 0) + 1`
- **注意**: カウントを忘れると、正しい結果が得られない

### 2. 最小ヒープの使用
- **問題**: k個の最大頻度要素を見つけるのに、なぜ最小ヒープを使うのか？
- **解決策**: k個の最大頻度要素を保持するために、最小ヒープを使用して最小頻度を削除
- **実装**: 最小ヒープでk個の最大頻度要素を保持
- **注意**: 最大ヒープを使う場合は、全ての要素を保持する必要がある

### 3. ヒープのサイズ制限
- **問題**: ヒープのサイズをkに制限する必要がある
- **解決策**: ヒープのサイズがkを超えた場合、最小頻度を削除
- **実装**: `if len(heap) > k: heapq.heappop(heap)`
- **メリット**: メモリ使用量をO(k)に削減

### 4. 時間計算量の理解
- **平均**: O(n + u log k) - nは要素数、uはユニークな要素数
- **最悪**: O(n + u log k) - 常に同じ時間計算量
- **空間**: O(u + k) - 頻度マップO(u)とヒープO(k)
- **注意**: uが小さい場合、O(n + u log k)はO(n log n)より大幅に高速

### 5. バケットソートとの比較
- **問題**: バケットソート（O(n)）の方が高速な場合がある
- **解決策**: 
  - ヒープ: O(n + u log k)、実装が簡単
  - バケットソート: O(n)、実装が複雑、頻度の範囲が限定的
- **選択**: 頻度の範囲が大きい場合や実装の簡単さを重視する場合はヒープ

### 6. 結果の順序
- **問題**: 結果の順序を頻度順にする必要がある場合がある
- **解決策**: ヒープから取得した後、頻度でソート
- **実装**: `sorted([num for count, num in heap], key=lambda x: freq[x], reverse=True)`
- **注意**: 問題の要件を確認する必要がある

### 7. 同頻度の要素の扱い
- **問題**: 同じ頻度の要素が複数ある場合、どれを選ぶべきか？
- **解決策**: 通常は任意のk個を返すが、問題の要件を確認
- **実装**: ヒープは自動的に処理
- **注意**: 特定の順序が必要な場合は、追加の処理が必要

### 8. ストリーミングデータへの対応
- **問題**: データがストリームとして到着する場合、ヒープが有効
- **解決策**: 各要素を順次処理し、頻度マップとヒープを更新
- **実装**: ループ内で頻度を更新し、ヒープを管理
- **メリット**: ストリーミングデータに適している

## 関連問題

- [Kth Largest Element](./kth_largest_element_logic.md) - トップK問題の基本
- [Top K Frequent Words](../leetcode/medium/) - 文字列版
- [Find K Closest Elements](../leetcode/medium/) - 距離に基づくトップK
- [Sort Characters By Frequency](../leetcode/medium/) - 頻度でソート

---

**次のステップ**: [Divide and Conquerテクニック](../18_divide_conquer/README.md)で分割統治法を学ぶ

