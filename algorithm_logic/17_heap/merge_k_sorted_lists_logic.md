# Merge K Sorted Lists - ロジック解説

## 問題概要

k個のソート済みリンクリストが与えられたとき、それらを1つのソート済みリンクリストにマージする。

**制約**:
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`

**例**:
```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
```

## ロジックの核心

### なぜヒープが有効か？

**全要素をソート（O(n log n)）**:
- 全ての要素を配列に集めてソート
- 時間計算量: O(n log n) - nは全要素数

**ヒープを使う理由**:
- **各リストの先頭を管理**: k個のリストの先頭をヒープで管理
- **最小値の取得**: O(1)で最小値を取得
- **時間計算量**: O(n log k) - kが小さい場合、大幅に改善

### 思考プロセス

1. **各リストの先頭をヒープに追加**: 各リストの最初のノードをヒープに追加
2. **最小値を取得**: ヒープから最小値を取得し、結果リストに追加
3. **次のノードを追加**: 取得したノードの次のノードをヒープに追加
4. **繰り返し**: ヒープが空になるまで繰り返す

### アルゴリズムのステップ

```
function mergeKLists(lists):
    heap = []
    
    // 各リストの先頭をヒープに追加
    for i, node in enumerate(lists):
        if node:
            heapq.heappush(heap, (node.val, i, node))
    
    dummy = ListNode(0)
    current = dummy
    
    while heap:
        val, idx, node = heapq.heappop(heap)
        current.next = node
        current = current.next
        
        // 次のノードをヒープに追加
        if node.next:
            heapq.heappush(heap, (node.next.val, idx, node.next))
    
    return dummy.next
```

## 具体例でのトレース

### 例: `lists = [[1,4,5],[1,3,4],[2,6]]`

```
初期状態:
  heap = [(1,0,node1), (1,1,node1), (2,2,node2)]
  current = dummy

ステップ1: pop (1,0,node1)
  current.next = node1 (val=1)
  heap = [(1,1,node1), (2,2,node2), (4,0,node4)]

ステップ2: pop (1,1,node1)
  current.next = node1 (val=1)
  heap = [(2,2,node2), (3,1,node3), (4,0,node4)]

ステップ3: pop (2,2,node2)
  current.next = node2 (val=2)
  heap = [(3,1,node3), (4,0,node4), (6,2,node6)]

ステップ4: pop (3,1,node3)
  current.next = node3 (val=3)
  heap = [(4,0,node4), (4,1,node4), (6,2,node6)]

ステップ5: pop (4,0,node4)
  current.next = node4 (val=4)
  heap = [(4,1,node4), (5,0,node5), (6,2,node6)]

ステップ6: pop (4,1,node4)
  current.next = node4 (val=4)
  heap = [(5,0,node5), (6,2,node6)]

ステップ7: pop (5,0,node5)
  current.next = node5 (val=5)
  heap = [(6,2,node6)]

ステップ8: pop (6,2,node6)
  current.next = node6 (val=6)
  heap = []

結果: [1,1,2,3,4,4,5,6]
```

## 現実世界での応用

### 1. マージソートの実装
- **シナリオ**: 複数のソート済み配列を1つにマージ
- **実装**: 各配列の先頭をヒープで管理し、最小値を順次取得
- **例**: 外部ソートアルゴリズム
- **メリット**: メモリ効率的なマージ

### 2. データベースのクエリ結果のマージ
- **シナリオ**: 複数のデータベースクエリの結果を時系列順にマージ
- **実装**: 各クエリ結果の先頭をヒープで管理
- **例**: 分散データベースのクエリ結果の統合
- **メリット**: 効率的なデータ統合

### 3. ログファイルのマージ
- **シナリオ**: 複数のサーバーのログファイルを時系列順にマージ
- **実装**: 各ログファイルの先頭をヒープで管理
- **例**: ログ分析システム
- **メリット**: 時系列順のログ分析

### 4. ストリーミングデータのマージ
- **シナリオ**: 複数のストリームからデータを時系列順にマージ
- **実装**: 各ストリームの先頭をヒープで管理
- **例**: リアルタイムデータ分析
- **メリット**: 効率的なストリーム処理

### 5. 分散システムのデータ統合
- **シナリオ**: 複数のノードからデータを収集し、時系列順にマージ
- **実装**: 各ノードのデータの先頭をヒープで管理
- **例**: 分散データ処理システム
- **メリット**: 効率的なデータ統合

### 6. バージョン管理システム
- **シナリオ**: 複数のブランチの変更履歴を時系列順にマージ
- **実装**: 各ブランチの変更履歴の先頭をヒープで管理
- **例**: Gitのマージ操作
- **メリット**: 効率的なバージョン管理

## 注意点と落とし穴

### 1. タプルの比較
- **問題**: ヒープでノードを比較する際、同じ値の場合の処理
- **解決策**: タプルにインデックスを含めて、一意性を保証
- **実装**: `(node.val, idx, node)`のタプルを使用
- **注意**: インデックスがないと、ノードオブジェクトの比較でエラーが発生

### 2. 空のリストの処理
- **問題**: リストが空の場合や、全てのリストが空の場合の処理
- **解決策**: ヒープに追加する前に、ノードが存在するかチェック
- **実装**: `if node: heapq.heappush(heap, ...)`
- **注意**: エッジケースの処理が重要

### 3. 時間計算量の理解
- **平均**: O(n log k) - nは全要素数、kはリスト数
- **最悪**: O(n log k) - 常に同じ時間計算量
- **空間**: O(k) - k個のノードをヒープで保持
- **注意**: kが小さい場合、O(n log k)はO(n log n)より大幅に高速

### 4. 分割統治法との比較
- **問題**: 分割統治法（O(n log k)）も同じ時間計算量
- **解決策**: 
  - ヒープ: 実装が簡単、メモリO(k)
  - 分割統治: 実装が複雑、メモリO(log k)の再帰スタック
- **選択**: 実装の簡単さを重視する場合はヒープ

### 5. リンクリストの操作
- **問題**: リンクリストのノードを適切に接続する必要がある
- **解決策**: ダミーノードを使用して、結果リストを構築
- **実装**: `dummy = ListNode(0)`で開始
- **注意**: ダミーノードを使うことで、エッジケースを簡潔に処理

### 6. ヒープの更新
- **問題**: ノードを取得した後、次のノードをヒープに追加する必要がある
- **解決策**: `node.next`が存在する場合、ヒープに追加
- **実装**: `if node.next: heapq.heappush(heap, ...)`
- **注意**: 次のノードがない場合、そのリストは終了

### 7. メモリ使用量
- **問題**: ヒープにk個のノードを保持する必要がある
- **解決策**: kが大きい場合、メモリ使用量が増える
- **実装**: ヒープのサイズは最大k
- **注意**: kが非常に大きい場合、メモリ制約に注意

### 8. 安定ソートの保証
- **問題**: 同じ値の要素の順序を保証する必要がある場合がある
- **解決策**: タプルにインデックスを含めることで、安定ソートを実現
- **実装**: `(node.val, idx, node)`のタプルを使用
- **注意**: インデックスの順序により、安定ソートが保証される

## 関連問題

- [Merge Two Sorted Lists](../20_linked_list/merge_two_sorted_lists_logic.md) - 2つのリストのマージ
- [Kth Largest Element](./kth_largest_element_logic.md) - トップK問題
- [Top K Frequent Elements](./top_k_frequent_elements_logic.md) - 頻度問題
- [Ugly Number II](../leetcode/medium/) - ヒープの応用

---

**次のステップ**: [Top K Frequent Elements](./top_k_frequent_elements_logic.md)で頻度問題を学ぶ

