# Insert Interval - ロジック解説

## 問題概要

ソート済みで重複のないインターバルの配列と新しいインターバルが与えられたとき、新しいインターバルを挿入し、必要に応じてマージして返す。

**制約**:
- `0 <= intervals.length <= 10^4`
- インターバルはソート済みで重複がない

**例**:
```
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
説明: [2,5]が[1,3]と重複するため、[1,5]にマージ
```

## ロジックの核心

### なぜ3つのフェーズが有効か？

**全探索（O(n)）**:
- 全てのインターバルをチェックして挿入位置を探す
- 時間計算量: O(n) - 線形時間

**3つのフェーズを使う理由**:
- **フェーズ1**: 新しいインターバルより前のインターバルを追加
- **フェーズ2**: 新しいインターバルと重複するインターバルをマージ
- **フェーズ3**: 新しいインターバルより後のインターバルを追加
- **時間計算量**: O(n) - 1回の走査で完了

### 思考プロセス

1. **フェーズ1**: 新しいインターバルの開始点より前のインターバルを追加
2. **フェーズ2**: 新しいインターバルと重複するインターバルをマージ
3. **フェーズ3**: 新しいインターバルの終了点より後のインターバルを追加

### アルゴリズムのステップ

```
function insert(intervals, newInterval):
    result = []
    i = 0
    n = len(intervals)
    
    // フェーズ1: 新しいインターバルより前のインターバルを追加
    while i < n and intervals[i][1] < newInterval[0]:
        result.append(intervals[i])
        i += 1
    
    // フェーズ2: 新しいインターバルと重複するインターバルをマージ
    while i < n and intervals[i][0] <= newInterval[1]:
        newInterval[0] = min(newInterval[0], intervals[i][0])
        newInterval[1] = max(newInterval[1], intervals[i][1])
        i += 1
    
    result.append(newInterval)
    
    // フェーズ3: 新しいインターバルより後のインターバルを追加
    while i < n:
        result.append(intervals[i])
        i += 1
    
    return result
```

## 具体例でのトレース

### 例: `intervals = [[1,3],[6,9]], newInterval = [2,5]`

```
初期状態:
  result = []
  i = 0
  newInterval = [2,5]

フェーズ1: intervals[0][1](3) < newInterval[0](2)? → No
  スキップ

フェーズ2: intervals[0][0](1) <= newInterval[1](5)? → Yes
  newInterval[0] = min(2, 1) = 1
  newInterval[1] = max(5, 3) = 5
  i = 1
  intervals[1][0](6) <= newInterval[1](5)? → No
  終了
  result.append([1,5])

フェーズ3: intervals[1]を追加
  result.append([6,9])

結果: [[1,5],[6,9]]
```

## 現実世界での応用

### 1. 会議室予約システム
- **シナリオ**: 新しい予約を追加し、重複する予約を統合
- **実装**: 3つのフェーズで効率的に挿入
- **メリット**: 効率的な予約管理

### 2. カレンダーアプリケーション
- **シナリオ**: 新しいイベントを追加し、重複するイベントを統合
- **実装**: 3つのフェーズで効率的に挿入
- **メリット**: 効率的なイベント管理

### 3. ネットワークの帯域幅管理
- **シナリオ**: 新しい帯域幅の使用時間を追加し、重複を統合
- **実装**: 3つのフェーズで効率的に挿入
- **メリット**: 効率的な帯域幅管理

### 4. データベースのクエリ最適化
- **シナリオ**: データベースで、新しい時間範囲を追加
- **実装**: 3つのフェーズで効率的に挿入
- **メリット**: クエリの実行時間を短縮

### 5. ゲーム開発
- **シナリオ**: ゲームで、新しいイベントの時間範囲を追加
- **実装**: 3つのフェーズで効率的に挿入
- **メリット**: 効率的なイベント管理

### 6. 金融取引システム
- **シナリオ**: 金融取引で、新しい取引時間の範囲を追加
- **実装**: 3つのフェーズで効率的に挿入
- **メリット**: 効率的な取引管理

## 注意点と落とし穴

### 1. 3つのフェーズの理解
- **問題**: 3つのフェーズを正確に実装する必要がある
- **解決策**: 
  - フェーズ1: 前のインターバルを追加
  - フェーズ2: 重複するインターバルをマージ
  - フェーズ3: 後のインターバルを追加
- **実装**: 各フェーズを正確に実装
- **注意**: フェーズの順序が重要

### 2. 重複の判定
- **問題**: 新しいインターバルと既存のインターバルが重複するか判定
- **解決策**: `intervals[i][0] <= newInterval[1]`で重複を判定
- **実装**: フェーズ2で重複をチェック
- **注意**: 重複の定義を明確にする必要がある

### 3. マージ操作
- **問題**: 重複するインターバルを1つに統合
- **解決策**: 開始点の最小値と終了点の最大値を取る
- **実装**: `newInterval[0] = min(...)`, `newInterval[1] = max(...)`
- **注意**: マージの条件を正確に理解する必要がある

### 4. 時間計算量の理解
- **平均**: O(n) - 1回の走査で完了
- **最悪**: O(n) - 常に線形時間
- **空間**: O(n) - 結果配列
- **メリット**: ソートが不要（既にソート済み）

### 5. エッジケースの処理
- **問題**: 空のリスト、新しいインターバルが最初/最後、全てと重複する場合
- **解決策**: 各フェーズで適切に処理
- **実装**: 各フェーズの条件を正確に実装
- **注意**: エッジケースを忘れると、エラーが発生

### 6. ソート済みの前提
- **問題**: インターバルがソート済みであることを前提とする
- **解決策**: 問題の制約でソート済みが保証されている
- **実装**: ソートの処理は不要
- **注意**: ソート済みでない場合は、事前にソートが必要

### 7. 重複のない前提
- **問題**: インターバルが重複していないことを前提とする
- **解決策**: 問題の制約で重複がないことが保証されている
- **実装**: 既存のインターバル間の重複を考慮する必要がない
- **注意**: 重複がある場合は、事前にマージが必要

### 8. 新しいインターバルの位置
- **問題**: 新しいインターバルがどこに挿入されるか
- **解決策**: 3つのフェーズで自動的に適切な位置に挿入
- **実装**: フェーズ2でマージし、フェーズ3の前に追加
- **注意**: 挿入位置を正確に理解する必要がある

## 関連問題

- [Merge Intervals](./merge_intervals_logic.md) - インターバルのマージ
- [Non-overlapping Intervals](./non_overlapping_intervals_logic.md) - 重複の削除
- [Meeting Rooms](./meeting_rooms_logic.md) - 会議室の予約
- [Range Module](../leetcode/hard/) - 範囲の管理

---

**次のステップ**: [Non-overlapping Intervals](./non_overlapping_intervals_logic.md)で重複削除を学ぶ

