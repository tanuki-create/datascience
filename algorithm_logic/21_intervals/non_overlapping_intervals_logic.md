# Non-overlapping Intervals - ロジック解説

## 問題概要

インターバルの配列が与えられたとき、重複しないようにするために削除する必要がある最小のインターバルの数を返す。

**制約**:
- `1 <= intervals.length <= 10^5`

**例**:
```
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
説明: [1,3]を削除すれば、重複がなくなる
```

## ロジックの核心

### なぜ貪欲法が有効か？

**全探索（O(2^n)）**:
- 全ての可能な削除の組み合わせを試す
- 時間計算量: O(2^n) - 非効率

**貪欲法を使う理由**:
- **終了点でソート**: 終了点が早いインターバルを優先的に保持
- **局所最適選択**: 各ステップで最適な選択を行う
- **時間計算量**: O(n log n) - ソート + O(n)の走査

### 思考プロセス

1. **終了点でソート**: 終了点が早いインターバルを優先
2. **重複チェック**: 現在のインターバルと前のインターバルが重複するか確認
3. **削除の決定**: 重複する場合、終了点が遅い方を削除（カウント）

### アルゴリズムのステップ

```
function eraseOverlapIntervals(intervals):
    if not intervals:
        return 0
    
    // 終了点でソート
    intervals.sort(key=lambda x: x[1])
    
    count = 0
    prev_end = intervals[0][1]
    
    for i in range(1, len(intervals)):
        current_start = intervals[i][0]
        
        // 重複チェック: current_start < prev_end
        if current_start < prev_end:
            count += 1  // 現在のインターバルを削除
        else:
            prev_end = intervals[i][1]  // 現在のインターバルを保持
    
    return count
```

## 具体例でのトレース

### 例: `intervals = [[1,2],[2,3],[3,4],[1,3]]`

```
終了点でソート後: [[1,2],[2,3],[1,3],[3,4]]

初期状態:
  prev_end = 2
  count = 0

i=1: [2,3]
  current_start(2) < prev_end(2)? → No
  prev_end = 3

i=2: [1,3]
  current_start(1) < prev_end(3)? → Yes
  count += 1 → count = 1

i=3: [3,4]
  current_start(3) < prev_end(3)? → No
  prev_end = 4

結果: 1
```

## 現実世界での応用

### 1. 会議室予約システム
- **シナリオ**: 会議室の予約で、重複する予約を最小限に削除
- **実装**: 終了点でソートし、重複を最小限に削除
- **メリット**: 効率的な予約管理

### 2. タスクスケジューリング
- **シナリオ**: タスクのスケジューリングで、重複するタスクを最小限に削除
- **実装**: 終了点でソートし、重複を最小限に削除
- **メリット**: 効率的なタスク管理

### 3. リソース割り当て
- **シナリオ**: リソースの割り当てで、重複する割り当てを最小限に削除
- **実装**: 終了点でソートし、重複を最小限に削除
- **メリット**: 効率的なリソース管理

### 4. イベント管理
- **シナリオ**: イベントの管理で、重複するイベントを最小限に削除
- **実装**: 終了点でソートし、重複を最小限に削除
- **メリット**: 効率的なイベント管理

### 5. ネットワークの帯域幅管理
- **シナリオ**: ネットワークで、重複する帯域幅の使用を最小限に削除
- **実装**: 終了点でソートし、重複を最小限に削除
- **メリット**: 効率的な帯域幅管理

### 6. 金融取引システム
- **シナリオ**: 金融取引で、重複する取引時間を最小限に削除
- **実装**: 終了点でソートし、重複を最小限に削除
- **メリット**: 効率的な取引管理

## 注意点と落とし穴

### 1. 終了点でソートの重要性
- **問題**: なぜ開始点ではなく終了点でソートするのか？
- **解決策**: 終了点が早いインターバルを優先的に保持することで、より多くのインターバルを保持できる
- **実装**: `intervals.sort(key=lambda x: x[1])`
- **メリット**: 貪欲法の最適性が保証される

### 2. 重複の判定
- **問題**: 2つのインターバルが重複しているか判定
- **解決策**: `current_start < prev_end`で重複を判定
- **実装**: ソート後、隣接するインターバルのみをチェック
- **注意**: 等号を含めない（`current_start == prev_end`は重複しない）

### 3. 削除の決定
- **問題**: 重複する場合、どちらを削除するべきか？
- **解決策**: 終了点が遅い方を削除（終了点が早い方を保持）
- **実装**: `count += 1`で削除をカウントし、`prev_end`を更新しない
- **注意**: 終了点が早い方を保持することで、より多くのインターバルを保持できる

### 4. 時間計算量の理解
- **平均**: O(n log n) - ソートのコスト
- **最悪**: O(n log n) - 常に同じ時間計算量
- **空間**: O(1) - 追加の空間は定数
- **注意**: ソートのコストが支配的

### 5. 貪欲法の最適性
- **問題**: なぜこの貪欲法が最適解を保証するのか？
- **解決策**: 終了点でソートすることで、局所最適選択が全体最適解になる
- **実装**: 終了点が早いインターバルを優先的に保持
- **注意**: 開始点でソートすると、最適解が保証されない場合がある

### 6. エッジケースの処理
- **問題**: 空のリスト、1つのインターバル、重複がない場合
- **解決策**: 各操作でエッジケースをチェック
- **実装**: `if not intervals: return 0`などのチェック
- **注意**: エッジケースを忘れると、エラーが発生

### 7. 等号の扱い
- **問題**: `current_start == prev_end`の場合、重複とみなすか？
- **解決策**: 通常は重複とみなさない（`current_start < prev_end`）
- **実装**: 等号を含めないことで、接するインターバルは重複しない
- **注意**: 問題の要件を確認する必要がある

### 8. 動的計画法との比較
- **問題**: 動的計画法でも解けるが、貪欲法の方が効率的
- **解決策**: 
  - 貪欲法: O(n log n)時間、O(1)空間
  - 動的計画法: O(n²)時間、O(n)空間
- **選択**: 貪欲法が推奨される

## 関連問題

- [Merge Intervals](./merge_intervals_logic.md) - インターバルのマージ
- [Insert Interval](./insert_interval_logic.md) - インターバルの挿入
- [Meeting Rooms](./meeting_rooms_logic.md) - 会議室の予約
- [Minimum Number of Arrows to Burst Balloons](../leetcode/medium/) - 類似の問題

---

**次のステップ**: [Meeting Rooms](./meeting_rooms_logic.md)で会議室の予約を学ぶ

