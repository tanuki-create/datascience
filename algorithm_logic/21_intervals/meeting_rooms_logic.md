# Meeting Rooms - ロジック解説

## 問題概要

会議のインターバルの配列が与えられたとき、全ての会議に参加できるか（重複がないか）を判定する。

**制約**:
- `0 <= intervals.length <= 10^4`

**例**:
```
Input: intervals = [[0,30],[5,10],[15,20]]
Output: false
説明: [5,10]と[0,30]が重複するため、全ての会議に参加できない

Input: intervals = [[7,10],[2,4]]
Output: true
説明: 重複がないため、全ての会議に参加できる
```

## ロジックの核心

### なぜソートが有効か？

**全探索（O(n²)）**:
- 全てのインターバルのペアをチェック
- 時間計算量: O(n²) - 非効率

**ソートを使う理由**:
- **順序の保証**: 開始点でソートすることで、重複チェックが簡単に
- **隣接チェック**: ソート後は、隣接するインターバルのみをチェック
- **時間計算量**: O(n log n) - ソート + O(n)の走査

### 思考プロセス

1. **ソート**: 開始点でソート
2. **重複チェック**: 隣接するインターバルが重複するか確認
3. **結果**: 重複があればfalse、なければtrue

### アルゴリズムのステップ

```
function canAttendMeetings(intervals):
    if not intervals:
        return True
    
    // 開始点でソート
    intervals.sort(key=lambda x: x[0])
    
    for i in range(1, len(intervals)):
        // 重複チェック: 前のインターバルの終了点 > 現在のインターバルの開始点
        if intervals[i-1][1] > intervals[i][0]:
            return False
    
    return True
```

## 具体例でのトレース

### 例: `intervals = [[0,30],[5,10],[15,20]]`

```
ソート後: [[0,30],[5,10],[15,20]]

i=1: intervals[0][1](30) > intervals[1][0](5)? → Yes
  重複が検出された → False

結果: false
```

### 例: `intervals = [[7,10],[2,4]]`

```
ソート後: [[2,4],[7,10]]

i=1: intervals[0][1](4) > intervals[1][0](7)? → No
  重複なし → True

結果: true
```

## 現実世界での応用

### 1. 会議室予約システム
- **シナリオ**: 会議室の予約で、重複する予約がないかチェック
- **実装**: インターバルをソートし、重複をチェック
- **メリット**: 効率的な予約管理

### 2. カレンダーアプリケーション
- **シナリオ**: カレンダーで、イベントの重複をチェック
- **実装**: インターバルをソートし、重複をチェック
- **メリット**: 効率的なイベント管理

### 3. タスクスケジューリング
- **シナリオ**: タスクのスケジューリングで、重複するタスクがないかチェック
- **実装**: インターバルをソートし、重複をチェック
- **メリット**: 効率的なタスク管理

### 4. リソース割り当て
- **シナリオ**: リソースの割り当てで、重複する割り当てがないかチェック
- **実装**: インターバルをソートし、重複をチェック
- **メリット**: 効率的なリソース管理

### 5. イベント管理
- **シナリオ**: イベントの管理で、重複するイベントがないかチェック
- **実装**: インターバルをソートし、重複をチェック
- **メリット**: 効率的なイベント管理

### 6. ネットワークの帯域幅管理
- **シナリオ**: ネットワークで、帯域幅の使用時間の重複をチェック
- **実装**: インターバルをソートし、重複をチェック
- **メリット**: 効率的な帯域幅管理

## 注意点と落とし穴

### 1. ソートの重要性
- **問題**: インターバルをソートすることで、処理が簡単になる
- **解決策**: 開始点でソート
- **実装**: `intervals.sort(key=lambda x: x[0])`
- **メリット**: 重複チェックが効率的に

### 2. 重複の判定
- **問題**: 2つのインターバルが重複しているか判定
- **解決策**: `intervals[i-1][1] > intervals[i][0]`で重複を判定
- **実装**: ソート後、隣接するインターバルのみをチェック
- **注意**: 等号を含めない（`intervals[i-1][1] == intervals[i][0]`は重複しない）

### 3. 時間計算量の理解
- **平均**: O(n log n) - ソートのコスト
- **最悪**: O(n log n) - 常に同じ時間計算量
- **空間**: O(1) - 追加の空間は定数（ソートがインプレースの場合）
- **注意**: ソートのコストが支配的

### 4. エッジケースの処理
- **問題**: 空のリスト、1つのインターバル、重複がない場合
- **解決策**: 各操作でエッジケースをチェック
- **実装**: `if not intervals: return True`などのチェック
- **注意**: エッジケースを忘れると、エラーが発生

### 5. 等号の扱い
- **問題**: `intervals[i-1][1] == intervals[i][0]`の場合、重複とみなすか？
- **解決策**: 通常は重複とみなさない（接するインターバルは重複しない）
- **実装**: `>`のみを使用（等号を含めない）
- **注意**: 問題の要件を確認する必要がある

### 6. インプレースソート
- **問題**: 元の配列を変更してもよいか？
- **解決策**: 問題の要件を確認する必要がある
- **実装**: インプレースソートを使用する場合と、コピーを作成する場合がある
- **注意**: 元の配列を保持する必要がある場合は、コピーを作成

### 7. 早期終了
- **問題**: 重複が見つかったら、即座に終了できる
- **解決策**: `if intervals[i-1][1] > intervals[i][0]: return False`
- **実装**: 重複が見つかったら、即座にFalseを返す
- **メリット**: 実際の実行時間を短縮

### 8. Merge Intervalsとの関係
- **問題**: この問題はMerge Intervalsの特殊ケース
- **解決策**: Merge Intervalsでマージ後、元のサイズと比較
- **実装**: `len(merge(intervals)) == len(intervals)`で判定
- **注意**: この問題では、よりシンプルな実装が可能

## 関連問題

- [Merge Intervals](./merge_intervals_logic.md) - インターバルのマージ
- [Insert Interval](./insert_interval_logic.md) - インターバルの挿入
- [Non-overlapping Intervals](./non_overlapping_intervals_logic.md) - 重複の削除
- [Meeting Rooms II](../leetcode/medium/) - 複数の会議室

---

**次のステップ**: [Advanced Stringテクニック](../22_advanced_string/README.md)で高度な文字列アルゴリズムを学ぶ

