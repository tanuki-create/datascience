# Merge Intervals - ロジック解説

## 問題概要

重複する可能性のあるインターバルの配列が与えられたとき、重複するインターバルをマージして返す。

**制約**:
- `1 <= intervals.length <= 10^4`
- `intervals[i].length == 2`

**例**:
```
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
説明: [1,3]と[2,6]が重複するため、[1,6]にマージ
```

## ロジックの核心

### なぜソートが有効か？

**全探索（O(n²)）**:
- 全てのインターバルのペアをチェック
- 時間計算量: O(n²) - 非効率

**ソートを使う理由**:
- **順序の保証**: 開始点でソートすることで、重複チェックが簡単に
- **隣接チェック**: ソート後は、隣接するインターバルのみをチェック
- **時間計算量**: O(n log n) - ソート + O(n)の走査

### 思考プロセス

1. **ソート**: 開始点でソート
2. **重複チェック**: 現在のインターバルと前のインターバルが重複するか確認
3. **マージ**: 重複する場合はマージ、しない場合は新しいインターバルとして追加

### アルゴリズムのステップ

```
function merge(intervals):
    if not intervals:
        return []
    
    // 開始点でソート
    intervals.sort(key=lambda x: x[0])
    
    result = [intervals[0]]
    
    for current in intervals[1:]:
        prev = result[-1]
        
        // 重複チェック: prev.end >= current.start
        if prev[1] >= current[0]:
            // マージ: 終了点の最大値を取る
            prev[1] = max(prev[1], current[1])
        else:
            // 重複しない場合は新しいインターバルとして追加
            result.append(current)
    
    return result
```

## 具体例でのトレース

### 例: `intervals = [[1,3],[2,6],[8,10],[15,18]]`

```
ソート後: [[1,3],[2,6],[8,10],[15,18]]

初期状態:
  result = [[1,3]]

current = [2,6]:
  prev = [1,3]
  prev[1](3) >= current[0](2) → 重複
  prev[1] = max(3, 6) = 6
  result = [[1,6]]

current = [8,10]:
  prev = [1,6]
  prev[1](6) < current[0](8) → 重複しない
  result = [[1,6],[8,10]]

current = [15,18]:
  prev = [8,10]
  prev[1](10) < current[0](15) → 重複しない
  result = [[1,6],[8,10],[15,18]]

結果: [[1,6],[8,10],[15,18]]
```

## 現実世界での応用

### 1. 会議室予約システム
- **シナリオ**: 会議室の予約を管理し、重複する予約を統合
- **実装**: インターバルをソートし、重複をマージ
- **メリット**: 効率的な予約管理

### 2. カレンダーアプリケーション
- **シナリオ**: カレンダーで、重複するイベントを統合
- **実装**: インターバルをソートし、重複をマージ
- **メリット**: 効率的なイベント管理

### 3. ネットワークの帯域幅管理
- **シナリオ**: ネットワークで、帯域幅の使用時間を統合
- **実装**: インターバルをソートし、重複をマージ
- **メリット**: 効率的な帯域幅管理

### 4. データベースのクエリ最適化
- **シナリオ**: データベースで、時間範囲のクエリを最適化
- **実装**: インターバルをソートし、重複をマージ
- **メリット**: クエリの実行時間を短縮

### 5. ゲーム開発
- **シナリオ**: ゲームで、イベントの時間範囲を統合
- **実装**: インターバルをソートし、重複をマージ
- **メリット**: 効率的なイベント管理

### 6. 金融取引システム
- **シナリオ**: 金融取引で、取引時間の範囲を統合
- **実装**: インターバルをソートし、重複をマージ
- **メリット**: 効率的な取引管理

## 注意点と落とし穴

### 1. ソートの重要性
- **問題**: インターバルをソートすることで、処理が簡単になる
- **解決策**: 開始点でソート
- **実装**: `intervals.sort(key=lambda x: x[0])`
- **メリット**: 重複チェックが効率的に

### 2. 重複の判定
- **問題**: 2つのインターバルが重複しているか判定
- **解決策**: `prev[1] >= current[0]`で重複を判定
- **実装**: ソート後、隣接するインターバルのみをチェック
- **注意**: 重複の定義を明確にする必要がある

### 3. マージ操作
- **問題**: 重複するインターバルを1つに統合
- **解決策**: 開始点の最小値と終了点の最大値を取る
- **実装**: `prev[1] = max(prev[1], current[1])`
- **注意**: 開始点は既にソートされているため、最小値は`prev[0]`

### 4. エッジケースの処理
- **問題**: 空のリスト、1つのインターバル、重複がない場合
- **解決策**: 各操作でエッジケースをチェック
- **実装**: `if not intervals: return []`などのチェック
- **注意**: エッジケースを忘れると、エラーが発生

### 5. 時間計算量の理解
- **平均**: O(n log n) - ソートのコスト
- **最悪**: O(n log n) - 常に同じ時間計算量
- **空間**: O(n) - 結果配列
- **注意**: ソートのコストが支配的

### 6. インプレース操作
- **問題**: 元の配列を変更せずに処理する必要がある場合がある
- **解決策**: 新しい配列を作成して結果を保存
- **実装**: `result = []`で新しい配列を作成
- **注意**: 元の配列を変更する場合は注意が必要

### 7. 包含関係の処理
- **問題**: インターバルAがインターバルBに完全に含まれる場合
- **解決策**: マージ操作で自動的に処理される
- **実装**: `max(prev[1], current[1])`で終了点の最大値を取る
- **注意**: 包含関係も正しく処理される

### 8. 等号の扱い
- **問題**: `prev[1] == current[0]`の場合、重複とみなすか？
- **解決策**: 通常は重複とみなす（`prev[1] >= current[0]`）
- **実装**: 等号を含めることで、接するインターバルもマージ
- **注意**: 問題の要件を確認する必要がある

## 関連問題

- [Insert Interval](./insert_interval_logic.md) - インターバルの挿入
- [Non-overlapping Intervals](./non_overlapping_intervals_logic.md) - 重複の削除
- [Meeting Rooms](./meeting_rooms_logic.md) - 会議室の予約
- [Range Module](../leetcode/hard/) - 範囲の管理

---

**次のステップ**: [Insert Interval](./insert_interval_logic.md)で挿入操作を学ぶ

