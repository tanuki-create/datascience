# Longest Substring Without Repeating Characters - ロジック解説

## 問題概要

文字列`s`が与えられたとき、重複する文字を含まない最長の部分文字列の長さを返す。

**制約**:
- `0 <= s.length <= 5 * 10^4`
- `s`は英字、数字、記号、空白で構成される

**例**:
```
Input: s = "abcabcbb"
Output: 3
説明: 答えは "abc" で、長さは 3
```

## ロジックの核心

### なぜスライディングウィンドウが有効か？

**素朴なアプローチ（O(n³)）**:
- 全ての部分文字列を列挙: O(n²)の組み合わせ
- 各部分文字列で重複チェック: O(n)の時間
- 時間計算量: O(n³) - 非常に非効率

**スライディングウィンドウを使う理由**:
- **可変サイズウィンドウ**: 重複が発生するまでウィンドウを拡張し、重複が発生したら縮小
- **ハッシュセットで重複管理**: O(1)で重複を検出
- **時間計算量**: O(n) - 各文字を最大2回処理（拡張と縮小）

### 思考プロセス

1. **ウィンドウの定義**: `[left, right]`の範囲が現在のウィンドウ
   - `left`: ウィンドウの開始位置
   - `right`: ウィンドウの終了位置

2. **重複の検出**: ハッシュセットでウィンドウ内の文字を管理
   - `s[right]`がセットに存在する → 重複が発生
   - `s[right]`がセットに存在しない → 重複なし、ウィンドウを拡張可能

3. **ウィンドウの拡張と縮小**:
   - **拡張**: `right`を右に移動し、`s[right]`をセットに追加
   - **縮小**: 重複が発生したら、`left`を右に移動して重複文字を削除

4. **最長長の追跡**: ウィンドウのサイズ`(right - left + 1)`を常に追跡し、最大値を更新

### アルゴリズムのステップ

```
1. ハッシュセット char_set = {}、left = 0、max_length = 0 を初期化
2. right を 0 から len(s) - 1 まで走査:
   a. 重複チェック: s[right] が char_set に存在するか？
   b. 重複がある場合:
      - left を右に移動: s[left] を char_set から削除
      - left++ を繰り返し、重複文字が削除されるまで続ける
   c. 重複がない場合:
      - s[right] を char_set に追加
      - ウィンドウのサイズを計算: current_length = right - left + 1
      - max_length を更新: max_length = max(max_length, current_length)
   d. right++ して次の文字へ
3. max_length を返す
```

### 疑似コード

```
function lengthOfLongestSubstring(s):
    if s is empty:
        return 0
    
    char_set = {}  // ウィンドウ内の文字を管理
    left = 0
    max_length = 0
    
    for right from 0 to len(s) - 1:
        // 重複が発生するまで left を右に移動
        while s[right] in char_set:
            char_set.remove(s[left])
            left++
        
        // 現在の文字を追加
        char_set.add(s[right])
        
        // ウィンドウのサイズを更新
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

## 具体例でのトレース

### 例1: `s = "abcabcbb"`

| ステップ | right | s[right] | char_set | left | ウィンドウ | max_length | アクション |
|---------|-------|-----------|----------|------|-----------|------------|-----------|
| 初期 | - | - | {} | 0 | - | 0 | - |
| 1 | 0 | 'a' | {} | 0 | "a" | 1 | 'a'を追加 |
| 2 | 1 | 'b' | {'a'} | 0 | "ab" | 2 | 'b'を追加 |
| 3 | 2 | 'c' | {'a','b'} | 0 | "abc" | 3 | 'c'を追加 |
| 4 | 3 | 'a' | {'a','b','c'} | 0 | "abc" | 3 | 重複！'a'を削除、left++ |
| 4続 | 3 | 'a' | {'b','c'} | 1 | "bca" | 3 | 'a'を追加 |
| 5 | 4 | 'b' | {'b','c','a'} | 1 | "bcab" | 3 | 重複！'b'を削除、left++ |
| 5続 | 4 | 'b' | {'c','a'} | 2 | "cab" | 3 | 'b'を追加 |
| 6 | 5 | 'c' | {'c','a','b'} | 2 | "cabc" | 3 | 重複！'c'を削除、left++ |
| 6続 | 5 | 'c' | {'a','b'} | 3 | "abc" | 3 | 'c'を追加 |
| 7 | 6 | 'b' | {'a','b','c'} | 3 | "abcb" | 3 | 重複！'b'を削除、left++ |
| 7続 | 6 | 'b' | {'a','c'} | 4 | "cb" | 3 | 'b'を追加 |
| 8 | 7 | 'b' | {'a','c','b'} | 4 | "cbb" | 3 | 重複！'b'を削除、left++ |
| 8続 | 7 | 'b' | {'c'} | 5 | "bb" | 3 | 重複！'b'を削除、left++ |
| 8続 | 7 | 'b' | {} | 6 | "b" | 3 | 'b'を追加 |

**結果**: `3` - 最長の部分文字列は "abc"（インデックス0-2または3-5）

### 可視化

```
文字列: "abcabcbb"
インデックス: 0 1 2 3 4 5 6 7

ステップ1-3: ウィンドウ拡張
[a b c] a b c b b
 ↑     ↑
left  right
max_length = 3

ステップ4: 重複発生、leftを移動
a [b c a] b c b b
   ↑     ↑
  left  right
max_length = 3

ステップ5: 重複発生、leftを移動
a b [c a b] c b b
     ↑     ↑
    left  right
max_length = 3
```

### 例2: `s = "bbbbb"`

| ステップ | right | s[right] | char_set | left | ウィンドウ | max_length | アクション |
|---------|-------|-----------|----------|------|-----------|------------|-----------|
| 初期 | - | - | {} | 0 | - | 0 | - |
| 1 | 0 | 'b' | {} | 0 | "b" | 1 | 'b'を追加 |
| 2 | 1 | 'b' | {'b'} | 0 | "bb" | 1 | 重複！'b'を削除、left++ |
| 2続 | 1 | 'b' | {} | 1 | "b" | 1 | 'b'を追加 |
| ... | ... | ... | ... | ... | ... | 1 | 同様の処理を繰り返し |

**結果**: `1` - 全て同じ文字のため、最長は1文字

### 例3: `s = "pwwkew"`

| ステップ | right | s[right] | char_set | left | ウィンドウ | max_length | アクション |
|---------|-------|-----------|----------|------|-----------|------------|-----------|
| 1-2 | 0-1 | 'p','w' | {'p','w'} | 0 | "pw" | 2 | 拡張 |
| 3 | 2 | 'w' | {'p','w'} | 0 | "pww" | 2 | 重複！'p'を削除、left++ |
| 3続 | 2 | 'w' | {'w'} | 1 | "ww" | 2 | 重複！'w'を削除、left++ |
| 3続 | 2 | 'w' | {} | 2 | "w" | 2 | 'w'を追加 |
| 4-5 | 3-4 | 'k','e' | {'w','k','e'} | 2 | "wke" | 3 | 拡張 |
| 6 | 5 | 'w' | {'w','k','e'} | 2 | "wkew" | 3 | 重複！'w'を削除、left++ |
| 6続 | 5 | 'w' | {'k','e'} | 3 | "kew" | 3 | 'w'を追加 |

**結果**: `3` - 最長の部分文字列は "wke"（インデックス2-4）

## 現実世界での応用

### 1. テキストエディタの検索機能
- **シナリオ**: ユーザーが入力した文字列で、重複のない最長の部分文字列をハイライト
- **実装**: スライディングウィンドウで、重複のない最長の部分文字列を検出
- **例**: コードエディタで、変数名の候補を表示する際に、重複のない最長の部分文字列を使用

### 2. データ圧縮（LZ77アルゴリズム）
- **シナリオ**: 文字列圧縮で、重複のない最長の部分文字列を見つけて圧縮
- **実装**: スライディングウィンドウで、重複のない最長の部分文字列を検出
- **例**: ZIPファイルの圧縮アルゴリズムで、重複パターンを検出

### 3. ネットワークプロトコル（TCPウィンドウ）
- **シナリオ**: TCP通信で、重複のないデータパケットの最大シーケンスを管理
- **実装**: スライディングウィンドウで、重複のないパケットシーケンスを追跡
- **例**: ネットワーク通信で、パケットの順序と重複を管理

### 4. ゲーム開発（入力処理）
- **シナリオ**: ゲームで、プレイヤーの入力シーケンスから、重複のない最長のコマンドを検出
- **実装**: スライディングウィンドウで、重複のない最長の入力シーケンスを検出
- **例**: コンボシステムで、重複のない最長のコマンドシーケンスを検出

### 5. ログ解析システム
- **シナリオ**: ログファイルで、重複のない最長のイベントシーケンスを検出
- **実装**: スライディングウィンドウで、重複のない最長のイベントシーケンスを検出
- **例**: セキュリティログで、異常なイベントシーケンスを検出

## 注意点と落とし穴

### 1. ウィンドウの縮小タイミング
- **問題**: 重複が発生したとき、`left`をどこまで移動すべきか？
- **解決策**: 重複文字が削除されるまで`left`を右に移動
- **実装**: `while s[right] in char_set:`で、重複がなくなるまで繰り返す

### 2. ハッシュセットの更新
- **問題**: `left`を移動する際に、セットから要素を削除するのを忘れやすい
- **解決策**: `left`を移動するたびに、`s[left]`をセットから削除
- **注意**: 削除を忘れると、重複が正しく検出されない

### 3. 空文字列の扱い
- **問題**: 空文字列の場合の処理
- **解決策**: 最初に空文字列チェックを行い、`0`を返す
- **実装**: `if not s: return 0`

### 4. ウィンドウサイズの計算
- **問題**: ウィンドウのサイズを正しく計算する必要がある
- **解決策**: `right - left + 1`で計算（両端を含む）
- **注意**: `right - left`ではなく、`+1`が必要

### 5. 時間計算量の理解
- **平均**: O(n) - 各文字を最大2回処理（拡張と縮小）
- **最悪**: O(n) - 全ての文字を1回ずつ処理
- **空間**: O(min(m, n)) - mは文字セットのサイズ（通常は26または256）

### 6. 最適化の余地
- **ハッシュマップの使用**: 文字の最後の出現位置を記録することで、`left`を直接ジャンプ可能
- **実装例**:
  ```
  last_seen = {}  // 文字 -> 最後の出現位置
  if s[right] in last_seen:
      left = max(left, last_seen[s[right]] + 1)
  ```
- **メリット**: `while`ループが不要になり、より効率的

### 7. Unicode文字の扱い
- **問題**: Unicode文字（日本語など）が含まれる場合
- **解決策**: ハッシュセットはUnicode文字にも対応可能
- **注意**: 文字セットのサイズが大きくなる可能性がある

## 関連問題

同じテクニック（スライディングウィンドウ）を使う問題：

1. **Longest Substring with At Most K Distinct Characters** - 最大k個の異なる文字を含む最長の部分文字列
2. **Minimum Window Substring** - 文字列tの全ての文字を含む最小の部分文字列
3. **Find All Anagrams in String** - 文字列内のアナグラムを全て見つける
4. **Sliding Window Maximum** - 固定サイズウィンドウの最大値
5. **Maximum Average Subarray I** - 固定サイズウィンドウの平均値

## まとめ

Longest Substring Without Repeating Charactersは、スライディングウィンドウの最も基本的な例です。重要なポイントは：

1. **可変サイズウィンドウ**: 重複が発生するまで拡張し、発生したら縮小
2. **ハッシュセットで重複管理**: O(1)で重複を検出
3. **O(n)時間**: 各文字を最大2回処理（拡張と縮小）
4. **O(min(m,n))空間**: 文字セットのサイズに依存

この問題を理解することで、スライディングウィンドウテクニックの基本が身につきます。

---

**次のステップ**: 
- [スライディングウィンドウのREADME](./README.md)に戻って他の問題も確認
- [ハッシュテーブルテクニック](../01_hash_table/README.md) - スライディングウィンドウとよく組み合わせて使用

