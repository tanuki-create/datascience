# スライディングウィンドウ (Sliding Window)

## 概要

スライディングウィンドウは、配列や文字列の**連続する部分列（サブアレイ/サブストリング）**を効率的に処理するためのテクニックです。二ポインタの特殊なケースとして、固定サイズまたは可変サイズの「ウィンドウ」を配列上で滑らせるように移動させながら処理を行います。

## 基本概念

### スライディングウィンドウのパターン

1. **固定サイズウィンドウ**: ウィンドウのサイズが一定
   - 例: 長さkの部分配列の最大和を求める
   - 用途: 固定サイズのサブアレイの問題

2. **可変サイズウィンドウ**: ウィンドウのサイズが条件に応じて変化
   - 例: 条件を満たす最長の部分文字列を求める
   - 用途: 条件を満たす最長/最短のサブアレイの問題

### 主な操作と計算量

| パターン | 時間計算量 | 空間計算量 | 適用場面 |
|---------|-----------|-----------|---------|
| 固定サイズ | O(n) | O(1) | 固定サイズのサブアレイ |
| 可変サイズ | O(n) | O(k) | 条件を満たす最長/最短のサブアレイ |

**特徴**: 通常はO(n)の時間計算量で、全ての部分列を効率的に処理できます。

## いつ使うべきか

スライディングウィンドウテクニックは以下のような場面で威力を発揮します：

### 1. 連続する部分列の問題
- 「重複のない最長の部分文字列を求める」
- 「条件を満たす最長の部分配列を求める」
- **利点**: 全ての部分列を列挙する必要がなく、効率的に処理

### 2. 固定サイズのサブアレイ
- 「長さkの部分配列の最大和を求める」
- 「長さkの部分配列の平均値を求める」
- **利点**: ウィンドウを1つずつスライドさせることで、重複計算を避けられる

### 3. 文字列マッチング
- 「文字列s内で文字列tの全ての文字を含む最小の部分文字列を求める」
- 「文字列s内で文字列tのアナグラムを全て見つける」
- **利点**: 部分文字列を効率的に探索

### 4. カウント問題
- 「最大k個の異なる文字を含む最長の部分文字列を求める」
- 「条件を満たす部分配列の数を数える」
- **利点**: ウィンドウ内の要素を効率的にカウント

### 5. 最適化問題
- 「条件を満たす最小/最大の部分配列を求める」
- 「条件を満たす部分配列の和の最大/最小を求める」
- **利点**: 貪欲的なアプローチで最適解を効率的に発見

## 現実世界での応用例

### 1. ネットワークトラフィック分析
- **例**: 一定時間内のネットワークトラフィックの最大値を監視
- **実装**: 固定サイズのスライディングウィンドウで、時間窓内のトラフィックを集計
- **メリット**: リアルタイムでトラフィックのピークを検出

### 2. ストリーミングデータの処理
- **例**: 動画ストリーミングで、一定時間内の平均ビットレートを計算
- **実装**: スライディングウィンドウで、最新のNフレームの平均を計算
- **メリット**: リアルタイムで品質を監視

### 3. 金融取引システム
- **例**: 株価データで、過去N日間の移動平均を計算
- **実装**: 固定サイズのスライディングウィンドウで、移動平均を効率的に計算
- **メリット**: リアルタイムでトレンドを分析

### 4. ログ分析システム
- **例**: サーバーログで、一定時間内のエラー発生回数を監視
- **実装**: スライディングウィンドウで、時間窓内のエラーをカウント
- **メリット**: 異常検出をリアルタイムで実行

### 5. 自然言語処理
- **例**: テキスト内で、重複のない最長の単語列を検出
- **実装**: 可変サイズのスライディングウィンドウで、重複を避けながら最長の部分列を探索
- **メリット**: テキストの構造を効率的に解析

## 実装時の注意点

### 1. ウィンドウの拡張と縮小
- **問題**: いつウィンドウを拡張し、いつ縮小するべきか？
- **解決策**: 問題の条件に応じて明確なルールを設定
  - 条件を満たすまで拡張
  - 条件を満たさなくなったら縮小

### 2. ハッシュテーブルとの組み合わせ
- **問題**: ウィンドウ内の要素を効率的に管理する必要がある
- **解決策**: ハッシュテーブルやセットを使用して、要素の存在やカウントを管理
- **例**: 文字の出現回数を`dict`で管理

### 3. 境界条件
- **問題**: ウィンドウが配列の範囲外に出ないようにする
- **解決策**: ループ条件を適切に設定（`right < len(array)`など）
- **注意**: ウィンドウのサイズが0になる場合も考慮

### 4. 重複の処理
- **問題**: ウィンドウ内に重複要素がある場合の処理
- **解決策**: ハッシュセットやカウントマップを使用して重複を管理
- **例**: 文字の出現回数をカウントして、重複を検出

### 5. 時間計算量の理解
- **平均**: O(n) - 各要素を1回ずつ処理
- **最悪**: O(n) - 常に線形時間
- **空間**: O(k) - ウィンドウ内の要素を保存（kはウィンドウの最大サイズ）

### 6. 固定サイズウィンドウの最適化
- **問題**: 固定サイズの場合、毎回和を再計算するのは非効率
- **解決策**: 最初の和を計算し、ウィンドウをスライドさせる際に、出る要素を引き、入る要素を足す
- **例**: `current_sum = current_sum - array[left] + array[right]`

## 関連するLeetCode/AtCoder問題

### Easy
- [Maximum Average Subarray I](../leetcode/easy/) - 固定サイズウィンドウの基本
- [Contains Duplicate II](../leetcode/easy/) - ウィンドウ内の重複検出

### Medium
- [Longest Substring Without Repeating Characters](./longest_substring_no_repeat_logic.md) - 可変サイズウィンドウの典型例
- [Minimum Window Substring](../leetcode/hard/) - より複雑な可変サイズウィンドウ
- [Longest Substring with At Most K Distinct Characters](../leetcode/medium/) - 条件付きウィンドウ

### Hard
- [Minimum Window Substring](../leetcode/hard/) - 高度なスライディングウィンドウ
- [Sliding Window Maximum](../leetcode/hard/) - モノトニックキューとの組み合わせ

## 学習の進め方

1. **Longest Substring Without Repeating Characters**から始める: 可変サイズウィンドウの最も基本的な例
2. **固定サイズウィンドウ**の問題で、ウィンドウのスライド方法を学ぶ
3. **より複雑な条件**の問題で、ハッシュテーブルとの組み合わせを学ぶ

## 次のステップ

- [Longest Substring Without Repeating Characters のロジック解説](./longest_substring_no_repeat_logic.md)
- [二ポインタテクニック](../02_two_pointers/README.md) - スライディングウィンドウの基礎
- [ハッシュテーブルテクニック](../01_hash_table/README.md) - よく組み合わせて使用

---

**重要**: スライディングウィンドウは、連続する部分列の問題で非常に強力なテクニックです。二ポインタとハッシュテーブルを組み合わせることで、O(n²)やO(n³)の問題をO(n)に改善できます。

