# Minimum Window Substring - ロジック解説

## 問題概要

文字列`s`と`t`が与えられたとき、`s`の部分文字列で`t`の全ての文字を含む最小の部分文字列を返す。

**制約**:
- `1 <= s.length, t.length <= 10^5`

**例**:
```
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
説明: "BANC"は"ABC"の全ての文字を含む最小の部分文字列
```

## ロジックの核心

### なぜスライディングウィンドウが有効か？

**全探索（O(n²)）**:
- 全ての部分文字列をチェック
- 時間計算量: O(n²) - 非効率

**スライディングウィンドウを使う理由**:
- **可変サイズウィンドウ**: 条件を満たすまで拡張し、満たしたら縮小
- **ハッシュマップで文字カウント**: `t`の文字の出現回数を効率的に管理
- **時間計算量**: O(n) - 1回の走査で完了

### 思考プロセス

1. **文字カウント**: `t`の各文字の出現回数をカウント
2. **ウィンドウの拡張**: 右ポインタを動かして、必要な文字を全て含むまで拡張
3. **ウィンドウの縮小**: 左ポインタを動かして、最小の部分文字列を探す
4. **最小の追跡**: 見つかった部分文字列の最小を追跡

### アルゴリズムのステップ

```
1. tの文字カウントを作成: need = {}
2. left = 0, right = 0, min_len = inf, min_start = 0
3. right を 0 から n-1 まで:
   a. s[right]をウィンドウに追加
   b. 必要な文字が全て揃ったかチェック
   c. 揃ったら、leftを動かして最小のウィンドウを探す
   d. 最小のウィンドウを更新
4. 最小の部分文字列を返す
```

## 具体例でのトレース

### 例: `s = "ADOBECODEBANC", t = "ABC"`

| ステップ | left | right | ウィンドウ | 必要な文字 | 最小ウィンドウ |
|---------|------|-------|-----------|-----------|--------------|
| 1 | 0 | 5 | "ADOBEC" | A✓B✓C✓ | "ADOBEC" |
| 2 | 0 | 9 | "ADOBECODEBA" | A✓B✓C✓ | "ADOBEC" |
| 3 | 5 | 9 | "CODEBA" | A✓B✓C✗ | "ADOBEC" |
| 4 | 5 | 12 | "CODEBANC" | A✓B✓C✓ | "CODEBANC" |
| 5 | 9 | 12 | "BANC" | A✓B✓C✓ | **"BANC"** |

**結果**: `"BANC"`

## 現実世界での応用

### 1. テキスト検索
- **シナリオ**: 文書内で特定のキーワードを含む最小の範囲を検索
- **実装**: 同様のスライディングウィンドウで効率的に検索

### 2. データ分析
- **シナリオ**: 時系列データで特定の条件を満たす最小の期間を特定
- **実装**: 条件を満たす最小のウィンドウを探索

## 注意点と落とし穴

1. **文字カウントの管理**: ウィンドウ内の文字カウントを正確に管理
2. **条件の判定**: 必要な文字が全て揃ったかを正確に判定
3. **最小の追跡**: 見つかったウィンドウの最小を正確に追跡

## 関連問題

- Longest Substring Without Repeating Characters
- Find All Anagrams in String
- Minimum Window Subsequence

---

**次のステップ**: [スライディングウィンドウのREADME](./README.md)に戻る

