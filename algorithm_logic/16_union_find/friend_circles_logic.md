# Friend Circles (Number of Provinces) - ロジック解説

## 問題概要

n人の友達関係が隣接行列`M`で与えられたとき、友達の輪（連結成分）の数を返す。`M[i][j] = 1`はiとjが友達であることを示す。

**制約**:
- `1 <= n <= 200`
- `M[i][i] = 1`（自分自身は友達）
- `M[i][j] = M[j][i]`（無向グラフ）

**例**:
```
Input: M = [[1,1,0],[1,1,0],[0,0,1]]
Output: 2
説明: 
- 友達の輪1: {0, 1}
- 友達の輪2: {2}
```

## ロジックの核心

### なぜUnion-Findが有効か？

**DFS/BFSアプローチ（O(n²)）**:
- 各ノードからDFS/BFSで連結成分を探索
- 時間計算量: O(n²) - 隣接行列の走査

**Union-Findを使う理由**:
- **効率的な統合**: 2つのノードが友達の場合、Union操作で統合
- **連結成分の数**: ユニークなルートの数が連結成分の数
- **時間計算量**: O(n² × α(n)) - 実用的にはO(n²)

### 思考プロセス

1. **初期化**: 各人を独立した集合として初期化
2. **Union操作**: 友達関係（M[i][j] = 1）ごとにUnion
3. **連結成分の数**: 全ての人のルートを数え、ユニークなルートの数を返す

### アルゴリズムのステップ

```
function findCircleNum(M):
    n = len(M)
    uf = UnionFind(n)
    
    // 友達関係をUnion
    for i in range(n):
        for j in range(i+1, n):
            if M[i][j] == 1:
                uf.union(i, j)
    
    // 連結成分の数を返す
    return uf.count

class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.count = n  // 初期状態ではn個の集合
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  // 経路圧縮
        return self.parent[x]
    
    def union(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)
        
        if rootX == rootY:
            return  // 既に同じ集合
        
        // ランク統合
        if self.rank[rootX] < self.rank[rootY]:
            self.parent[rootX] = rootY
        elif self.rank[rootX] > self.rank[rootY]:
            self.parent[rootY] = rootX
        else:
            self.parent[rootY] = rootX
            self.rank[rootX] += 1
        
        self.count -= 1  // 集合の数を減らす
```

## 具体例でのトレース

### 例: `M = [[1,1,0],[1,1,0],[0,0,1]]`

```
初期状態:
  parent = [0, 1, 2]
  rank = [0, 0, 0]
  count = 3

i=0, j=1: M[0][1] = 1
  find(0) = 0, find(1) = 1
  union(0, 1):
    parent[1] = 0
    rank[0] = 1
    count = 2

i=0, j=2: M[0][2] = 0 → スキップ
i=1, j=2: M[1][2] = 0 → スキップ

最終状態:
  parent = [0, 0, 2]
  rank = [1, 0, 0]
  count = 2

結果: 2
```

## 現実世界での応用

### 1. ソーシャルネットワーク分析
- **シナリオ**: Facebookで、ユーザーのコミュニティを識別
- **実装**: 友達関係をUnion-Findで管理し、コミュニティの数を数える
- **例**: ソーシャルネットワークのクラスタリング
- **メリット**: 大規模なネットワークでも高速に処理

### 2. 組織構造の分析
- **シナリオ**: 企業内の部門やチームの関係を分析
- **実装**: 関係をUnion-Findで管理し、グループの数を数える
- **例**: 組織図の分析
- **メリット**: 組織構造の理解

### 3. ネットワークインフラの管理
- **シナリオ**: データセンターで、サーバー間の接続性をチェック
- **実装**: 接続をUnion-Findで管理し、ネットワークの数を数える
- **例**: ネットワークの障害検出
- **メリット**: ネットワークの健全性を監視

### 4. 画像処理（連結成分の検出）
- **シナリオ**: 画像内の物体を検出し、同じ物体に属するピクセルをグループ化
- **実装**: 隣接するピクセルをUnionして、連結領域を検出
- **例**: 物体の識別とカウント
- **メリット**: 画像解析の効率化

### 5. ゲーム開発（物理エンジン）
- **シナリオ**: 物理シミュレーションで、接触しているオブジェクトをグループ化
- **実装**: 接触しているオブジェクトをUnionして、衝突判定を効率化
- **例**: 物理エンジンの最適化
- **メリット**: 物理計算の高速化

### 6. データベースのクエリ最適化
- **シナリオ**: データベースで、関連するレコードをグループ化
- **実装**: 関連するレコードをUnionして、クエリを効率化
- **例**: データベースのクラスタリング
- **メリット**: クエリの実行時間を短縮

## 注意点と落とし穴

### 1. 経路圧縮の実装
- **問題**: Find操作で、木の高さを削減して効率化
- **解決策**: 探索中に、全てのノードを直接ルートに接続
- **実装**: `self.parent[x] = self.find(self.parent[x])`で再帰的に圧縮
- **メリット**: 時間計算量をO(log n)からO(α(n))に改善

### 2. ランク統合の実装
- **問題**: Union操作で、小さい木を大きい木に統合して効率化
- **解決策**: 各ノードのランク（高さ）を記録し、小さい方を大きい方に統合
- **実装**: `rank`配列を管理し、統合時に更新
- **メリット**: 木の高さを抑制し、時間計算量を改善

### 3. 連結成分の数の管理
- **問題**: 連結成分の数を正確に追跡する必要がある
- **解決策**: Union操作で、2つの集合が統合されるたびにcountを減らす
- **実装**: `self.count -= 1`で管理
- **注意**: 既に同じ集合の場合はcountを減らさない

### 4. 対称行列の処理
- **問題**: 隣接行列が対称であるため、重複して処理しないようにする
- **解決策**: `for j in range(i+1, n):`で、上三角部分のみを処理
- **実装**: 対角線より上のみを処理
- **メリット**: 処理時間を半分に削減

### 5. 時間計算量の理解
- **平均**: O(n² × α(n)) - α(n)は実用的には定数
- **最悪**: O(n² × α(n)) - 常に同じ時間計算量
- **空間**: O(n) - parentとrank配列
- **注意**: 経路圧縮とランク統合により、実用的には定数時間に近い

### 6. 自己ループの処理
- **問題**: M[i][i] = 1は自分自身を友達とするが、これは無視できる
- **解決策**: `for j in range(i+1, n):`で、i < jの場合のみ処理
- **実装**: 対角線より上のみを処理することで、自己ループを回避
- **注意**: 自己ループは連結成分の数に影響しない

### 7. 初期状態の理解
- **問題**: 初期状態では、各要素が独立した集合
- **解決策**: `self.parent[i] = i`と`self.count = n`で初期化
- **実装**: コンストラクタで初期化
- **注意**: 初期化を忘れると、正しく動作しない

### 8. DFS/BFSとの比較
- **問題**: Union-FindとDFS/BFSのどちらを使うべきか？
- **解決策**: 
  - Union-Find: 連結成分の数のみが必要な場合
  - DFS/BFS: 連結成分の詳細な情報が必要な場合
- **メリット**: Union-Findは実装が簡単で、効率的

## 関連問題

- [Redundant Connection](./redundant_connection_logic.md) - サイクルの検出
- [Number of Islands](../10_graph_algorithms/number_of_islands_logic.md) - DFS/BFSアプローチ
- [Accounts Merge](../leetcode/hard/) - Union-Findの応用
- [Graph Valid Tree](../leetcode/medium/) - ツリーの検証

---

**次のステップ**: [Redundant Connection](./redundant_connection_logic.md)でサイクル検出を学ぶ

