# Union-Find (Disjoint Set)

## 概要

Union-Find（Disjoint Set Union、DSU）は、要素の集合を効率的に管理するデータ構造です。**2つの要素が同じ集合に属するか**を高速に判定し、**2つの集合を統合**する操作をサポートします。グラフの連結成分の判定、最小全域木の構築、ネットワークの接続性チェックなどで広く使用されています。

## 基本概念

### Union-Findの操作

1. **Find**: 要素が属する集合の代表（ルート）を見つける
2. **Union**: 2つの集合を1つに統合する
3. **初期化**: 各要素を独立した集合として初期化

### 主な操作と計算量

| 操作 | 時間計算量（経路圧縮 + ランク統合） | 空間計算量 | 適用場面 |
|------|--------------------------------|-----------|---------|
| Find | O(α(n)) | O(n) | 集合の代表を見つける |
| Union | O(α(n)) | O(n) | 2つの集合を統合 |
| 初期化 | O(n) | O(n) | n個の要素を初期化 |

**注意**: α(n)はアッカーマン関数の逆関数で、実用的には定数（5以下）として扱えます。

## いつ使うべきか

Union-Findは以下のような場面で威力を発揮します：

### 1. グラフの連結成分の判定
- 2つのノードが同じ連結成分に属するか判定
- 連結成分の数を数える

### 2. 最小全域木（MST）の構築
- Kruskalのアルゴリズムで、サイクルを検出

### 3. ネットワークの接続性チェック
- ネットワーク内のノードが接続されているか確認

### 4. 画像処理
- 画像内の連結領域を検出

### 5. ゲーム開発
- ゲーム内のオブジェクトのグループ化

## 現実世界での応用例

### 1. ソーシャルネットワーク分析
- **例**: Facebookで、2人のユーザーが同じコミュニティに属するか判定
- **実装**: ユーザーをノード、友達関係をエッジとして、Union-Findで管理
- **メリット**: 大規模なネットワークでも高速に処理

### 2. 画像処理（連結成分の検出）
- **例**: 画像内の物体を検出し、同じ物体に属するピクセルをグループ化
- **実装**: 隣接するピクセルをUnionして、連結領域を検出
- **メリット**: 物体の識別とカウント

### 3. ネットワークインフラの管理
- **例**: データセンターで、サーバー間の接続性をチェック
- **実装**: サーバーをノード、接続をエッジとして、Union-Findで管理
- **メリット**: ネットワークの障害検出

### 4. ゲーム開発（物理エンジン）
- **例**: 物理シミュレーションで、接触しているオブジェクトをグループ化
- **実装**: 接触しているオブジェクトをUnionして、衝突判定を効率化
- **メリット**: 物理計算の高速化

### 5. データベースのクエリ最適化
- **例**: データベースで、関連するレコードをグループ化
- **実装**: 関連するレコードをUnionして、クエリを効率化
- **メリット**: クエリの実行時間を短縮

### 6. 遺伝子解析
- **例**: DNA配列で、関連する遺伝子をグループ化
- **実装**: 関連する遺伝子をUnionして、遺伝子の機能を理解
- **メリット**: 遺伝子の分類と解析

## 実装時の注意点

### 1. 経路圧縮（Path Compression）
- **問題**: Find操作で、木の高さを削減して効率化
- **解決策**: 探索中に、全てのノードを直接ルートに接続
- **実装**: `parent[x] = find(parent[x])`で再帰的に圧縮
- **メリット**: 時間計算量をO(log n)からO(α(n))に改善

### 2. ランク統合（Union by Rank）
- **問題**: Union操作で、小さい木を大きい木に統合して効率化
- **解決策**: 各ノードのランク（高さ）を記録し、小さい方を大きい方に統合
- **実装**: `rank`配列を管理し、統合時に更新
- **メリット**: 木の高さを抑制し、時間計算量を改善

### 3. 初期化
- **問題**: 各要素を独立した集合として初期化する必要がある
- **解決策**: `parent[i] = i`と`rank[i] = 0`で初期化
- **実装**: コンストラクタで初期化
- **注意**: 初期化を忘れると、正しく動作しない

### 4. サイクルの検出
- **問題**: グラフにサイクルがあるか判定
- **解決策**: Union操作で、2つの要素が既に同じ集合に属する場合、サイクルが存在
- **実装**: `find(x) == find(y)`の場合、サイクルが存在
- **メリット**: 最小全域木の構築でサイクルを検出

### 5. 連結成分の数
- **問題**: グラフの連結成分の数を数える
- **解決策**: 各要素のルートを数え、ユニークなルートの数が連結成分の数
- **実装**: 全ての要素のルートをセットに保存し、サイズを返す
- **メリット**: グラフの構造を理解

## 関連するLeetCode/AtCoder問題

### Medium
- [Friend Circles](./friend_circles_logic.md) - Union-Findの基本
- [Redundant Connection](./redundant_connection_logic.md) - サイクルの検出
- [Number of Provinces](./number_of_provinces_logic.md) - 連結成分の数

### Hard
- [Accounts Merge](../leetcode/hard/) - Union-Findの応用
- [Remove Max Number of Edges](../leetcode/hard/) - 複雑なUnion-Find

## 学習の進め方

1. **Friend Circles**から始める: Union-Findの最も基本的な例
2. **Redundant Connection**でサイクル検出を学ぶ: 最小全域木への応用
3. **より複雑な問題**に挑戦: 他のテクニックと組み合わせた使用法を学ぶ

## 次のステップ

- [Friend Circles のロジック解説](./friend_circles_logic.md)
- [Redundant Connection のロジック解説](./redundant_connection_logic.md)
- [グラフアルゴリズムテクニック](../10_graph_algorithms/README.md) - Union-Findと組み合わせて使用

---

**重要**: Union-Findは、グラフの連結成分を効率的に管理する強力なデータ構造です。経路圧縮とランク統合を組み合わせることで、実用的には定数時間に近い性能を実現できます。

