# Binary Tree Level Order Traversal - ロジック解説

## 問題概要

二分木をレベル順（幅優先）に走査し、各レベルのノードの値を返す。

**例**:
```
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]
```

## ロジックの核心

### BFS（キューを使ったアプローチ）

**考え方**:
- キューを使って、レベルごとにノードを処理
- 各レベルのサイズを記録して、レベルごとに結果を保存

### アルゴリズムのステップ

```
1. キューにrootを追加
2. キューが空になるまで:
   a. 現在のレベルのサイズを記録
   b. そのサイズ分だけノードを処理:
      - ノードの値を結果に追加
      - 子ノードをキューに追加
   c. レベルを結果に追加
3. 結果を返す
```

## 具体例でのトレース

```
レベル0: [3]
レベル1: [9, 20]
レベル2: [15, 7]

キュー: [3] → [9,20] → [15,7] → []
結果: [[3], [9,20], [15,7]]
```

## 現実世界での応用

### 1. ネットワークの階層構造
- **シナリオ**: ネットワークの階層をレベルごとに処理
- **実装**: BFSでレベルごとにノードを処理

### 2. 組織構造の表示
- **シナリオ**: 組織の階層をレベルごとに表示
- **実装**: 同様のBFSでレベルごとに処理

## 注意点と落とし穴

1. **キューサイズの記録**: 各レベルの開始時にサイズを記録する必要がある
2. **nullチェック**: 子ノードがnullの場合の処理
3. **空の木**: 空の木の場合は空のリストを返す

## 関連問題

- Binary Tree Zigzag Level Order Traversal
- Binary Tree Right Side View
- Average of Levels in Binary Tree

---

**次のステップ**: [グラフアルゴリズム](../10_graph_algorithms/README.md)でグラフでのBFS/DFSを学ぶ

