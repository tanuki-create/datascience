# Binary Tree Level Order Traversal - ロジック解説

## 問題概要

二分木をレベル順（幅優先）に走査し、各レベルのノードの値を返す。

**例**:
```
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]
```

## ロジックの核心

### BFS（キューを使ったアプローチ）

**考え方**:
- キューを使って、レベルごとにノードを処理
- 各レベルのサイズを記録して、レベルごとに結果を保存

### アルゴリズムのステップ

```
1. キューにrootを追加
2. キューが空になるまで:
   a. 現在のレベルのサイズを記録
   b. そのサイズ分だけノードを処理:
      - ノードの値を結果に追加
      - 子ノードをキューに追加
   c. レベルを結果に追加
3. 結果を返す
```

## 具体例でのトレース

```
レベル0: [3]
レベル1: [9, 20]
レベル2: [15, 7]

キュー: [3] → [9,20] → [15,7] → []
結果: [[3], [9,20], [15,7]]
```

## 現実世界での応用

### 1. ネットワークの階層構造の処理
- **シナリオ**: ネットワークの階層をレベルごとに処理
- **実装**: BFSでレベルごとにノードを処理
- **例**: ネットワークトポロジーで、各階層のノードを順次処理
- **メリット**: ネットワークの構造を効率的に解析

### 2. 組織構造の可視化
- **シナリオ**: 組織の階層をレベルごとに表示
- **実装**: 同様のBFSでレベルごとに処理
- **例**: 企業の組織図を階層ごとに表示し、各階層の従業員を一覧表示
- **メリット**: 組織構造を視覚的に理解しやすくする

### 3. ファイルシステムの階層表示
- **シナリオ**: ディレクトリ構造を階層ごとに表示
- **実装**: ディレクトリツリーをBFSで走査
- **例**: ファイルエクスプローラーで、各階層のファイルとフォルダを表示
- **メリット**: ディレクトリ構造を効率的にナビゲート

### 4. ゲームのレベルデザイン
- **シナリオ**: ゲームのレベル構造を階層ごとに処理
- **実装**: ゲームの状態空間をBFSで探索
- **例**: パズルゲームで、各レベルの状態を順次処理
- **メリット**: ゲームの進行を効率的に管理

### 5. データベースの階層クエリ
- **シナリオ**: 階層データをレベルごとにクエリ
- **実装**: 階層データをBFSで走査
- **例**: カテゴリツリーで、各階層のカテゴリを順次取得
- **メリット**: 階層データを効率的に処理

### 6. ソーシャルネットワークの分析
- **シナリオ**: ソーシャルネットワークの階層をレベルごとに分析
- **実装**: ネットワークグラフをBFSで探索
- **例**: SNSで、ユーザーの友達関係を階層ごとに分析
- **メリット**: ネットワークの構造を理解し、影響範囲を分析

## 注意点と落とし穴

### 1. キューサイズの記録の重要性
- **問題**: 各レベルの開始時にサイズを記録する必要がある
- **解決策**: `level_size = len(queue)`で現在のレベルのサイズを記録
- **理由**: キューに追加しながら処理するため、サイズが変動する
- **実装**: 
  ```
  while queue:
      level_size = len(queue)  # 現在のレベルのサイズを記録
      level = []
      for _ in range(level_size):  # そのサイズ分だけ処理
          node = queue.popleft()
          level.append(node.val)
          if node.left: queue.append(node.left)
          if node.right: queue.append(node.right)
      result.append(level)
  ```
- **注意**: サイズを記録しないと、次のレベルのノードも同じレベルとして処理されてしまう

### 2. nullチェックの徹底
- **問題**: 子ノードがnullの場合の処理が重要
- **解決策**: 子ノードをキューに追加する前にnullチェックを行う
- **注意**: nullをキューに追加すると、後でエラーが発生する
- **実装**: `if node.left: queue.append(node.left)`

### 3. 空の木の処理
- **問題**: 空の木（rootがnull）の場合は空のリストを返す必要がある
- **解決策**: 最初に`if not root: return []`をチェック
- **注意**: 空の木を処理しないと、キューが空のままループが実行されない

### 4. キューの実装の選択
- **問題**: Pythonの`list`をキューとして使うと非効率（`pop(0)`がO(n)）
- **解決策**: `collections.deque`を使用（`popleft()`がO(1)）
- **実装**: `from collections import deque`して`queue = deque([root])`を使用
- **メリット**: 時間計算量をO(n)に保つ

### 5. 時間計算量の理解
- **平均**: O(n) - 各ノードを1回ずつ処理
- **最悪**: O(n) - 常に線形時間
- **空間**: O(w) - wは最大幅（キューに保存される最大ノード数）
- **注意**: 完全二分木の場合、最後のレベルに約n/2個のノードがあるため、空間計算量はO(n)

### 6. DFSとの比較
- **BFSの利点**: レベルごとの処理が自然、最短経路を保証
- **DFSの利点**: メモリ使用量が少ない（O(h) vs O(w)）
- **選択**: レベルごとの処理が必要な場合はBFS、深さ優先の探索が必要な場合はDFS

## 関連問題

- Binary Tree Zigzag Level Order Traversal
- Binary Tree Right Side View
- Average of Levels in Binary Tree

---

**次のステップ**: [グラフアルゴリズム](../10_graph_algorithms/README.md)でグラフでのBFS/DFSを学ぶ

