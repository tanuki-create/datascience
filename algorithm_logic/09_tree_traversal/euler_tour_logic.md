# オイラーツアー (Euler Tour) - ロジック解説

## 問題概要

オイラーツアーは、**木をDFSで探索し、各ノードの訪問時刻を記録する**テクニックです。各ノードに2つの時刻（入時刻と出時刻）を記録することで、部分木のクエリを区間クエリに変換できます。セグメント木やFenwick Treeと組み合わせて使用されます。

**例**:
```
木:
    1
   / \
  2   3
 / \
4   5

オイラーツアー: [1, 2, 4, 4, 5, 5, 2, 3, 3, 1]
入時刻: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
出時刻: [9, 6, 3, 3, 5, 5, 6, 8, 8, 9]
```

## ロジックの核心

### なぜオイラーツアーが有効か？

**全探索（O(n)）**:
- 部分木のクエリで毎回DFSを実行
- 時間計算量: O(n) per query - 非効率

**オイラーツアーを使う理由**:
- **部分木の線形化**: 部分木を連続する区間に変換
- **時間計算量**: O(log n) per query - セグメント木と組み合わせ
- **空間計算量**: O(n) - 時刻配列

### アルゴリズムのステップ

```
function eulerTour(tree, root):
    n = len(tree)
    in_time = [0] * n
    out_time = [0] * n
    euler = []
    time = 0
    
    function dfs(node, parent):
        in_time[node] = time
        euler.append(node)
        time += 1
        
        for child in tree[node]:
            if child != parent:
                dfs(child, node)
        
        out_time[node] = time - 1
        euler.append(node)
        time += 1
    
    dfs(root, -1)
    return in_time, out_time, euler
```

### 具体例でのトレース

#### 例: オイラーツアーの構築

**木**:
```
    1
   / \
  2   3
 / \
4   5
```

**DFSでの構築**:
```
DFS(1, -1):
  in_time[1] = 0
  euler = [1]
  time = 1
  
  DFS(2, 1):
    in_time[2] = 1
    euler = [1, 2]
    time = 2
    
    DFS(4, 2):
      in_time[4] = 2
      euler = [1, 2, 4]
      time = 3
      
      // 葉ノードなので子ノードなし
      out_time[4] = 2
      euler = [1, 2, 4, 4]
      time = 3
    
    DFS(5, 2):
      in_time[5] = 3
      euler = [1, 2, 4, 4, 5]
      time = 4
      
      // 葉ノードなので子ノードなし
      out_time[5] = 3
      euler = [1, 2, 4, 4, 5, 5]
      time = 4
    
    out_time[2] = 5
    euler = [1, 2, 4, 4, 5, 5, 2]
    time = 5
  
  DFS(3, 1):
    in_time[3] = 5
    euler = [1, 2, 4, 4, 5, 5, 2, 3]
    time = 6
    
    // 葉ノードなので子ノードなし
    out_time[3] = 5
    euler = [1, 2, 4, 4, 5, 5, 2, 3, 3]
    time = 6
  
  out_time[1] = 7
  euler = [1, 2, 4, 4, 5, 5, 2, 3, 3, 1]
  time = 7

結果:
in_time = [0, 1, 5, 2, 3]
out_time = [7, 5, 5, 2, 3]
euler = [1, 2, 4, 4, 5, 5, 2, 3, 3, 1]
```

#### 部分木のクエリへの応用

**問題**: ノード2を根とする部分木の合計値を求める

```
ノード2の部分木: {2, 4, 5}
in_time[2] = 1
out_time[2] = 5

区間[1, 5]の合計を計算:
euler[1:6] = [2, 4, 4, 5, 5]
→ セグメント木で区間[1, 5]の合計を計算
```

## 現実世界での応用

### 1. 部分木のクエリ
- **シナリオ**: 部分木の合計、最小値、最大値を効率的に計算
- **実装**: オイラーツアーで部分木を区間に変換
- **メリット**: O(log n)で部分木のクエリを処理

### 2. LCA（最小共通祖先）
- **シナリオ**: 2頂点の最小共通祖先を効率的に計算
- **実装**: オイラーツアーとセグメント木でLCAを計算
- **メリット**: O(log n)でLCAを計算

### 3. パスのクエリ
- **シナリオ**: 2頂点間のパスの情報を効率的に計算
- **実装**: オイラーツアーでパスを区間に変換
- **メリット**: 効率的なパスクエリ

### 4. 部分木の更新
- **シナリオ**: 部分木の値を一括更新
- **実装**: オイラーツアーと遅延評価セグメント木で更新
- **メリット**: O(log n)で部分木を更新

### 5. 木の構造の解析
- **シナリオ**: 木の構造を線形に表現
- **実装**: オイラーツアーで木を線形化
- **メリット**: 木の構造の理解と解析

### 6. データベースのクエリ
- **シナリオ**: 階層データのクエリを効率化
- **実装**: オイラーツアーで階層データを線形化
- **メリット**: 効率的なデータベースクエリ

## 注意点と落とし穴

### 1. 入時刻と出時刻の管理
- **問題**: 入時刻と出時刻を正確に記録
- **解決策**: DFSの開始時と終了時に記録
- **実装**: `in_time[node] = time`と`out_time[node] = time - 1`
- **注意**: 時刻を間違えると結果が間違う

### 2. 部分木の区間の決定
- **問題**: 部分木をどの区間にマッピングするか
- **解決策**: `[in_time[node], out_time[node]]`が部分木の区間
- **実装**: 入時刻から出時刻までの区間を使用
- **注意**: 区間を間違えると結果が間違う

### 3. セグメント木との組み合わせ
- **問題**: セグメント木のサイズを決定
- **解決策**: オイラーツアーの長さ（2n-1）を使用
- **実装**: `size = 2 * n - 1`
- **注意**: サイズを間違えるとインデックスエラー

### 4. 重み付きエッジの処理
- **問題**: エッジに重みがある場合の処理
- **解決策**: ノードに重みを割り当て
- **実装**: エッジの重みをノードの値に変換
- **注意**: 重みの割り当て方法に注意

### 5. 更新の処理
- **問題**: ノードの値を更新する場合の処理
- **解決策**: セグメント木で対応する位置を更新
- **実装**: `update(in_time[node], new_value)`
- **注意**: 更新位置を間違えると結果が間違う

### 6. メモリ使用量
- **問題**: O(n)のメモリが必要
- **解決策**: 必要に応じて最適化
- **実装**: 不要な情報を削除
- **注意**: メモリ制約がある場合は注意

### 7. 時間計算量
- **問題**: 構築にO(n)、クエリにO(log n)
- **解決策**: 効率的な実装を心がける
- **実装**: セグメント木と組み合わせて使用
- **注意**: 実装によっては時間計算量が変わる

## 関連問題

- [Subtree Queries](../leetcode/hard/) - 部分木のクエリ
- [LCA (Lowest Common Ancestor)](./lowest_common_ancestor_logic.md) - 最小共通祖先
- [Path Queries](../leetcode/hard/) - パスのクエリ

---

**次のステップ**: [木の探索README](./README.md)で木の探索の全体像を学ぶ

