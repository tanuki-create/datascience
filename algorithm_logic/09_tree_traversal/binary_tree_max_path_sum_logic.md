# Binary Tree Maximum Path Sum - ロジック解説

## 問題概要

二分木のルートが与えられたとき、任意のノードから任意のノードへのパスで、ノード値の和の最大値を返す。

**制約**:
- ノード数は最大3×10^4
- `-1000 <= node.val <= 1000`

**例**:
```
Input: root = [1,2,3]
Output: 6
説明: 2→1→3のパスで和は6

Input: root = [-10,9,20,null,null,15,7]
Output: 42
説明: 15→20→7のパスで和は42
```

## ロジックの核心

### なぜDFSが有効か？

**全探索（O(n²)）**:
- 全てのノードのペアをチェック
- 時間計算量: O(n²) - 非効率

**DFSを使う理由**:
- **部分問題**: 各ノードで、そのノードを通る最大パス和を計算
- **時間計算量**: O(n) - 各ノードを1回ずつ処理
- **空間計算量**: O(h) - 再帰の深さ

### 思考プロセス

1. **部分問題**: 各ノードで、そのノードを通る最大パス和を計算
2. **遷移**: `max_path = node.val + max(0, left) + max(0, right)`
3. **返り値**: 親ノードに返す値は`node.val + max(0, left, right)`

### アルゴリズムのステップ

```
function maxPathSum(root):
    max_sum = float('-inf')
    
    function dfs(node):
        if not node:
            return 0
        
        // 左右の子から最大の貢献を取得（負の場合は0）
        left = max(0, dfs(node.left))
        right = max(0, dfs(node.right))
        
        // このノードを通る最大パス和
        current = node.val + left + right
        max_sum = max(max_sum, current)
        
        // 親ノードに返す値（片方の子のみ）
        return node.val + max(left, right)
    
    dfs(root)
    return max_sum
```

## 具体例でのトレース

### 例: `root = [-10,9,20,null,null,15,7]`

```
dfs(-10):
  left = max(0, dfs(9)) = max(0, 9) = 9
  right = max(0, dfs(20)) = max(0, 35) = 35
  current = -10 + 9 + 35 = 34
  max_sum = max(-inf, 34) = 34
  return -10 + max(9, 35) = 25

dfs(9):
  left = 0, right = 0
  current = 9
  max_sum = max(34, 9) = 34
  return 9

dfs(20):
  left = max(0, dfs(15)) = max(0, 15) = 15
  right = max(0, dfs(7)) = max(0, 7) = 7
  current = 20 + 15 + 7 = 42
  max_sum = max(34, 42) = 42
  return 20 + max(15, 7) = 35

結果: 42
```

## 現実世界での応用

### 1. データ分析
- **シナリオ**: データ分析で、時系列データの最大サブアレイ和を計算
- **実装**: 最大パス和で最大サブアレイ和を計算
- **メリット**: 効率的なデータ分析

### 2. 金融取引
- **シナリオ**: 金融取引で、利益の最大和を計算
- **実装**: 最大パス和で利益の最大和を計算
- **メリット**: 効率的な金融分析

### 3. ゲーム開発
- **シナリオ**: ゲームで、スコアの最大和を計算
- **実装**: 最大パス和でスコアの最大和を計算
- **メリット**: 効率的なゲーム処理

### 4. ネットワーク分析
- **シナリオ**: ネットワークで、トラフィックの最大和を計算
- **実装**: 最大パス和でトラフィックの最大和を計算
- **メリット**: 効率的なネットワーク分析

### 5. 画像処理
- **シナリオ**: 画像処理で、ピクセル値の最大和を計算
- **実装**: 最大パス和でピクセル値の最大和を計算
- **メリット**: 効率的な画像処理

### 6. ログ分析
- **シナリオ**: ログ分析で、イベントの最大和を計算
- **実装**: 最大パス和でイベントの最大和を計算
- **メリット**: 効率的なログ分析

## 注意点と落とし穴

### 1. 負の値の処理
- **問題**: 負の値の貢献を無視する必要がある
- **解決策**: `max(0, dfs(node))`で負の値を0に
- **実装**: 負の貢献は無視して、0を返す
- **注意**: 負の値を無視することで、最大和を正確に計算

### 2. パスの定義
- **問題**: パスは任意のノードから任意のノードへ
- **解決策**: 各ノードで、そのノードを通る最大パス和を計算
- **実装**: 左右の子の貢献を合計
- **注意**: パスの定義を正確に理解する必要がある

### 3. 返り値の理解
- **問題**: 親ノードに返す値は片方の子のみ
- **解決策**: `return node.val + max(left, right)`
- **実装**: 片方の子のみを選択（両方は選択できない）
- **注意**: 返り値と最大和の計算が異なる

### 4. 時間計算量の理解
- **平均**: O(n) - 各ノードを1回ずつ処理
- **最悪**: O(n) - 常に同じ時間計算量
- **空間**: O(h) - 再帰の深さ
- **メリット**: 効率的なアルゴリズム

### 5. エッジケースの処理
- **問題**: 全てのノードが負の値、1つのノード、空の木
- **解決策**: 各操作でエッジケースをチェック
- **実装**: `if not node: return 0`などのチェック
- **注意**: エッジケースを忘れると、誤った結果が返される

### 6. グローバル変数の使用
- **問題**: 最大和を追跡する必要がある
- **解決策**: グローバル変数または参照渡しを使用
- **実装**: `max_sum`をグローバル変数として管理
- **注意**: グローバル変数の管理が重要

### 7. 初期値の設定
- **問題**: 最大和の初期値を`-inf`に設定
- **解決策**: `max_sum = float('-inf')`で初期化
- **実装**: 全てのノードが負の値の場合も正しく処理
- **注意**: 初期値を0にすると、全て負の場合に誤った結果が返される

### 8. パスの復元
- **問題**: 最大和だけでなく、パス自体を取得する必要がある場合
- **解決策**: パスを記録しながら探索
- **実装**: `path`配列でパスを記録
- **注意**: パスの復元には追加の空間が必要

## 関連問題

- [Maximum Depth of Binary Tree](./maximum_depth_logic.md) - 木の深さ
- [Lowest Common Ancestor](./lowest_common_ancestor_logic.md) - 最小共通祖先
- [Path Sum](../leetcode/easy/) - パス和の判定
- [Maximum Subarray](../08_greedy/maximum_subarray_logic.md) - 配列版

---

**次のステップ**: [Serialize and Deserialize Binary Tree](./serialize_deserialize_tree_logic.md)でシリアライゼーションを学ぶ

