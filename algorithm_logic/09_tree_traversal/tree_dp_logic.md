# 木DP (Tree DP) - ロジック解説

## 問題概要

木DPは、**木構造での動的計画法**です。各ノードで部分問題を解き、子ノードの結果を組み合わせて親ノードの解を構築します。木の最適化問題、カウント問題、判定問題などで使用されます。典型的にはDFSでボトムアップに計算します。

**例**: 木の独立集合の最大サイズ
```
木:
    1
   / \
  2   3
 / \
4   5

最大独立集合: {1, 4, 5} (サイズ3)
```

## ロジックの核心

### なぜ木DPが有効か？

**全探索（O(2^n)）**:
- 全ての可能なノードの選択を試す
- 時間計算量: 指数時間 - 非効率

**木DPを使う理由**:
- **部分問題の再利用**: 各ノードで部分問題を解く
- **時間計算量**: O(n) - 各ノードを1回ずつ処理
- **空間計算量**: O(n) - 各ノードの状態を保存

### アルゴリズムのステップ

#### 基本的な構造

```
function treeDP(root):
    // dp[node][state] = ノードnodeで状態stateの場合の最適解
    
    function dfs(node):
        // 葉ノードの処理
        if not node.children:
            return base_case
        
        // 子ノードの結果を集約
        for child in node.children:
            child_result = dfs(child)
            // 子ノードの結果を組み合わせ
        
        // 現在のノードの状態を計算
        result = combine(child_results)
        return result
    
    return dfs(root)
```

### 具体例でのトレース

#### 例1: 木の独立集合の最大サイズ

**木**:
```
    1
   / \
  2   3
 / \
4   5
```

**DPの定義**:
```
dp[node][0] = ノードnodeを選ばない場合の最大サイズ
dp[node][1] = ノードnodeを選ぶ場合の最大サイズ
```

**DFSでの計算**:
```
DFS(1):
  子ノード: [2, 3]
  
  DFS(2):
    子ノード: [4, 5]
    
    DFS(4):
      葉ノード
      dp[4][0] = 0
      dp[4][1] = 1
      return (0, 1)
    
    DFS(5):
      葉ノード
      dp[5][0] = 0
      dp[5][1] = 1
      return (0, 1)
    
    // ノード2の計算
    dp[2][0] = max(dp[4][0], dp[4][1]) + max(dp[5][0], dp[5][1])
             = max(0, 1) + max(0, 1) = 1 + 1 = 2
    dp[2][1] = dp[4][0] + dp[5][0] + 1 = 0 + 0 + 1 = 1
    return (2, 1)
  
  DFS(3):
    葉ノード
    dp[3][0] = 0
    dp[3][1] = 1
    return (0, 1)
  
  // ノード1の計算
  dp[1][0] = max(dp[2][0], dp[2][1]) + max(dp[3][0], dp[3][1])
           = max(2, 1) + max(0, 1) = 2 + 1 = 3
  dp[1][1] = dp[2][0] + dp[3][0] + 1 = 2 + 0 + 1 = 3
  
  結果: max(dp[1][0], dp[1][1]) = max(3, 3) = 3
```

#### 例2: 木の直径

**木**:
```
    1
   / \
  2   3
 / \
4   5
```

**DPの定義**:
```
dp[node] = ノードnodeを根とする部分木の最大深さ
max_diameter = 各ノードで、2つの最深の子ノードの距離の最大値
```

**DFSでの計算**:
```
DFS(1):
  子ノード: [2, 3]
  
  DFS(2):
    子ノード: [4, 5]
    
    DFS(4):
      葉ノード
      dp[4] = 0
      return 0
    
    DFS(5):
      葉ノード
      dp[5] = 0
      return 0
    
    // ノード2の計算
    depths = [dp[4] + 1, dp[5] + 1] = [1, 1]
    dp[2] = max(depths) = 1
    diameter_at_2 = sum(sorted(depths)[-2:]) = 1 + 1 = 2
    return 1
  
  DFS(3):
    葉ノード
    dp[3] = 0
    return 0
  
  // ノード1の計算
  depths = [dp[2] + 1, dp[3] + 1] = [2, 1]
  dp[1] = max(depths) = 2
  diameter_at_1 = sum(sorted(depths)[-2:]) = 2 + 1 = 3
  
  結果: max(diameter_at_1, diameter_at_2) = max(3, 2) = 3
```

## 現実世界での応用

### 1. 木の最適化問題
- **シナリオ**: 木構造での最適な選択を求める
- **実装**: 木DPで最適解を計算
- **メリット**: 効率的な最適化

### 2. カウント問題
- **シナリオ**: 条件を満たすノードの選択の数を数える
- **実装**: 木DPでカウントを計算
- **メリット**: 効率的なカウント

### 3. 判定問題
- **シナリオ**: 条件を満たす選択が存在するか判定
- **実装**: 木DPで判定を計算
- **メリット**: 効率的な判定

### 4. ゲーム理論
- **シナリオ**: 木構造でのゲームの最適戦略
- **実装**: 木DPでゲーム状態を管理
- **メリット**: 効率的なゲーム解析

### 5. ネットワーク設計
- **シナリオ**: ネットワークの最適な構造を設計
- **実装**: 木DPでネットワークを最適化
- **メリット**: 効率的なネットワーク設計

### 6. 組織構造の最適化
- **シナリオ**: 組織の階層構造を最適化
- **実装**: 木DPで組織構造を最適化
- **メリット**: 効率的な組織設計

## 注意点と落とし穴

### 1. 再帰の構造
- **問題**: DFSでボトムアップに計算
- **解決策**: 子ノードの結果を集約して親ノードを計算
- **実装**: 再帰関数で子ノードを先に処理
- **注意**: トップダウンとボトムアップを混同しない

### 2. 状態の定義
- **問題**: 各ノードでどのような状態を管理するか
- **解決策**: 問題に応じて適切な状態を定義
- **実装**: `dp[node][state]`など
- **注意**: 状態の定義を間違えると結果が間違う

### 3. 子ノードの結果の組み合わせ
- **問題**: 複数の子ノードの結果をどう組み合わせるか
- **解決策**: 問題に応じて適切な演算を選択
- **実装**: `max`, `min`, `sum`など
- **注意**: 組み合わせ方を間違えると結果が間違う

### 4. ベースケースの処理
- **問題**: 葉ノードの処理が重要
- **解決策**: 葉ノードで適切な値を返す
- **実装**: `if not node.children: return base_case`
- **注意**: ベースケースを間違えると結果が間違う

### 5. メモ化
- **問題**: 同じノードが複数回計算される可能性
- **解決策**: 通常は不要（各ノードは1回だけ訪問）
- **実装**: 必要に応じてメモ化を追加
- **注意**: 木構造では通常メモ化は不要

### 6. ルートの選択
- **問題**: ルートをどこに選ぶか
- **解決策**: 任意のノードをルートに選べる
- **実装**: 通常は問題で指定される
- **注意**: ルートの選択によって結果が変わる場合がある

### 7. 有向木と無向木
- **問題**: 有向木と無向木の扱いが異なる
- **解決策**: 無向木は親ノードを記録して有向木として扱う
- **実装**: `parent`パラメータを使用
- **注意**: 親ノードに戻らないようにする

## 関連問題

- [Binary Tree Maximum Path Sum](./binary_tree_max_path_sum_logic.md) - パスの最大和
- [House Robber III](../leetcode/medium/) - 木の独立集合
- [Diameter of Binary Tree](../leetcode/easy/) - 木の直径
- [Sum of Distances in Tree](../leetcode/hard/) - 距離の和

---

**次のステップ**: [木の直径](./tree_diameter_logic.md)で木の性質を学ぶ

