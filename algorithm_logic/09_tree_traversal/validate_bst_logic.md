# Validate Binary Search Tree - ロジック解説

## 問題概要

二分探索木のルートが与えられたとき、有効な二分探索木かどうかを判定する。

**制約**:
- ノード数は最大10^4

**例**:
```
Input: root = [2,1,3]
Output: true

Input: root = [5,1,4,null,null,3,6]
Output: false
```

## ロジックの核心

### なぜDFSが有効か？

**全探索（非効率）**:
- 全てのノードをチェックして、BSTの性質を検証
- 時間計算量: O(n) - 各ノードを1回ずつ処理

**DFSを使う理由**:
- **範囲の伝播**: 各ノードで有効な値の範囲を伝播
- **時間計算量**: O(n) - 各ノードを1回ずつ処理
- **空間計算量**: O(h) - 再帰の深さ

### 思考プロセス

1. **範囲の管理**: 各ノードで有効な値の範囲[min, max]を管理
2. **検証**: ノードの値が範囲内にあるかチェック
3. **再帰**: 左右の子ノードに範囲を伝播

### アルゴリズムのステップ

```
function isValidBST(root):
    return validate(root, float('-inf'), float('inf'))

function validate(node, min_val, max_val):
    if not node:
        return True
    
    if node.val <= min_val or node.val >= max_val:
        return False
    
    return (validate(node.left, min_val, node.val) and 
            validate(node.right, node.val, max_val))
```

## 具体例でのトレース

### 例: `root = [5,1,4,null,null,3,6]`

```
validate(5, -inf, inf):
  node.val=5, min=-inf, max=inf → OK
  left: validate(1, -inf, 5)
    node.val=1, min=-inf, max=5 → OK
    left: validate(null) → True
    right: validate(null) → True
  right: validate(4, 5, inf)
    node.val=4, min=5, max=inf → 4 < 5 → False

結果: False
```

## 現実世界での応用

### 1. データベースのインデックス
- **シナリオ**: データベースで、B-treeインデックスの整合性をチェック
- **実装**: BSTの検証で整合性をチェック
- **メリット**: 効率的なデータベース管理

### 2. 検索エンジン
- **シナリオ**: 検索エンジンで、インデックスの整合性をチェック
- **実装**: BSTの検証で整合性をチェック
- **メリット**: 効率的な検索

### 3. ファイルシステム
- **シナリオ**: ファイルシステムで、ディレクトリ構造の整合性をチェック
- **実装**: BSTの検証で整合性をチェック
- **メリット**: 効率的なファイル管理

### 4. ゲーム開発
- **シナリオ**: ゲームで、データ構造の整合性をチェック
- **実装**: BSTの検証で整合性をチェック
- **メリット**: 効率的なゲーム処理

### 5. コンパイラ
- **シナリオ**: コンパイラで、構文木の整合性をチェック
- **実装**: BSTの検証で整合性をチェック
- **メリット**: 効率的なコンパイル

### 6. ネットワークルーティング
- **シナリオ**: ネットワークで、ルーティングテーブルの整合性をチェック
- **実装**: BSTの検証で整合性をチェック
- **メリット**: 効率的なルーティング

## 注意点と落とし穴

### 1. 範囲の管理
- **問題**: 各ノードで有効な値の範囲を正確に管理する必要がある
- **解決策**: min_valとmax_valで範囲を管理
- **実装**: 左の子にはmax_valを、右の子にはmin_valを伝播
- **注意**: 範囲の管理が重要

### 2. 等号の扱い
- **問題**: BSTの定義で、等号を含めるかどうか
- **解決策**: 通常は等号を含めない（`node.val <= min_val`）
- **実装**: 問題の要件に応じて調整
- **注意**: 等号の扱いを明確にする必要がある

### 3. 時間計算量の理解
- **平均**: O(n) - 各ノードを1回ずつ処理
- **最悪**: O(n) - 常に同じ時間計算量
- **空間**: O(h) - 再帰の深さ（hは木の高さ）
- **注意**: 最悪の場合、h=n（線形木）

### 4. 中順走査との比較
- **問題**: 中順走査でソート順をチェックする方法もある
- **解決策**: 中順走査で値を収集し、ソート順をチェック
- **実装**: 中順走査で値を収集し、`values == sorted(set(values))`をチェック
- **注意**: この方法は追加の空間が必要

### 5. エッジケースの処理
- **問題**: 空の木、1つのノード、同じ値のノード
- **解決策**: 各操作でエッジケースをチェック
- **実装**: `if not node: return True`などのチェック
- **注意**: エッジケースを忘れると、エラーが発生

### 6. 整数オーバーフロー
- **問題**: ノードの値が非常に大きい/小さい場合
- **解決策**: `float('inf')`と`float('-inf')`を使用
- **実装**: 無限大を使用して範囲を管理
- **注意**: 整数オーバーフローに注意

### 7. 再帰の深さ
- **問題**: 深い木でスタックオーバーフローが発生する可能性
- **解決策**: 反復的実装を使用
- **実装**: スタックを使用して反復的に実装
- **注意**: 深い木では反復的実装が推奨

### 8. 部分木の検証
- **問題**: 部分木がBSTかどうかを検証する必要がある場合
- **解決策**: 同じロジックを部分木に適用
- **実装**: 部分木のルートから検証を開始
- **注意**: 部分木の検証も同様に実装可能

## 関連問題

- [Maximum Depth of Binary Tree](./maximum_depth_logic.md) - 木の深さ
- [Binary Tree Level Order Traversal](./level_order_traversal_logic.md) - レベル順走査
- [Lowest Common Ancestor](./lowest_common_ancestor_logic.md) - 最小共通祖先
- [Kth Smallest Element in BST](../leetcode/medium/) - BSTの応用

---

**次のステップ**: [Lowest Common Ancestor](./lowest_common_ancestor_logic.md)で最小共通祖先を学ぶ

