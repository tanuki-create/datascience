# Course Schedule (Graph) - ロジック解説

## 問題概要

n個のコースと前提条件のリストが与えられたとき、全てのコースを完了できるか（サイクルがないか）を判定する。

**制約**:
- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= 5000`

**例**:
```
Input: numCourses = 2, prerequisites = [[1,0]]
Output: true

Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
```

## ロジックの核心

### なぜトポロジカルソートが有効か？

**DFSでサイクル検出（O(V + E)）**:
- DFSでサイクルを検出
- 時間計算量: O(V + E) - 線形時間

**トポロジカルソートを使う理由**:
- **サイクルの検出**: トポロジカルソートが完了すればサイクルなし
- **時間計算量**: O(V + E) - 線形時間
- **実装**: トポロジカルソートの実装を再利用

### 思考プロセス

1. **グラフの構築**: 前提条件からグラフを構築
2. **トポロジカルソート**: BFSでトポロジカルソートを実行
3. **サイクルの検出**: 全てのノードが処理されたか確認

### アルゴリズムのステップ

```
function canFinish(numCourses, prerequisites):
    graph = defaultdict(list)
    indegree = [0] * numCourses
    
    for course, prereq in prerequisites:
        graph[prereq].append(course)
        indegree[course] += 1
    
    queue = deque()
    for i in range(numCourses):
        if indegree[i] == 0:
            queue.append(i)
    
    count = 0
    
    while queue:
        node = queue.popleft()
        count += 1
        
        for neighbor in graph[node]:
            indegree[neighbor] -= 1
            if indegree[neighbor] == 0:
                queue.append(neighbor)
    
    return count == numCourses
```

## 現実世界での応用

### 1. 教育システム
- **シナリオ**: 大学のコース登録システムで、前提条件をチェック
- **実装**: トポロジカルソートでサイクルを検出
- **メリット**: 効率的なコース登録管理

### 2. スキル習得システム
- **シナリオ**: オンライン学習プラットフォームで、スキルの習得順序をチェック
- **実装**: トポロジカルソートでサイクルを検出
- **メリット**: 効率的な学習管理

### 3. タスク管理
- **シナリオ**: プロジェクト管理ツールで、タスクの依存関係をチェック
- **実装**: トポロジカルソートでサイクルを検出
- **メリット**: 効率的なタスク管理

### 4. ビルドシステム
- **シナリオ**: Make、CMakeなどのビルドシステムで、ターゲットの依存関係をチェック
- **実装**: トポロジカルソートでサイクルを検出
- **メリット**: 効率的なビルド管理

### 5. パッケージマネージャー
- **シナリオ**: npm、pipなどのパッケージマネージャーで、依存関係のサイクルを検出
- **実装**: トポロジカルソートでサイクルを検出
- **メリット**: 効率的なパッケージ管理

### 6. ワークフロー管理
- **シナリオ**: ワークフロー管理システムで、ステップの依存関係をチェック
- **実装**: トポロジカルソートでサイクルを検出
- **メリット**: 効率的なワークフロー管理

## 注意点と落とし穴

### 1. サイクルの検出
- **問題**: サイクルがある場合、全てのコースを完了できない
- **解決策**: 処理されたノード数が総ノード数と等しいか確認
- **実装**: `return count == numCourses`
- **注意**: サイクルがある場合、`count < numCourses`になる

### 2. 入次数の管理
- **問題**: 各ノードの入次数を正確に管理する必要がある
- **解決策**: グラフ構築時に入次数を計算
- **実装**: `indegree[course] += 1`で管理
- **注意**: 入次数の計算を忘れると、正しく動作しない

### 3. 空の前提条件
- **問題**: 前提条件がない場合（全てのコースが独立）
- **解決策**: 全てのノードの入次数が0になる
- **実装**: 通常の処理で正しく動作
- **注意**: エッジケースの処理が重要

### 4. 時間計算量の理解
- **平均**: O(V + E) - 各ノードと辺を1回ずつ処理
- **最悪**: O(V + E) - 常に線形時間
- **空間**: O(V) - グラフ、入次数、キュー
- **メリット**: 効率的なアルゴリズム

## 関連問題

- [Topological Sort](./topological_sort_logic.md) - トポロジカルソートの基本
- [Course Schedule II](../leetcode/medium/) - トポロジカルソートの順序を返す
- [Number of Islands](./number_of_islands_logic.md) - グラフ探索

---

**次のステップ**: [Stringテクニック](../11_string_manipulation/README.md)で文字列の問題を学ぶ

