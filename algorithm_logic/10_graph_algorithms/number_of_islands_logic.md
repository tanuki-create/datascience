# Number of Islands - ロジック解説

## 問題概要

2次元グリッドが与えられたとき、'1'（陸地）と'0'（水）で構成される。島の数を数える。島は上下左右に隣接する'1'で構成される。

**例**:
```
Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3
```

## ロジックの核心

### なぜDFS/BFSが有効か？

**全探索（非効率）**:
- 各セルを個別に処理すると、同じ島を複数回カウントする可能性

**DFS/BFSを使う理由**:
- **連結成分の探索**: 1つの島（連結成分）を1回の探索で全て見つける
- **訪問済みのマーク**: 訪問済みのセルをマークして重複を避ける
- **時間計算量**: O(m×n) - 各セルを1回ずつ処理

### 思考プロセス

1. **島の発見**: '1'を見つけたら、新しい島としてカウント
2. **島の探索**: DFS/BFSでその島の全ての'1'を探索
3. **訪問済みのマーク**: 探索したセルを'0'または訪問済みとしてマーク
4. **次の島を探す**: 次の'1'を見つけて繰り返し

### アルゴリズムのステップ（DFS）

```
1. island_count = 0 を初期化
2. 各セル (i, j) について:
   a. grid[i][j] == '1' なら:
      - island_count++
      - DFSで (i, j) から連結する全ての'1'を'0'に変更
3. island_count を返す

DFS関数:
1. 境界チェック: i, jが範囲外または'0'なら return
2. grid[i][j] = '0' に変更（訪問済み）
3. 上下左右の4方向にDFSを再帰呼び出し
```

## 具体例でのトレース

### 例: 3つの島があるグリッド

```
初期状態:
1 1 0 0 0
1 1 0 0 0
0 0 1 0 0
0 0 0 1 1

(0,0)で'1'発見 → 島1としてカウント → DFSで探索
0 0 0 0 0  (全て'0'に変更)
0 0 0 0 0
0 0 1 0 0
0 0 0 1 1

(2,2)で'1'発見 → 島2としてカウント → DFSで探索
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 1 1

(3,3)で'1'発見 → 島3としてカウント → DFSで探索
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0

結果: 3
```

## 現実世界での応用

### 1. 画像処理
- **シナリオ**: 画像内の連結領域を検出
- **実装**: 同様のDFS/BFSで連結成分を検出

### 2. ネットワーク分析
- **シナリオ**: ネットワーク内の連結コンポーネントを数える
- **実装**: グラフの連結成分をDFS/BFSで探索

### 3. ゲーム開発
- **シナリオ**: ゲームマップ上の領域を検出
- **実装**: 同様の探索アルゴリズムで領域を特定

## 注意点と落とし穴

1. **訪問済みのマーク**: 同じ島を複数回カウントしないよう注意
2. **境界チェック**: 配列の範囲外アクセスに注意
3. **方向の定義**: 上下左右の4方向を正確に定義

## 関連問題

- Max Area of Island
- Surrounded Regions
- Pacific Atlantic Water Flow

---

**次のステップ**: [グラフアルゴリズムのREADME](./README.md)に戻る

