# Number of Islands - ロジック解説

## 問題概要

2次元グリッドが与えられたとき、'1'（陸地）と'0'（水）で構成される。島の数を数える。島は上下左右に隣接する'1'で構成される。

**例**:
```
Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3
```

## ロジックの核心

### なぜDFS/BFSが有効か？

**全探索（非効率）**:
- 各セルを個別に処理すると、同じ島を複数回カウントする可能性

**DFS/BFSを使う理由**:
- **連結成分の探索**: 1つの島（連結成分）を1回の探索で全て見つける
- **訪問済みのマーク**: 訪問済みのセルをマークして重複を避ける
- **時間計算量**: O(m×n) - 各セルを1回ずつ処理

### 思考プロセス

1. **島の発見**: '1'を見つけたら、新しい島としてカウント
2. **島の探索**: DFS/BFSでその島の全ての'1'を探索
3. **訪問済みのマーク**: 探索したセルを'0'または訪問済みとしてマーク
4. **次の島を探す**: 次の'1'を見つけて繰り返し

### アルゴリズムのステップ（DFS）

```
1. island_count = 0 を初期化
2. 各セル (i, j) について:
   a. grid[i][j] == '1' なら:
      - island_count++
      - DFSで (i, j) から連結する全ての'1'を'0'に変更
3. island_count を返す

DFS関数:
1. 境界チェック: i, jが範囲外または'0'なら return
2. grid[i][j] = '0' に変更（訪問済み）
3. 上下左右の4方向にDFSを再帰呼び出し
```

## 具体例でのトレース

### 例: 3つの島があるグリッド

```
初期状態:
1 1 0 0 0
1 1 0 0 0
0 0 1 0 0
0 0 0 1 1

(0,0)で'1'発見 → 島1としてカウント → DFSで探索
0 0 0 0 0  (全て'0'に変更)
0 0 0 0 0
0 0 1 0 0
0 0 0 1 1

(2,2)で'1'発見 → 島2としてカウント → DFSで探索
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 1 1

(3,3)で'1'発見 → 島3としてカウント → DFSで探索
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0

結果: 3
```

## 現実世界での応用

### 1. 画像処理（連結成分の検出）
- **シナリオ**: 画像内の連結領域を検出
- **実装**: 同様のDFS/BFSで連結成分を検出
- **例**: 画像内の物体を検出し、各物体（連結成分）を数える
- **メリット**: コンピュータビジョンや画像認識で使用

### 2. ネットワーク分析（連結コンポーネント）
- **シナリオ**: ネットワーク内の連結コンポーネントを数える
- **実装**: グラフの連結成分をDFS/BFSで探索
- **例**: ソーシャルネットワークで、独立したコミュニティの数を数える
- **メリット**: ネットワーク構造の理解に使用

### 3. ゲーム開発（マップ解析）
- **シナリオ**: ゲームマップ上の領域を検出
- **実装**: 同様の探索アルゴリズムで領域を特定
- **例**: 戦略ゲームで、マップ上の独立した領地の数を数える
- **メリット**: ゲームの状態管理に使用

### 4. 地理情報システム（GIS）
- **シナリオ**: 地図上の連結領域を検出
- **実装**: 地理データをグリッドとして表現してDFS/BFSで探索
- **例**: 地図上で、湖や島の数を数える
- **メリット**: 地理データの分析に使用

### 5. セルオートマトン
- **シナリオ**: セルオートマトンの連結状態を検出
- **実装**: セルの状態をグリッドとして表現してDFS/BFSで探索
- **例**: ライフゲームで、生きているセルの連結領域を検出
- **メリット**: シミュレーションの分析に使用

### 6. パターン認識
- **シナリオ**: パターン内の連結領域を検出
- **実装**: パターンをグリッドとして表現してDFS/BFSで探索
- **例**: 文字認識で、文字の連結成分を検出
- **メリット**: OCR（光学文字認識）で使用

## 注意点と落とし穴

### 1. 訪問済みのマークの重要性
- **問題**: 同じ島を複数回カウントしないよう注意が必要
- **解決策**: 
  - グリッドを直接変更: `grid[i][j] = '0'`に変更（訪問済み）
  - 別の訪問済みセットを使用: `visited = set()`
- **推奨**: グリッドを直接変更する方が空間効率が良い
- **注意**: グリッドを変更すると元のデータが失われるため、必要に応じてコピーを作成

### 2. 境界チェックの徹底
- **問題**: 配列の範囲外アクセスに注意が必要
- **解決策**: DFS/BFSの各ステップで境界チェックを行う
- **実装**: 
  ```
  if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):
      return
  ```
- **注意**: 境界チェックを忘れると、インデックスエラーが発生する

### 3. 方向の定義の一貫性
- **問題**: 上下左右の4方向を正確に定義する必要がある
- **解決策**: 方向ベクトルを定義して一貫性を保つ
- **実装**: 
  ```
  directions = [(-1,0), (1,0), (0,-1), (0,1)]  # 上下左右
  for di, dj in directions:
      ni, nj = i + di, j + dj
  ```
- **注意**: 8方向（斜めを含む）が必要な場合は、方向ベクトルを拡張

### 4. DFSとBFSの選択
- **DFS**: 再帰的実装が簡潔、スタックオーバーフローのリスク
- **BFS**: 反復的実装が必要、メモリ使用量が多い
- **推奨**: 通常はDFSが簡潔で推奨、深い探索が必要な場合はBFS
- **注意**: グリッドが大きい場合、スタックオーバーフローのリスクを考慮

### 5. 時間計算量の理解
- **平均**: O(m×n) - 各セルを1回ずつ処理
- **最悪**: O(m×n) - 常に線形時間
- **空間**: 
  - DFS（再帰）: O(m×n) - 最悪の場合、全てのセルが再帰スタックに
  - BFS: O(min(m,n)) - 通常はDFSより少ない
- **注意**: グリッドのサイズが大きい場合、空間計算量も考慮

### 6. 問題の拡張
- **最大の島の面積**: 各島の面積を計算して最大を返す
- **島の周囲の長さ**: 各島の周囲の長さを計算
- **島の形状の分析**: 各島の形状を分析（凸包など）
- **実装**: DFS/BFSの基本構造は同じで、処理内容を変更

## 関連問題

- Max Area of Island
- Surrounded Regions
- Pacific Atlantic Water Flow

---

**次のステップ**: [グラフアルゴリズムのREADME](./README.md)に戻る

