# Merge Sorted Array - ロジック解説

## 問題概要

2つのソート済み配列`nums1`と`nums2`を、`nums1`にマージする。`nums1`には十分なスペースがある。

**制約**:
- `nums1.length == m + n`
- `nums2.length == n`

**例**:
```
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
```

## ロジックの核心

### なぜ後ろからマージするか？

**前からマージ（問題あり）**:
- `nums1`の先頭に要素を挿入すると、既存の要素をシフトする必要がある
- 時間計算量: O(n²) - 非効率

**後ろからマージを使う理由**:
- **空きスペースの活用**: `nums1`の後ろに空きスペースがある
- **要素の移動不要**: 後ろから埋めることで、既存要素を移動する必要がない
- **時間計算量**: O(m+n) - 線形時間で効率的

### 思考プロセス

1. **後ろから処理**: 両方の配列の末尾から比較
2. **大きい方を配置**: 大きい方を`nums1`の後ろから配置
3. **ポインタの移動**: 配置した配列のポインタを移動
4. **残りの処理**: `nums2`に残りがあればコピー

### アルゴリズムのステップ

```
1. i = m-1, j = n-1, k = m+n-1 を設定
2. i >= 0 かつ j >= 0 の間:
   a. nums1[i] > nums2[j] なら:
      nums1[k] = nums1[i], i--, k--
   b. そうでなければ:
      nums1[k] = nums2[j], j--, k--
3. j >= 0 の間:
   nums1[k] = nums2[j], j--, k--
```

## 具体例でのトレース

### 例: `nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3`

| ステップ | i | j | k | nums1[i] | nums2[j] | nums1 | アクション |
|---------|---|----|---|----------|----------|-------|-----------|
| 初期 | 2 | 2 | 5 | 3 | 6 | [1,2,3,0,0,0] | - |
| 1 | 2 | 1 | 4 | 3 | 5 | [1,2,3,0,0,6] | 6を配置 |
| 2 | 2 | 0 | 3 | 3 | 2 | [1,2,3,0,5,6] | 5を配置 |
| 3 | 1 | 0 | 2 | 2 | 2 | [1,2,3,3,5,6] | 3を配置 |
| 4 | 0 | 0 | 1 | 1 | 2 | [1,2,2,3,5,6] | 2を配置 |
| 5 | -1 | 0 | 0 | - | 2 | [1,2,2,3,5,6] | 2を配置 |

**結果**: `[1,2,2,3,5,6]`

## 現実世界での応用

### 1. データベースのマージ
- **シナリオ**: 2つのソート済みテーブルをマージ
- **実装**: 同様の後ろからマージで効率的に処理

### 2. バージョン管理
- **シナリオ**: 2つのソート済み変更履歴をマージ
- **実装**: マージ操作で統合

## 注意点と落とし穴

1. **後ろから処理**: 前から処理すると要素の移動が必要
2. **残りの処理**: `nums2`に残りがあれば必ずコピー
3. **インデックスの管理**: ポインタの管理が重要

## 関連問題

- Merge Two Sorted Lists
- Merge k Sorted Lists
- Merge Intervals

---

**次のステップ**: [ソートのREADME](./README.md)に戻る

