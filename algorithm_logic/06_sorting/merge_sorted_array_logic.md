# Merge Sorted Array - ロジック解説

## 問題概要

2つのソート済み配列`nums1`と`nums2`を、`nums1`にマージする。`nums1`には十分なスペースがある。

**制約**:
- `nums1.length == m + n`
- `nums2.length == n`

**例**:
```
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
```

## ロジックの核心

### なぜ後ろからマージするか？

**前からマージ（問題あり）**:
- `nums1`の先頭に要素を挿入すると、既存の要素をシフトする必要がある
- 時間計算量: O(n²) - 非効率

**後ろからマージを使う理由**:
- **空きスペースの活用**: `nums1`の後ろに空きスペースがある
- **要素の移動不要**: 後ろから埋めることで、既存要素を移動する必要がない
- **時間計算量**: O(m+n) - 線形時間で効率的

### 思考プロセス

1. **後ろから処理**: 両方の配列の末尾から比較
2. **大きい方を配置**: 大きい方を`nums1`の後ろから配置
3. **ポインタの移動**: 配置した配列のポインタを移動
4. **残りの処理**: `nums2`に残りがあればコピー

### アルゴリズムのステップ

```
1. i = m-1, j = n-1, k = m+n-1 を設定
2. i >= 0 かつ j >= 0 の間:
   a. nums1[i] > nums2[j] なら:
      nums1[k] = nums1[i], i--, k--
   b. そうでなければ:
      nums1[k] = nums2[j], j--, k--
3. j >= 0 の間:
   nums1[k] = nums2[j], j--, k--
```

## 具体例でのトレース

### 例: `nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3`

| ステップ | i | j | k | nums1[i] | nums2[j] | nums1 | アクション |
|---------|---|----|---|----------|----------|-------|-----------|
| 初期 | 2 | 2 | 5 | 3 | 6 | [1,2,3,0,0,0] | - |
| 1 | 2 | 1 | 4 | 3 | 5 | [1,2,3,0,0,6] | 6を配置 |
| 2 | 2 | 0 | 3 | 3 | 2 | [1,2,3,0,5,6] | 5を配置 |
| 3 | 1 | 0 | 2 | 2 | 2 | [1,2,3,3,5,6] | 3を配置 |
| 4 | 0 | 0 | 1 | 1 | 2 | [1,2,2,3,5,6] | 2を配置 |
| 5 | -1 | 0 | 0 | - | 2 | [1,2,2,3,5,6] | 2を配置 |

**結果**: `[1,2,2,3,5,6]`

## 現実世界での応用

### 1. データベースのマージ操作
- **シナリオ**: 2つのソート済みテーブルをマージ
- **実装**: 同様の後ろからマージで効率的に処理
- **例**: 2つの顧客テーブルをID順にマージして統合
- **メリット**: データベースの統合やバックアップの復元に使用

### 2. バージョン管理システム（Git）
- **シナリオ**: 2つのソート済み変更履歴をマージ
- **実装**: マージ操作で統合
- **例**: Gitで2つのブランチの変更履歴を時系列順にマージ
- **メリット**: コードの統合を効率的に処理

### 3. ログファイルの統合
- **シナリオ**: 2つのソート済みログファイルをマージ
- **実装**: タイムスタンプ順にマージ
- **例**: 複数のサーバーのログファイルを時系列順に統合
- **メリット**: ログ分析の効率化

### 4. メールシステムの統合
- **シナリオ**: 2つのメールボックスのメールを時系列順にマージ
- **実装**: タイムスタンプ順にマージ
- **例**: 複数のメールアカウントのメールを統合して表示
- **メリット**: メールの一元管理

### 5. 金融取引データの統合
- **シナリオ**: 2つの取引履歴を時系列順にマージ
- **実装**: タイムスタンプ順にマージ
- **例**: 複数の取引所の取引データを統合
- **メリット**: 取引データの一元管理と分析

## 注意点と落とし穴

### 1. 後ろから処理する理由の理解
- **問題**: 前から処理すると要素の移動が必要になる
- **理由**: `nums1`の先頭に要素を挿入すると、既存の要素を右にシフトする必要がある
- **解決策**: 後ろから処理することで、空きスペースを活用し、要素の移動を避ける
- **例**: 
  - 前から: `[1,2,3,0,0,0]`に2を挿入 → `[1,2,2,3,0,0]`（3を移動）
  - 後ろから: `[1,2,3,0,0,0]`の後ろから埋める → 移動不要

### 2. 残りの要素の処理の重要性
- **問題**: `nums2`に残りがあれば必ずコピーする必要がある
- **理由**: `nums1`の要素が全て処理されても、`nums2`に残りがある場合がある
- **解決策**: `while j >= 0:`で`nums2`の残りを全てコピー
- **注意**: `nums1`の残りは既に正しい位置にあるため、コピー不要

### 3. インデックスの正確な管理
- **問題**: 3つのポインタ（`i`, `j`, `k`）を正確に管理する必要がある
- **解決策**: 
  - `i`: `nums1`の有効な要素の最後のインデックス（`m-1`から開始）
  - `j`: `nums2`の最後のインデックス（`n-1`から開始）
  - `k`: `nums1`の最後の位置（`m+n-1`から開始）
- **注意**: ポインタをデクリメントするタイミングを正確に

### 4. 境界条件の処理
- **問題**: `nums1`または`nums2`が空の場合の処理
- **解決策**: 
  - `nums1`が空: `nums2`の全てをコピー
  - `nums2`が空: `nums1`は既に正しい状態
- **実装**: `while j >= 0:`のループで`nums2`の残りを処理

### 5. インプレース操作の理解
- **問題**: `nums1`を直接変更する必要がある
- **解決策**: 後ろから処理することで、既存の要素を上書きせずに済む
- **注意**: 前から処理すると、既存の要素を上書きしてしまう

### 6. 時間計算量の理解
- **平均**: O(m+n) - 各要素を1回ずつ処理
- **最悪**: O(m+n) - 常に線形時間
- **空間**: O(1) - 追加の空間は定数（ポインタのみ）
- **メリット**: インプレース操作で空間効率が良い

## 関連問題

- Merge Two Sorted Lists
- Merge k Sorted Lists
- Merge Intervals

---

**次のステップ**: [ソートのREADME](./README.md)に戻る

