# Subarray Sum Equals K - ロジック解説

## 問題概要

整数配列`nums`と整数`k`が与えられたとき、合計が`k`に等しい連続する部分配列の数を返す。

**制約**:
- `1 <= nums.length <= 2 * 10^4`
- `-1000 <= nums[i] <= 1000`

**例**:
```
Input: nums = [1,1,1], k = 2
Output: 2
説明: [1,1]と[1,1]（異なる位置）
```

## ロジックの核心

### なぜ累積和 + ハッシュマップが有効か？

**全探索（O(n²)）**:
- 全ての部分配列の合計を計算
- 時間計算量: O(n²) - 非効率

**累積和 + ハッシュマップを使う理由**:
- **累積和の活用**: `prefix[j] - prefix[i] = k`となる(i, j)の組を探す
- **ハッシュマップ**: `prefix[j] - k`が既に出現した回数を記録
- **時間計算量**: O(n) - 1回の走査で完了

### 思考プロセス

1. **累積和の計算**: 各位置までの累積和を計算
2. **補数の探索**: `prefix[j] - k`が既に出現した回数をカウント
3. **ハッシュマップ**: 累積和の出現回数を記録

### アルゴリズムのステップ

```
function subarraySum(nums, k):
    count = 0
    prefix_sum = 0
    prefix_map = {0: 1}  // 累積和0が1回出現
    
    for num in nums:
        prefix_sum += num
        
        // prefix_sum - kが既に出現した回数を加算
        if prefix_sum - k in prefix_map:
            count += prefix_map[prefix_sum - k]
        
        // 現在の累積和を記録
        prefix_map[prefix_sum] = prefix_map.get(prefix_sum, 0) + 1
    
    return count
```

## 具体例でのトレース

### 例: `nums = [1,1,1], k = 2`

```
初期状態:
  prefix_sum = 0
  prefix_map = {0: 1}
  count = 0

num = 1:
  prefix_sum = 1
  prefix_sum - k = 1 - 2 = -1 → 存在しない
  prefix_map = {0: 1, 1: 1}

num = 1:
  prefix_sum = 2
  prefix_sum - k = 2 - 2 = 0 → prefix_map[0] = 1
  count += 1 → count = 1
  prefix_map = {0: 1, 1: 1, 2: 1}

num = 1:
  prefix_sum = 3
  prefix_sum - k = 3 - 2 = 1 → prefix_map[1] = 1
  count += 1 → count = 2
  prefix_map = {0: 1, 1: 1, 2: 1, 3: 1}

結果: 2
```

## 現実世界での応用

### 1. 金融取引システム
- **シナリオ**: 取引の累積利益が目標値に達する回数をカウント
- **実装**: 累積利益を追跡し、目標値との差をハッシュマップで管理
- **メリット**: 効率的な取引分析

### 2. データストリームの分析
- **シナリオ**: ストリーミングデータで、特定の合計値に達するパターンを検出
- **実装**: 累積和を追跡し、目標値との差をハッシュマップで管理
- **メリット**: リアルタイムパターン検出

### 3. ネットワークトラフィック分析
- **シナリオ**: ネットワークトラフィックで、特定の総量に達する期間を検出
- **実装**: 累積トラフィックを追跡し、目標値との差をハッシュマップで管理
- **メリット**: 効率的なトラフィック分析

### 4. 在庫管理
- **シナリオ**: 在庫の累積変動で、特定の値に達する回数をカウント
- **実装**: 累積在庫を追跡し、目標値との差をハッシュマップで管理
- **メリット**: 効率的な在庫分析

### 5. ゲーム開発
- **シナリオ**: ゲームで、スコアの累積が特定の値に達する回数をカウント
- **実装**: 累積スコアを追跡し、目標値との差をハッシュマップで管理
- **メリット**: ゲームの統計分析

### 6. ログ分析
- **シナリオ**: ログで、エラーの累積数が特定の値に達する回数をカウント
- **実装**: 累積エラー数を追跡し、目標値との差をハッシュマップで管理
- **メリット**: 効率的なログ分析

## 注意点と落とし穴

### 1. 初期値の設定
- **問題**: `prefix_map = {0: 1}`を初期値として設定する必要がある
- **解決策**: 累積和が0の場合（空の部分配列）を考慮
- **実装**: `prefix_map = {0: 1}`で初期化
- **注意**: 初期値を忘れると、最初の要素が正しくカウントされない

### 2. 累積和の更新タイミング
- **問題**: 累積和を更新する前に、補数をチェックする必要がある
- **解決策**: 補数をチェックしてから、累積和を記録
- **実装**: `if prefix_sum - k in prefix_map:`の後に`prefix_map[prefix_sum] += 1`
- **注意**: 順序を間違えると、誤った結果が返される

### 3. ハッシュマップの更新
- **問題**: 累積和の出現回数を正確に記録する必要がある
- **解決策**: `prefix_map.get(prefix_sum, 0) + 1`で更新
- **実装**: 既存の値に1を加える
- **注意**: 出現回数を正確にカウントすることが重要

### 4. 時間計算量の理解
- **平均**: O(n) - 1回の走査で完了
- **最悪**: O(n) - 常に線形時間
- **空間**: O(n) - ハッシュマップのサイズ
- **メリット**: O(n²)からO(n)に改善

### 5. 負の数の扱い
- **問題**: 負の数が含まれる場合の処理
- **解決策**: 累積和は負の値にもなる可能性がある
- **実装**: ハッシュマップは負のキーも扱える
- **注意**: 負の累積和も正しく処理される

### 6. 重複する部分配列
- **問題**: 同じ合計値を持つ部分配列が複数回出現する可能性がある
- **解決策**: ハッシュマップで出現回数をカウント
- **実装**: `count += prefix_map[prefix_sum - k]`で全ての組み合わせをカウント
- **注意**: 出現回数を正確にカウントすることが重要

### 7. k=0の場合
- **問題**: k=0の場合、累積和が同じ値の部分配列を探す
- **解決策**: `prefix_sum - 0 = prefix_sum`が既に出現した回数をカウント
- **実装**: 同じ累積和が複数回出現する場合をカウント
- **注意**: k=0の場合は特別な処理が必要

### 8. 空の部分配列
- **問題**: 空の部分配列を考慮する必要があるか？
- **解決策**: 通常は空の部分配列は考慮しない
- **実装**: `prefix_map = {0: 1}`で初期化することで、空の部分配列を考慮
- **注意**: 問題の要件を確認する必要がある

## 関連問題

- [Range Sum Query](./range_sum_query_logic.md) - 累積和の基本
- [Maximum Size Subarray Sum Equals k](../leetcode/medium/) - 最大サイズの部分配列
- [Contiguous Array](../leetcode/medium/) - 0と1の数が等しい部分配列
- [Binary Subarray With Sum](../leetcode/medium/) - バイナリ配列版

---

**次のステップ**: [Product of Array Except Self](./product_array_except_self_logic.md)で累積積を学ぶ

