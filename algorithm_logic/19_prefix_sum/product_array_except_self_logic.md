# Product of Array Except Self - ロジック解説

## 問題概要

整数配列`nums`が与えられたとき、各要素について、その要素を除く全ての要素の積を返す。除算を使用せず、O(n)時間で解く。

**制約**:
- `2 <= nums.length <= 10^5`
- 除算を使用しない

**例**:
```
Input: nums = [1,2,3,4]
Output: [24,12,8,6]
説明: 
- 1を除く: 2×3×4 = 24
- 2を除く: 1×3×4 = 12
- 3を除く: 1×2×4 = 8
- 4を除く: 1×2×3 = 6
```

## ロジックの核心

### なぜ累積積が有効か？

**全探索（O(n²)）**:
- 各要素について、他の全ての要素の積を計算
- 時間計算量: O(n²) - 非効率

**累積積を使う理由**:
- **左側の積**: 各要素の左側の要素の積を事前に計算
- **右側の積**: 各要素の右側の要素の積を事前に計算
- **時間計算量**: O(n) - 2回の走査で完了

### 思考プロセス

1. **左側の積**: 左から右へ走査し、各位置までの左側の積を計算
2. **右側の積**: 右から左へ走査し、各位置までの右側の積を計算
3. **結果**: 左側の積 × 右側の積

### アルゴリズムのステップ

```
function productExceptSelf(nums):
    n = len(nums)
    result = [1] * n
    
    // 左側の積を計算
    for i in range(1, n):
        result[i] = result[i-1] * nums[i-1]
    
    // 右側の積を計算（右から左へ）
    right = 1
    for i in range(n-1, -1, -1):
        result[i] *= right
        right *= nums[i]
    
    return result
```

## 具体例でのトレース

### 例: `nums = [1,2,3,4]`

```
ステップ1: 左側の積を計算
  result[0] = 1
  result[1] = 1 * 1 = 1
  result[2] = 1 * 2 = 2
  result[3] = 2 * 3 = 6
  result = [1, 1, 2, 6]

ステップ2: 右側の積を計算
  i=3: right=1, result[3]=6*1=6, right=1*4=4
  i=2: right=4, result[2]=2*4=8, right=4*3=12
  i=1: right=12, result[1]=1*12=12, right=12*2=24
  i=0: right=24, result[0]=1*24=24, right=24*1=24
  result = [24, 12, 8, 6]

結果: [24, 12, 8, 6]
```

## 現実世界での応用

### 1. 統計計算
- **シナリオ**: データ分析で、特定の要素を除いた統計量を計算
- **実装**: 累積積を使用して効率的に計算
- **メリット**: 効率的な統計計算

### 2. 画像処理
- **シナリオ**: 画像処理で、特定のピクセルを除いた処理
- **実装**: 累積積を使用して効率的に処理
- **メリット**: 高速な画像処理

### 3. 信号処理
- **シナリオ**: 信号処理で、特定のサンプルを除いた処理
- **実装**: 累積積を使用して効率的に処理
- **メリット**: リアルタイム処理が可能

### 4. 金融計算
- **シナリオ**: 金融計算で、特定の要素を除いた計算
- **実装**: 累積積を使用して効率的に計算
- **メリット**: 効率的な金融計算

### 5. 機械学習
- **シナリオ**: 機械学習で、特定の特徴を除いた予測
- **実装**: 累積積を使用して効率的に計算
- **メリット**: 特徴選択の効率化

### 6. データベースのクエリ
- **シナリオ**: データベースで、特定のレコードを除いた集計
- **実装**: 累積積を使用して効率的に計算
- **メリット**: クエリの効率化

## 注意点と落とし穴

### 1. 除算の使用禁止
- **問題**: 除算を使用せずに解く必要がある
- **解決策**: 左側の積と右側の積を使用
- **実装**: 2回の走査で左側と右側の積を計算
- **注意**: 除算を使うと簡単だが、0の扱いが複雑

### 2. 0の扱い
- **問題**: 0が含まれる場合の処理
- **解決策**: 累積積の方法では0も正しく処理される
- **実装**: 0が含まれても、累積積は正しく計算される
- **注意**: 0が1つだけの場合、その位置以外は0になる

### 3. 右側の積の計算
- **問題**: 右側の積を効率的に計算する必要がある
- **解決策**: 右から左へ走査し、変数で右側の積を保持
- **実装**: `right`変数で右側の積を保持
- **メリット**: 追加の配列が不要

### 4. 時間計算量の理解
- **平均**: O(n) - 2回の走査で完了
- **最悪**: O(n) - 常に線形時間
- **空間**: O(1) - 結果配列を除けば定数空間
- **メリット**: O(n²)からO(n)に改善

### 5. 空間計算量の最適化
- **問題**: 結果配列以外の追加空間を最小化
- **解決策**: 右側の積を変数で保持し、結果配列を直接更新
- **実装**: `right`変数を使用して追加配列を避ける
- **メリット**: 空間効率が良い

### 6. オーバーフローの注意
- **問題**: 大きな値の積でオーバーフローが発生する可能性
- **解決策**: 言語によっては大きな整数型を使用
- **実装**: Pythonでは自動的に大きな整数を扱える
- **注意**: 他の言語では注意が必要

### 7. 負の数の扱い
- **問題**: 負の数が含まれる場合の処理
- **解決策**: 累積積は負の数にも対応可能
- **実装**: 通常の累積積の計算で問題ない
- **注意**: 符号は自動的に処理される

### 8. 結果配列の初期化
- **問題**: 結果配列を1で初期化する必要がある
- **解決策**: `result = [1] * n`で初期化
- **実装**: 1で初期化することで、積の計算が正しく動作
- **注意**: 0で初期化すると、全て0になってしまう

## 関連問題

- [Range Sum Query](./range_sum_query_logic.md) - 累積和の基本
- [Subarray Sum Equals K](./subarray_sum_equals_k_logic.md) - 累積和の応用
- [Trapping Rain Water](../04_stack_queue/trapping_rain_water_logic.md) - 類似のパターン
- [Container With Most Water](../02_two_pointers/container_with_most_water_logic.md) - 類似のパターン

---

**次のステップ**: [2D Prefix Sum](./2d_prefix_sum_logic.md)で2次元累積和を学ぶ

