# Range Sum Query - ロジック解説

## 問題概要

配列`nums`が与えられたとき、範囲[i, j]の要素の合計を返すクエリを複数回処理する。

**制約**:
- `1 <= nums.length <= 10^4`
- `-10^5 <= nums[i] <= 10^5`
- クエリ数は最大10^4

**例**:
```
Input: nums = [-2, 0, 3, -5, 2, -1]
Query: sumRange(0, 2) → 1
Query: sumRange(2, 5) → -1
```

## ロジックの核心

### なぜ累積和が有効か？

**素朴なアプローチ（O(n)）**:
- 各クエリで範囲の合計を計算
- 時間計算量: O(n × q) - qはクエリ数

**累積和を使う理由**:
- **事前計算**: 累積和を事前に計算しておく
- **O(1)クエリ**: 任意の範囲の合計をO(1)で取得
- **時間計算量**: O(n + q) - 大幅に改善

### 思考プロセス

1. **累積和の構築**: `prefix[i] = nums[0] + ... + nums[i-1]`
2. **範囲の計算**: `sumRange(i, j) = prefix[j+1] - prefix[i]`

### アルゴリズムのステップ

```
class NumArray:
    def __init__(self, nums):
        n = len(nums)
        self.prefix = [0] * (n + 1)
        for i in range(n):
            self.prefix[i + 1] = self.prefix[i] + nums[i]
    
    def sumRange(self, i, j):
        return self.prefix[j + 1] - self.prefix[i]
```

## 具体例でのトレース

### 例: `nums = [-2, 0, 3, -5, 2, -1]`

```
累積和の構築:
  prefix[0] = 0
  prefix[1] = 0 + (-2) = -2
  prefix[2] = -2 + 0 = -2
  prefix[3] = -2 + 3 = 1
  prefix[4] = 1 + (-5) = -4
  prefix[5] = -4 + 2 = -2
  prefix[6] = -2 + (-1) = -3

sumRange(0, 2):
  prefix[3] - prefix[0] = 1 - 0 = 1 ✓

sumRange(2, 5):
  prefix[6] - prefix[2] = -3 - (-2) = -1 ✓
```

## 現実世界での応用

### 1. データベースのクエリ最適化
- **シナリオ**: SQLのSUMクエリを高速化
- **実装**: 累積和を事前に計算して保存
- **メリット**: クエリの実行時間を短縮

### 2. 金融取引システム
- **シナリオ**: 株価の累積リターンを計算
- **実装**: 価格変動の累積和を計算
- **メリット**: リアルタイム計算が可能

### 3. ウェブアナリティクス
- **シナリオ**: ウェブサイトの訪問者の累積数を追跡
- **実装**: 日次の訪問者数の累積和を計算
- **メリット**: 効率的なデータ分析

### 4. ゲーム開発
- **シナリオ**: ゲーム内のスコアの累積を表示
- **実装**: スコアの累積和を計算
- **メリット**: リアルタイム表示が可能

### 5. ログ分析
- **シナリオ**: サーバーログの特定期間のエラー数を集計
- **実装**: エラー数の累積和を計算
- **メリット**: 効率的なログ分析

### 6. 在庫管理
- **シナリオ**: 在庫の累積変動を追跡
- **実装**: 在庫変動の累積和を計算
- **メリット**: 効率的な在庫管理

## 注意点と落とし穴

### 1. インデックスの扱い
- **問題**: 累積和のインデックスが1-basedか0-basedかを明確にする
- **解決策**: `prefix[i]`が`nums[0..i-1]`の合計を表すように定義
- **実装**: `prefix[0] = 0`として開始
- **注意**: インデックスのずれに注意

### 2. 範囲の計算式
- **問題**: 範囲[i, j]の合計を計算する際の式
- **解決策**: `prefix[j+1] - prefix[i]`で計算
- **実装**: 右端を含む場合は`j+1`を使用
- **注意**: 範囲の定義を明確にする

### 3. オーバーフローの注意
- **問題**: 大きな値の累積和でオーバーフローが発生する可能性
- **解決策**: 言語によっては大きな整数型を使用
- **実装**: Pythonでは自動的に大きな整数を扱える
- **注意**: 他の言語では注意が必要

### 4. 時間計算量の理解
- **構築**: O(n) - 1回だけ実行
- **クエリ**: O(1) - 各クエリが定数時間
- **合計**: O(n + q) - qはクエリ数
- **メリット**: クエリが多い場合、大幅に改善

### 5. 空間計算量
- **問題**: 累積和の配列を保存する必要がある
- **解決策**: O(n)の追加空間が必要
- **実装**: `prefix`配列を保存
- **トレードオフ**: 時間効率と空間効率のトレードオフ

### 6. 更新操作の対応
- **問題**: 配列の要素が更新される場合、累積和も更新する必要がある
- **解決策**: セグメント木やFenwick Treeを使用
- **実装**: 更新操作をサポートするデータ構造を使用
- **注意**: この問題では更新操作はない

### 7. 負の数の扱い
- **問題**: 負の数が含まれる場合の処理
- **解決策**: 累積和は負の数にも対応可能
- **実装**: 通常の累積和の計算で問題ない
- **注意**: オーバーフローのリスクは低い

### 8. 空の範囲の処理
- **問題**: i > jの場合の処理
- **解決策**: 通常は0を返すか、エラーを返す
- **実装**: 問題の要件に応じて処理
- **注意**: エッジケースの処理が重要

## 関連問題

- [Range Sum Query 2D](../leetcode/medium/) - 2次元累積和
- [Range Sum Query - Mutable](../leetcode/medium/) - 更新操作付き
- [Subarray Sum Equals K](./subarray_sum_equals_k_logic.md) - ハッシュマップとの組み合わせ
- [Maximum Size Subarray Sum Equals k](../leetcode/medium/) - 最大サイズの部分配列

---

**次のステップ**: [Subarray Sum Equals K](./subarray_sum_equals_k_logic.md)でハッシュマップと組み合わせた使用法を学ぶ

