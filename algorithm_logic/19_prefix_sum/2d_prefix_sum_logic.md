# 2D Prefix Sum - ロジック解説

## 問題概要

2次元配列`matrix`が与えられたとき、矩形領域の合計をO(1)で取得するクエリを複数回処理する。

**制約**:
- `1 <= m, n <= 200`
- クエリ数は最大10^4

**例**:
```
Input: matrix = [[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]
Query: sumRegion(2,1,4,3) → 8
説明: 矩形領域(2,1)から(4,3)までの合計
```

## ロジックの核心

### なぜ2次元累積和が有効か？

**素朴なアプローチ（O(m×n)）**:
- 各クエリで矩形領域の合計を計算
- 時間計算量: O(m×n×q) - qはクエリ数

**2次元累積和を使う理由**:
- **事前計算**: 2次元累積和を事前に計算しておく
- **O(1)クエリ**: 任意の矩形領域の合計をO(1)で取得
- **時間計算量**: O(m×n + q) - 大幅に改善

### 思考プロセス

1. **2次元累積和の構築**: `prefix[i][j] = sum of matrix[0..i-1][0..j-1]`
2. **矩形領域の計算**: 4つの累積和を使って矩形領域の合計を計算

### アルゴリズムのステップ

```
class NumMatrix:
    def __init__(self, matrix):
        m, n = len(matrix), len(matrix[0])
        self.prefix = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                self.prefix[i][j] = (matrix[i-1][j-1] + 
                                    self.prefix[i-1][j] + 
                                    self.prefix[i][j-1] - 
                                    self.prefix[i-1][j-1])
    
    def sumRegion(self, row1, col1, row2, col2):
        return (self.prefix[row2+1][col2+1] - 
                self.prefix[row1][col2+1] - 
                self.prefix[row2+1][col1] + 
                self.prefix[row1][col1])
```

## 具体例でのトレース

### 例: `matrix = [[1,2],[3,4]]`, `sumRegion(0,0,1,1)`

```
2次元累積和の構築:
  prefix[0][*] = [0, 0, 0]
  prefix[1][*] = [0, 1, 3]
  prefix[2][*] = [0, 4, 10]

sumRegion(0,0,1,1):
  prefix[2][2] - prefix[0][2] - prefix[2][0] + prefix[0][0]
  = 10 - 3 - 4 + 0 = 3
  実際の合計: 1+2+3+4 = 10（範囲の定義による）
```

## 現実世界での応用

### 1. 画像処理
- **シナリオ**: 画像の矩形領域の平均輝度を計算
- **実装**: 2次元累積和を使用して効率的に計算
- **メリット**: 高速な画像処理

### 2. データ分析
- **シナリオ**: 2次元データの矩形領域の統計量を計算
- **実装**: 2次元累積和を使用して効率的に計算
- **メリット**: 効率的なデータ分析

### 3. ゲーム開発
- **シナリオ**: ゲームマップの矩形領域のリソース量を計算
- **実装**: 2次元累積和を使用して効率的に計算
- **メリット**: リアルタイム計算が可能

### 4. 地理情報システム
- **シナリオ**: 地図の矩形領域の人口密度を計算
- **実装**: 2次元累積和を使用して効率的に計算
- **メリット**: 効率的な地理分析

### 5. 機械学習
- **シナリオ**: 特徴マップの矩形領域の特徴量を計算
- **実装**: 2次元累積和を使用して効率的に計算
- **メリット**: 高速な特徴抽出

### 6. データベースのクエリ
- **シナリオ**: 2次元データの矩形領域の集計
- **実装**: 2次元累積和を使用して効率的に計算
- **メリット**: クエリの効率化

## 注意点と落とし穴

### 1. インデックスの扱い
- **問題**: 2次元累積和のインデックスが1-basedか0-basedかを明確にする
- **解決策**: `prefix[i][j]`が`matrix[0..i-1][0..j-1]`の合計を表すように定義
- **実装**: `prefix[0][*] = 0`と`prefix[*][0] = 0`として開始
- **注意**: インデックスのずれに注意

### 2. 矩形領域の計算式
- **問題**: 矩形領域の合計を計算する際の式
- **解決策**: 4つの累積和を使って計算（包含-排除原理）
- **実装**: `prefix[r2+1][c2+1] - prefix[r1][c2+1] - prefix[r2+1][c1] + prefix[r1][c1]`
- **注意**: 重複部分を引く必要がある

### 3. 範囲の定義
- **問題**: 範囲が包含的か排他的かを明確にする
- **解決策**: 通常は`[row1, col1]`から`[row2, col2]`までを含む
- **実装**: `row2+1`と`col2+1`を使用
- **注意**: 問題の要件を確認する必要がある

### 4. 時間計算量の理解
- **構築**: O(m×n) - 1回だけ実行
- **クエリ**: O(1) - 各クエリが定数時間
- **合計**: O(m×n + q) - qはクエリ数
- **メリット**: クエリが多い場合、大幅に改善

### 5. 空間計算量
- **問題**: 2次元累積和の配列を保存する必要がある
- **解決策**: O(m×n)の追加空間が必要
- **実装**: `prefix`配列を保存
- **トレードオフ**: 時間効率と空間効率のトレードオフ

### 6. オーバーフローの注意
- **問題**: 大きな値の累積和でオーバーフローが発生する可能性
- **解決策**: 言語によっては大きな整数型を使用
- **実装**: Pythonでは自動的に大きな整数を扱える
- **注意**: 他の言語では注意が必要

### 7. 負の数の扱い
- **問題**: 負の数が含まれる場合の処理
- **解決策**: 2次元累積和は負の数にも対応可能
- **実装**: 通常の累積和の計算で問題ない
- **注意**: 符号は自動的に処理される

### 8. 空の矩形領域
- **問題**: row1 > row2やcol1 > col2の場合の処理
- **解決策**: 通常は0を返すか、エラーを返す
- **実装**: 問題の要件に応じて処理
- **注意**: エッジケースの処理が重要

## 関連問題

- [Range Sum Query](./range_sum_query_logic.md) - 1次元累積和
- [Max Sum of Rectangle No Larger Than K](../leetcode/hard/) - 2次元累積和の応用
- [Number of Submatrices That Sum to Target](../leetcode/medium/) - 2次元累積和の応用
- [Image Smoother](../leetcode/easy/) - 2次元累積和の応用

---

**次のステップ**: [Linked Listテクニック](../20_linked_list/README.md)でリンクリストを学ぶ

