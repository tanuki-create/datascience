# 累積和 (Prefix Sum)

## 概要

累積和（Prefix Sum）は、配列の各位置までの要素の合計を事前に計算しておくテクニックです。これにより、**任意の範囲の合計をO(1)で取得**できます。AtCoderで頻出のテクニックで、範囲クエリの問題で威力を発揮します。

## 基本概念

### 累積和の構築

1. **1次元累積和**: `prefix[i] = arr[0] + arr[1] + ... + arr[i-1]`
2. **2次元累積和**: 2次元配列の矩形領域の合計をO(1)で取得
3. **いもす法**: 範囲への加算を効率的に処理

### 主な操作と計算量

| 操作 | 時間計算量 | 空間計算量 | 適用場面 |
|------|-----------|-----------|---------|
| 累積和の構築 | O(n) | O(n) | 1次元配列 |
| 範囲の合計取得 | O(1) | O(1) | 任意の範囲 |
| 2次元累積和の構築 | O(n×m) | O(n×m) | 2次元配列 |
| 矩形領域の合計取得 | O(1) | O(1) | 任意の矩形 |

**注意**: 累積和は範囲クエリが頻繁に行われる場合に特に有効です。

## いつ使うべきか

累積和は以下のような場面で威力を発揮します：

### 1. 範囲クエリ問題
- 配列の任意の範囲の合計を高速に取得
- 部分配列の合計を複数回計算する場合

### 2. AtCoderの問題
- 範囲の合計、平均、最大値などを求める問題
- いもす法を使った範囲への加算

### 3. データ分析
- 時系列データの累積和を計算
- 売上の累積、訪問者の累積など

### 4. 画像処理
- 画像の矩形領域の輝度の合計
- 2次元累積和を使用

### 5. ゲーム開発
- ゲーム内のスコアの累積
- 経験値の累積など

## 現実世界での応用例

### 1. データベースのクエリ最適化
- **例**: SQLのSUMクエリを高速化
- **実装**: 累積和を事前に計算して保存
- **メリット**: クエリの実行時間を短縮

### 2. 金融取引システム
- **例**: 株価の累積リターンを計算
- **実装**: 価格変動の累積和を計算
- **メリット**: リアルタイム計算が可能

### 3. ウェブアナリティクス
- **例**: ウェブサイトの訪問者の累積数を追跡
- **実装**: 日次の訪問者数の累積和を計算
- **メリット**: 効率的なデータ分析

### 4. 画像処理
- **例**: 画像の矩形領域の平均輝度を計算
- **実装**: 2次元累積和を使用
- **メリット**: 高速な画像処理

### 5. ゲーム開発
- **例**: ゲーム内のスコアの累積を表示
- **実装**: スコアの累積和を計算
- **メリット**: リアルタイム表示が可能

### 6. ログ分析
- **例**: サーバーログの特定期間のエラー数を集計
- **実装**: エラー数の累積和を計算
- **メリット**: 効率的なログ分析

## 実装時の注意点

### 1. インデックスの扱い
- **問題**: 累積和のインデックスが1-basedか0-basedかを明確にする
- **解決策**: `prefix[i]`が`arr[0..i-1]`の合計を表すように定義
- **実装**: `prefix[0] = 0`として開始
- **注意**: インデックスのずれに注意

### 2. 範囲の計算
- **問題**: 範囲[i, j]の合計を計算する際の式
- **解決策**: `prefix[j+1] - prefix[i]`で計算
- **実装**: 右端を含む場合は`j+1`を使用
- **注意**: 範囲の定義を明確にする

### 3. オーバーフローの注意
- **問題**: 大きな値の累積和でオーバーフローが発生する可能性
- **解決策**: 言語によっては大きな整数型を使用
- **実装**: Pythonでは自動的に大きな整数を扱える
- **注意**: 他の言語では注意が必要

### 4. 2次元累積和
- **問題**: 2次元配列の矩形領域の合計を計算
- **解決策**: 2次元累積和を構築
- **実装**: `prefix[i][j] = arr[i][j] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1]`
- **注意**: 重複部分を引く必要がある

### 5. いもす法
- **問題**: 範囲への加算を効率的に処理
- **解決策**: 開始位置に+1、終了位置+1に-1を記録し、累積和を取る
- **実装**: `diff[start] += value; diff[end+1] -= value`
- **メリット**: 複数の範囲への加算をO(1)で処理

## 関連するLeetCode/AtCoder問題

### Medium
- [Range Sum Query](./range_sum_query_logic.md) - 累積和の基本
- [Subarray Sum Equals K](./subarray_sum_equals_k_logic.md) - ハッシュマップとの組み合わせ
- [Product of Array Except Self](./product_array_except_self_logic.md) - 累積積
- [2D Prefix Sum](./2d_prefix_sum_logic.md) - 2次元累積和

### Hard
- [Maximum Sum of 3 Non-Overlapping Subarrays](../leetcode/hard/) - 累積和の応用

## 学習の進め方

1. **Range Sum Query**から始める: 累積和の最も基本的な例
2. **Subarray Sum Equals K**でハッシュマップと組み合わせ: より複雑な問題
3. **2D Prefix Sum**で2次元累積和を学ぶ: 矩形領域のクエリ
4. **より複雑な問題**に挑戦: いもす法などの応用を学ぶ

## 次のステップ

- [Range Sum Query のロジック解説](./range_sum_query_logic.md)
- [Subarray Sum Equals K のロジック解説](./subarray_sum_equals_k_logic.md)
- [二分探索テクニック](../05_binary_search/README.md) - 累積和と組み合わせて使用

---

**重要**: 累積和は、範囲クエリが頻繁に行われる場合に強力なテクニックです。特にAtCoderでは頻出なので、しっかりと理解することが重要です。

