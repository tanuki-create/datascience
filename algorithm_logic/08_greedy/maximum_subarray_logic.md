# Maximum Subarray (Kadane's Algorithm) - ロジック解説

## 問題概要

整数配列から、連続する部分配列の最大和を求める。

**制約**:
- `1 <= nums.length <= 10^5`

**例**:
```
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
説明: [4,-1,2,1]の和が最大で6
```

## ロジックの核心

### Kadane's Algorithm

**貪欲的なアプローチ**: 
- 各要素について、それまでの和に現在の要素を加えるか、現在の要素から始めるかを選択
- `current_sum = max(current_sum + nums[i], nums[i])`
- `max_sum = max(max_sum, current_sum)`

### 思考プロセス

1. **局所最適選択**: 各時点で、それまでの和を続けるか、新しい和を始めるかを選択
2. **負の和のリセット**: 和が負になったら、新しい和を始める方が有利

### アルゴリズムのステップ

```
1. current_sum = nums[0], max_sum = nums[0] を初期化
2. i = 1 から n-1 まで:
   current_sum = max(current_sum + nums[i], nums[i])
   max_sum = max(max_sum, current_sum)
3. max_sum を返す
```

## 具体例でのトレース

### 例: `nums = [-2,1,-3,4,-1,2,1,-5,4]`

| i | nums[i] | current_sum | max_sum |
|---|---------|-------------|---------|
| 0 | -2 | -2 | -2 |
| 1 | 1 | 1 | 1 |
| 2 | -3 | -2 | 1 |
| 3 | 4 | 4 | 4 |
| 4 | -1 | 3 | 4 |
| 5 | 2 | 5 | 5 |
| 6 | 1 | 6 | 6 |
| 7 | -5 | 1 | 6 |
| 8 | 4 | 5 | 6 |

**結果**: `6`

## 現実世界での応用

### 1. 金融分析（利益最大化）
- **シナリオ**: 時系列データから最大の利益期間を特定
- **実装**: Kadane's Algorithmで最大和を計算
- **例**: 株価の変動から、連続する期間で最大の利益を生む期間を特定
- **メリット**: 投資戦略の最適化に使用

### 2. 画像処理（輝度解析）
- **シナリオ**: 画像の特定領域の最大輝度を計算
- **実装**: 2次元に拡張したKadane's Algorithmを使用
- **例**: 画像内の最も明るい矩形領域を検出
- **メリット**: 画像解析やコンピュータビジョンで使用

### 3. 音声処理（信号解析）
- **シナリオ**: 音声信号から最大振幅を持つ連続区間を検出
- **実装**: 音声信号の振幅データにKadane's Algorithmを適用
- **例**: 音楽や音声から、最も大きな音量の連続区間を特定
- **メリット**: 音声認識や音楽解析で使用

### 4. ネットワークトラフィック分析
- **シナリオ**: ネットワークトラフィックの時系列データから最大負荷期間を特定
- **実装**: トラフィックデータにKadane's Algorithmを適用
- **例**: サーバーの負荷データから、最も負荷が高い連続期間を検出
- **メリット**: キャパシティプランニングに使用

### 5. 売上分析（ビジネスインテリジェンス）
- **シナリオ**: 売上の時系列データから最大売上期間を特定
- **実装**: 売上データにKadane's Algorithmを適用
- **例**: 月次売上データから、最も売上が高い連続期間を検出
- **メリット**: マーケティング戦略の最適化に使用

## 注意点と落とし穴

### 1. 全て負の値の場合の処理
- **問題**: 配列の全ての要素が負の場合、最大和は最大の負の値になる
- **解決策**: アルゴリズムは自動的に最大の負の値を返す
- **例**: `nums = [-5,-3,-1]`の場合、最大和は`-1`
- **注意**: 問題によっては、空の部分配列（和=0）を許可する場合がある

### 2. 空の部分配列の扱い
- **問題**: 問題によっては空の部分配列を許可する場合がある
- **解決策**: 空の部分配列を許可する場合は、`max_sum`の初期値を0にする
- **実装**: `max_sum = 0`とし、`max(max_sum, current_sum)`で0より大きい値のみを考慮
- **注意**: 問題文をよく読んで、空の部分配列が許可されているか確認

### 3. 開始/終了位置の追跡
- **問題**: 最大和の部分配列の位置も知りたい場合がある
- **解決策**: `current_sum`が更新されるたびに開始位置を記録し、`max_sum`が更新されるたびに終了位置を記録
- **実装**: 
  ```
  if current_sum == nums[i]:
      start = i
  if max_sum < current_sum:
      max_sum = current_sum
      end = i
  ```
- **応用**: 最大和の部分配列の実際の値を返す場合に使用

### 4. オーバーフローの注意
- **問題**: 大きな値の和がオーバーフローする可能性
- **解決策**: 言語によっては大きな整数型を使用する必要がある
- **注意**: Pythonでは自動的に大きな整数を扱えるが、他の言語では注意が必要

### 5. Kadane's Algorithmの理解
- **核心**: 「現在の要素から新しい部分配列を始めるか、既存の部分配列に追加するか」を選択
- **判断基準**: 既存の和が負の場合、新しい部分配列を始める方が有利
- **理由**: 負の和に正の値を加えても、正の値から始める方が大きくなる

### 6. 2次元への拡張
- **問題**: 2次元配列（行列）での最大和部分行列を求める場合
- **解決策**: 各行の組み合わせに対して1次元のKadane's Algorithmを適用
- **時間計算量**: O(n²×m) - nは行数、mは列数
- **応用**: 画像処理やデータ分析で使用

## 関連問題

- Maximum Product Subarray
- Maximum Sum Circular Subarray

---

**次のステップ**: [木の探索テクニック](../09_tree_traversal/README.md)でDFS/BFSを学ぶ

