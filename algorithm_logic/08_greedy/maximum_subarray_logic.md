# Maximum Subarray (Kadane's Algorithm) - ロジック解説

## 問題概要

整数配列から、連続する部分配列の最大和を求める。

**制約**:
- `1 <= nums.length <= 10^5`

**例**:
```
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
説明: [4,-1,2,1]の和が最大で6
```

## ロジックの核心

### Kadane's Algorithm

**貪欲的なアプローチ**: 
- 各要素について、それまでの和に現在の要素を加えるか、現在の要素から始めるかを選択
- `current_sum = max(current_sum + nums[i], nums[i])`
- `max_sum = max(max_sum, current_sum)`

### 思考プロセス

1. **局所最適選択**: 各時点で、それまでの和を続けるか、新しい和を始めるかを選択
2. **負の和のリセット**: 和が負になったら、新しい和を始める方が有利

### アルゴリズムのステップ

```
1. current_sum = nums[0], max_sum = nums[0] を初期化
2. i = 1 から n-1 まで:
   current_sum = max(current_sum + nums[i], nums[i])
   max_sum = max(max_sum, current_sum)
3. max_sum を返す
```

## 具体例でのトレース

### 例: `nums = [-2,1,-3,4,-1,2,1,-5,4]`

| i | nums[i] | current_sum | max_sum |
|---|---------|-------------|---------|
| 0 | -2 | -2 | -2 |
| 1 | 1 | 1 | 1 |
| 2 | -3 | -2 | 1 |
| 3 | 4 | 4 | 4 |
| 4 | -1 | 3 | 4 |
| 5 | 2 | 5 | 5 |
| 6 | 1 | 6 | 6 |
| 7 | -5 | 1 | 6 |
| 8 | 4 | 5 | 6 |

**結果**: `6`

## 現実世界での応用

### 1. 金融分析
- **シナリオ**: 時系列データから最大の利益期間を特定
- **実装**: Kadane's Algorithmで最大和を計算

### 2. 画像処理
- **シナリオ**: 画像の特定領域の最大輝度を計算
- **実装**: 2次元に拡張したKadane's Algorithmを使用

## 注意点と落とし穴

1. **全て負の場合**: 最大の負の値が答えになる
2. **空の部分配列**: 問題によっては空の部分配列を許可する場合がある
3. **開始/終了位置**: 最大和の部分配列の位置も追跡したい場合は、インデックスを保存

## 関連問題

- Maximum Product Subarray
- Maximum Sum Circular Subarray

---

**次のステップ**: [木の探索テクニック](../09_tree_traversal/README.md)でDFS/BFSを学ぶ

