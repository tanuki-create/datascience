
================================================================================
ページ 1
================================================================================
フロントエンド
2025-08-18
id:mizdra
#hatenaintern
!



================================================================================
ページ 2
================================================================================
はじめに
• 「Webフロントエンド」と聞いて、何を思い浮かべますか?
• 「Webフロントエンド」の開発をする上で、必要な知識は何だ
と思いますか?
#hatenaintern
!



================================================================================
ページ 3
================================================================================
必要な知識の⼀例
• Webページ/ブラウザ/サーバの関係性‧役割
• HTML/CSS/JavaScript (⾔語)
• React, Next.js (View ライブラリ/フレームワーク)
• XSS, CSP (セキュリティ)
• Web Vitals (パフォーマンス)
• アクセシビリティ
• bundler, linter, formatter, test runner (開発ツール)
#hatenaintern
!



================================================================================
ページ 4
================================================================================
フロントエンドへのよくある印象 ①
• 「覚えることが多い」
• そうかもだが、フロントエンド以外の領域でも同じだと思う
• アクセシビリティ/⾔語ツールは、この領域特有かもしれない
が...
• ⾔語/ライブラリ/パフォーマンスの知識は、他の領域でも必要
• あんまり恐れる必要ない
#hatenaintern
!



================================================================================
ページ 5
================================================================================
フロントエンドへのよくある印象 ②
• 「技術の流れが早い」
• そうかも
• フロントエンドはユーザに近くて、コーディング⼈⼝が多い領域
• そのため、頻繁に新技術が出てくる !
• 向き合い⽅を変えるべき
• 流⾏を追うのも良いけど...その技術が登場した背景を考えよう
• ライブラリの使い⽅を覚えるのも良いけど...⻑く通⽤する知識も⾝につけよう
! 諸説あります。
#hatenaintern
!



================================================================================
ページ 6
================================================================================
この講義のゴール
• フロントエンド開発で必須の知識を押さえる
• それぞれの技術が登場した背景を知る
• ⻑く通⽤する知識を⾝につける
講義が終わった後も、Webフロントエンドを学べるような⼿助け
になれば良いと思っています。
#hatenaintern
!



================================================================================
ページ 7
================================================================================
JavaScript について(01min)
#hatenaintern
!



================================================================================
ページ 8
================================================================================
JavaScript について
• 皆さんが実際にコードを読む際に知っておいて欲しい 
JavaScript 上の概念について紹介します
#hatenaintern
!



================================================================================
ページ 9
================================================================================
変数宣⾔
// 変数と宣言
let a = "a" // let は上書き可能
const b = "b" // 上書き不可能
a = "A" // OK
b = "B" // Cannot assign to "b" because it is a constant
• 変数宣⾔は const をできるだけ使うと良い
• 変数の値が変わることを考慮しなくて済む
#hatenaintern
!



================================================================================
ページ 10
================================================================================
プリミティブ型 / オブジェクト
const id1 = "1234" // string
const id2 = '1234' // string
const name = null // null
const age = 2022 // number
const isAdmin = false // boolean
// object
const user = {
  id: "1234",
  username: null,
  age: 2022,
  isAdmin, // `isAdmin: isAdmin` の省略形
}
user.age // 2022
// 未定義プロパティだと undefined が返る
user.abc // undefined
#hatenaintern
!"



================================================================================
ページ 11
================================================================================
関数 / 配列
// 関数
function add(a, b) {
  return a + b
}
add(1, 2) // 3
// 配列
const array1 = [1, 2]
// 配列操作
array1[0] // 1
for (elm of array1) {
  console.log(elm)
}
array1.forEach((elm) => {
  console.log(elm)
})
array1.map((elm) => elm * 2) // [2, 4]
#hatenaintern
!!



================================================================================
ページ 12
================================================================================
Arrow Function
• 簡潔に関数を書くための構⽂
const add = (a, b) => {
    return a + b
}
// 1行だけなら return などを省略可
const add = (a, b) => a + b
// 引数が 1 つのときは引数を囲う `()` も省略可
const hello = name => `Hello, ${name}`
// 返り値がオブジェクトのときは `()` で囲う必要がある
const getProps = () => ({ a: "foo", b: "bar" })
#hatenaintern
!"



================================================================================
ページ 13
================================================================================
typeof 演算⼦
• 値の実⾏時の型を返す演算⼦
const str = "hello world"
console.log(typeof str) // 'string'
console.log(typeof 10) // 'number'
console.log(typeof { name: "jonh", age: 20 }) // 'object'
console.log(typeof undefined) // 'undefined'
console.log(typeof ["a"]) // 'object'
console.log(typeof null) // 'object'
#hatenaintern
!"



================================================================================
ページ 14
================================================================================
in 演算⼦
値に特定のプロパティが有ることを判定する演算⼦。ブラウザが特
定の API に対応しているかどうかを識別することにも使われる。
const user = { name: "hatena", age: 20 }
if ("name" in user) {
  console.log("user has name property")
}
if ("fetch" in window) {
  console.log("This browser supports fetch API")
}
#hatenaintern
!"



================================================================================
ページ 15
================================================================================
Promiseについて
• ⾮同期処理を抽象化したオブジェクト !
• 3つの状態を表現できる
• Pending: 初期状態。成功も失敗もして
いない。
• Fulfilled: ⾮同期処理が成功した
• Rejected: ⾮同期処理が失敗した
• まず Pending になって、その後 
Fulfilled or Rejected になる
! Promise は⾮同期処理を扱うためのオブジェクトで、JavaScript の⾮同期処理の基本的な仕組みです。詳細は付録
「Promise について」を参照してください。
#hatenaintern
!"



================================================================================
ページ 16
================================================================================
Promise の⽣成⽅法
• new Promise((resolve, reject) => {...}) で Promise を⽣成
• resolve を呼ぶと Fulfilled になり、reject を呼ぶと Rejected になる
function sleep(ms) {
  return new Promise((resolve, reject) => {
    if (typeof ms !== "number") {
      reject(new Error("ms must be a number"))
      return
    }
    setTimeout(() => {
      resolve(ms)
    }, ms)
  })
}
#hatenaintern
!"



================================================================================
ページ 17
================================================================================
コールバックの登録
• ⾮同期処理が完了した時に呼ばれるコールバック関数を登録できる
• then メソッド: Fulfilled になった時に呼ばれるコールバックを
登録
• catch メソッド: Rejected になった時に呼ばれるコールバックを
登録
sleep(1000)
  .then((ms) => console.log(`sleep: ${ms}ms`))
  .catch((e) => console.error(e))
#hatenaintern
!"



================================================================================
ページ 18
================================================================================
fetch を使った例
• fetch は HTTP リクエストを送信する API
• リクエスト送信は⾮同期処理なので、Promise を返すようになってる
const promise = fetch("https://api.example.com/user/1") // ①
  .then((res) => /* ② */ res.json())
  .then((json) => /* ③ */ console.log(json.user))
  .catch((e) => /* ④ */ console.error(e))
console.log(promise) // ⑤
• ① => ⑤ => ② => ③ => ④ の順に実⾏されることに注意
• コールバック関数は⾮同期処理が完了後に実⾏される (遅延される)
#hatenaintern
!"



================================================================================
ページ 19
================================================================================
async/await
• ⾮同期処理を簡潔に書くための構⽂
• then や catch を使わずに、同期的なコードっぽく書ける
#hatenaintern
!"



================================================================================
ページ 20
================================================================================
async/await
const getUser = async (id) => {
  try {
    const res = await fetch(`https://api.example.com/user/${id}`)
    const json = await res.json()
    const user = json.user
    console.log(`${user.name}のidは${user.id}`)
    return user
  } catch (e) {
    console.error(e)
    throw new Error("error reason: *********")
  }
}
エラーハンドリングには try {} catch (e) {} を使⽤します。
#hatenaintern
!"



================================================================================
ページ 21
================================================================================
async/await
• async function ⾃体も暗黙的に Promise を返す
• 関数の返り値に対して、then を呼び出せる
getUser(1)
  .then(console.log) // {id: 1, name: 'hatena'}
  .catch(console.error)
#hatenaintern
!"



================================================================================
ページ 22
================================================================================
ECMAScript Modules (ES Modules)
• プログラムをモジュールという単位に分割する機能
• 1 ファイル == 1 モジュール
• スコープはモジュールごと
• 関数や変数などを import/export できる
• 歴史的経緯で CommonJS!という形式が Node.js などを中⼼に⻑く採⽤されてきたが、
ECMAScript"で標準化された ES Modules が今では Node.js、ブラウザなどでも広くサポートさ
れている#
! 実際にはサポートしていないブラウザやパフォーマンスのために Babel を使って変換した後に、モジュールを解釈して 1 つ〜複数のファイルをまとめて配信するために webpack などを利
⽤することが多い。詳細は付録「JavaScript をウェブアプリケーションで提供する際に使⽤するツールチェインについて」を参照してください。
! ECMAScript は JavaScript の仕様における名称。ECMAScript 仕様については付録「JavaScript やフロントエンド周辺技術の標準(化)について」で解説しています。
! module.exports という特殊なオブジェクトを経由してエクスポートし、require 関数を利⽤してインポートする⽅式。https://nodejs.org/docs/latest/api/modules.html
#hatenaintern
!!



================================================================================
ページ 23
================================================================================
named export, named import
• 変数宣⾔や関数宣⾔に export を付加すると named export できる
// lib.js
export const logLevel = {
  WARN: "warn",
  ERROR: "error",
};
export function log(message, level) {/* ... */}
// main.js
import { logLevel, log } from './lib.js'
#hatenaintern
!"



================================================================================
ページ 24
================================================================================
default export
// lib.js
export default function (message, level) {/* ... */}
// main.js
import awesome from "./lib"
• export default というキーワードでも export できる
• 名前を付けずにエクスポートできる
• export default できるのは、1つのモジュールにつき 1 つだけ
• import 時に任意の名前を設定できる
#hatenaintern
!"



================================================================================
ページ 25
================================================================================
import/export の細かい挙動
• as でリネーム出来る
import { logType as LOGTYPE } from "./namedModule"
• * as で export されているもの全てをオブジェクトにまとめる!
import * as Logger from "./namedModule"
Logger.hello() // 'hello'
! 必要なものだけを取り込むことで受けられる恩恵(webpack による TreeShakingなど)も多いので、基本的には * as は避ける⽅のがオススメ。
#hatenaintern
!"



================================================================================
ページ 26
================================================================================
for...of
• 反復可能(iterable)なオブジェクトの要素を順番に取り出せる
• 配列、⽂字列、NodeList、Map、Setなど
const iterable = [10, 20, 30]
for (const value of iterable) {
  console.log(value)
}
#hatenaintern
!"



================================================================================
ページ 27
================================================================================
Nullish coalescing operator ??
• a ?? b のようにして使う
• 左辺が undefined or null の時に右辺の値を返す
• それ以外なら左辺の値を返す
• デフォルト値に fallback させるのに便利
function greet(name) {
  return `Hello, ${name ?? "mizdra"}!`
}
#hatenaintern
!"



================================================================================
ページ 28
================================================================================
Optional chaining ?.
• プロパティアクセス (a.b) の亜種で、a?.b のように書く
• a が null または undefined のときは undefined を返す
• それ以外のときは通常通りプロパティアクセスを⾏う
const userId1 = session.user?.id;
const userId2 = session.user ? session.user.id : undefined;
• 関数呼び出しとも組み合わせられる
const result = someObject?.someMethod?.(arg1, arg2);
#hatenaintern
!"



================================================================================
ページ 29
================================================================================
Spread Syntax
• ... を使うと配列やオブジェクトを展開出来る
const sum = (a, b, c, d) => a + b + c + d
const nums = [1, 2]
const copied = [...nums] // 中身を複製した配列を作れる
const moreNums = [...copied, 5] // [1, 2, 5]
sum(...nums, 10) // 13
const obj = { a: 10, b: "foo" }
const obj2 = { b: "bar", c: true }
// 2つ以上のobjectをmergeする。キーが重複している場合は後に書いた方で上書きされる
const merged = { ...obj, ...obj2 } // {a: 10, b: 'bar', c: true}
const getUserConfig = (received) => ({
  force: false,
  ...received, // デフォルト値を渡された値があれば上書きする
})
#hatenaintern
!"



================================================================================
ページ 30
================================================================================
Rest Parameters
• 関数の引数も ... で受け取ることで可変な⻑さの引数を受け取れる
• Spread Syntax と違って、1 つだけ且つ引数の末尾でしか使えな
い
//
const sum = (num1, num2, ...nums) =>
  num1 + num2 + nums.reduce((a, b) => a + b, 0)
const numbers = [1, 2, 3]
sum(3, ...numbers, 6) // 15
#hatenaintern
!"



================================================================================
ページ 31
================================================================================
TypeScript について(01min)
#hatenaintern
!"



================================================================================
ページ 32
================================================================================
TypeScript について
• JavaScript に静的型付けを導⼊した⾔語
• JavaScript + 型注釈
• コンパイラ (tsc) で型チェックを⾏う
• 現代では⽣の JavaScript 書くより、TypeScript で書くことが多い
function hello(name: string): string {
  return `Hello, ${name}!`
}
const result = hello(1)
//                   ^
// Type Error: Argument of type '1' is not assignable to parameter of type 'string'.
#hatenaintern
!"



================================================================================
ページ 33
================================================================================
なぜ TypeScript が必要か？
• 型エラーを未然に防ぐため
• 実⾏した時ではなく、コードを書いてる時に気付けるように
• コードを変更しやすくするため
• Rename/補完
• コードを読みやすくするため
• 型がドキュメント代わりに
• コードジャンプ
#hatenaintern
!!



================================================================================
ページ 34
================================================================================
tsc: TypeScript compiler
• TypeScript ⾔語のためのコンパイラ
• 主な機能
• 型チェックをする
• TypeScript で書かれたコードを JavaScript に変換する
• 変換と⾔っても、型アノテーション等の削除くらい
#hatenaintern
!"



================================================================================
ページ 35
================================================================================
型宣⾔部分を読めるようになろう
TypeScript の代表的な表現などを紹介していきます。
#hatenaintern
!"



================================================================================
ページ 36
================================================================================
変数宣⾔時の型アノテーション
// JavaScriptの場合
const a = 'hello';
// TypeScriptの場合は変数名と=の間に:を置いて型アノテーションを書く
const a: 【ここに型アノテーション】 = 'hello';
// 例えば
const a: string = 'hello';
これくらいだったら推論されるので、普通は省略されます。
#hatenaintern
!"



================================================================================
ページ 37
================================================================================
代表的な表現 ①
• プリミティブ型: string, number, boolean, null, undefined
• 'hello', 12, true, false のような特定の値(リテラル型と呼びます)も使える
const a: number = 10
const b: boolean = false
const c: string = 11 // Type Error
const d: "hello" = "hello"
const n: null = null
• 配列
const arr: string[] = ["hello", "world"]
const arr2: Array<number> = [1, 2, 3, 5, 8]
const arr3: [string, number] = ["year", 2021] // タプル(Tuple)型とも
#hatenaintern
!"



================================================================================
ページ 38
================================================================================
代表的な表現 ②
• オブジェクト
• JavaScript のオブジェクト同様に書いて、値を書くところに型を書く
• キー名に ? を付けるとオプショナルなキーになって、省略可能になる。!
const person: {
  name: string
  age: number
  address?: string
} = {
  name: "john",
  age: 21,
}
! string | undefined のような記述と同じと紹介されることもある。値が⼊っているかどうかで JavaScript として実⾏した際の振る舞いが変わることがある(Object.keys() など)ので、厳密
には同じではないことに注意。特に TypeScript \.\ で導⼊された exactOptionalPropertyTypes を有効にすると、tsc での型解析時の振る舞いも変わります。
#hatenaintern
!"



================================================================================
ページ 39
================================================================================
type
type を使うと型にエイリアスを付けられる
type Person = {
  name: string
  age: number
}
type Team = Person[]
#hatenaintern
!"



================================================================================
ページ 40
================================================================================
Union Type (合併型)
複数の型のいずれかを満たす
type Color = "red" | "green" | "blue" | "yellow" | "purple"
const c: Color = "red"
const d: Color = "black" // Type Error
#hatenaintern
!"



================================================================================
ページ 41
================================================================================
Narrowing
緩い型をいくつかの型に絞り込んでから、絞り込まれたそれぞれに対して処理したいこと
がある。
function padLeft(padding: number | string, input: string): string {
  if (padding が number なら) {
    return " ".repeat(padding) + input;
  } else if (padding が string なら) {
    return padding + input;
  }
  throw new Error("unreachable");
}
⼀部の JavaScript の演算⼦を使うと、型の絞り込み (Narrowing) ができる。
#hatenaintern
!"



================================================================================
ページ 42
================================================================================
typeof 演算⼦
• JavaScript にある演算⼦だが、TypeScript で使うと 
TypeScript の型の絞り込みもされる
function padLeft(padding: number | string, input: string): string {
  if (typeof padding === "number") {
    // このブロック内では `padding` は `number` 型
  } else if (typeof padding === "string") {
    // このブロック内では `padding` は `string` 型
  }
}
#hatenaintern
!"



================================================================================
ページ 43
================================================================================
in 演算⼦
• これも JavaScript にある演算⼦
• TypeScript では、特定のプロパティを持つ型へと絞り込める
type Fish = { name: string, swim: () => void }
type Bird = { name: string, fly: () => void }
const move = (x: Fish | Bird) => {
  if ("swim" in x) {
    // Fish 型に絞り込まれる
    return x.swim()
  }
  // ここでは Bird 型に絞り込まれる
  return x.fly()
}
#hatenaintern
!"



================================================================================
ページ 44
================================================================================
Tagged Union Types
• Union Type の個々の型に、kind のようなプロパティを持たせるテクニックがある
• x.kind === ... で型の絞り込みができる
• in による絞り込みより堅牢な書き⽅で、おすすめ
type Fish = {
  kind: "fish"
  // ...
}
type Bird = {
  kind: "bird"
  // ...
}
const move = (x: Fish | Bird) => {
  if (x.kind === "fish") {
    return x.swim()
  }
  return x.fly()
}
#hatenaintern
!!



================================================================================
ページ 45
================================================================================
as を⽤いた型アサーション(Type Assertion)
• TypeScript によって推論された型を上書きしたいときに使う
• 型キャストではない(ランタイム上での振る舞いがなんら変わ
ることはない) !
• 多くの場合は害になるので、本当に必要な場合だけ利⽤する
• 例えば、古い JavaScript のコードを移植するなど
! 例えば "str" as number のように書いた時に、実⾏時に⽂字列から数値に型変換されたりする訳ではない。TypeScript の型システム上での型が number に変わるだけ。
#hatenaintern
!"



================================================================================
ページ 46
================================================================================
as を⽤いた型アサーション(Type Assertion)
type Foo = {
  bar: number
  piyo: string
}
const foo1: Foo = { bar: 1, piyo: "2" } // OK
const foo2: Foo = {} // NG
const foo3: Foo =  {} as Foo // OK
#hatenaintern
!"



================================================================================
ページ 47
================================================================================
const アサーション
as const とすることで変数代⼊時などに変更不可能としてアサーションしてくれる。
const a = [1, 2, 3] // aの型はnumber[]となる
const b = [1, 2, 3] as const // bの型はreadonly [1, 2, 3]となる
// readonly な配列には push や pop などの変更を加えるメソッドが存在しない
a.push(4) // OK
b.push(4) // NG
type Pallet = {
  color: Color
}
const setPallet = (p: Pallet) => {
  /* do something */
}
const pallet = {
  color: "red",
} // ここに as const を付けないと{ color: string }と推論されてエラーになる
setPallet(pallet)
#hatenaintern
!"



================================================================================
ページ 48
================================================================================
不定な型を扱う⽅法
TypeScript 上で不定な型を扱うための⽅法を紹介します。
#hatenaintern
!"



================================================================================
ページ 49
================================================================================
any
• どんな値でも⼊れられる型
• any 型に対する操作はtscで型エラーにならない
let anything: any = {}
// anyには何でも代入できる
anything = () => {}
anything = null
anything.split(",") // anyの場合はメソッドもなんでも参照できる
• Rust の unsafe のようなもの
• ⾃由に書けるが、コンパイラは何も警告しない
• as 同様に避けられる場合は避ける
#hatenaintern
!"



================================================================================
ページ 50
================================================================================
unknown
• any 同様にどんな値でも⼊れられる
• any と違い、unknown はプロパティアクセスが型エラーになる
const val: unknown = { name: "foo" };
val.name // Type Error: Property 'name' does not exist on type 'unknown'.
• unknown ≒ {} | null | undefined
• 型を絞り込んでからアクセスする必要がある
if (typeof val === "object" && 'name' in val) {
  console.log(val.name) // OK
}
#hatenaintern
!"



================================================================================
ページ 51
================================================================================
関数
既にサンプルでは何度も出てきているけど、引数や返り値の型の書き⽅のパターンたち紹介しておきます。
const f = (x: string): number => {
  return x.length
}
// 特にreturnをしない場合は返り値にvoidを指定する
const a: () => void = () => {
  console.log("a")
}
// オプショナルな引数はkeyに?を付ける
// 推論されるもので良いなら返り値の型は省略可
const b = (n?: number) => `${n}`
// Rest Parametersを受け取る場合はこういう感じ
const c = (...texts: string[]) => {
  return texts.join("|")
}
#hatenaintern
!"



================================================================================
ページ 52
================================================================================
型引数(Generics)
• 関数の返り値の型に関する制約を外から与えて、関数内部で利⽤できる。
• よくよく型定義などを⾒ると定義されていて利⽤可能だけど、気付いていないということもよくあ
る…
• TypeScript で querySelector メソッドを使うときに型引数を指定する - Hatena Developer Blog
const getJSON = <T>(url: string): Promise<T> => {
  // res.jsonはanyとならずに型引数で渡されたものと解釈される
  return fetch(url).then<T>((res) => res.json())
}
// ここでusersはUser[]になる
const users = await getJSON<User[]>("/api/users")
// ここでblogsはBlog[]になる
const blogs = await getJSON<Blog[]>("/api/blogs")
#hatenaintern
!"



================================================================================
ページ 53
================================================================================
続: 型引数
• extends を使うと指定した型/インターフェースを満たすように指定できる
• 型引数をそのまま関数の引数の型に使うことで静的解析時に呼び出し元の
引数の型から返り値を推論してくれる
const echo = <T extends string>(text: T): T => {
  return text
}
const a = echo("foo") // a の型は 'foo'
const str: string = "foo"
const b = echo(str) // b の型は 'string'
#hatenaintern
!"



================================================================================
ページ 54
================================================================================
TypeScript の書き⽅で困ったら?
• 公式ドキュメントの Handbook を読もう
• https://www.typescriptlang.org/docs/handbook/intro.html
• Playground で試し書きしよう
• https://www.typescriptlang.org/play
• 難しい型の書き⽅は Type Challenge に結構載ってる
• https://github.com/type-challenges/type-challenges
#hatenaintern
!"



================================================================================
ページ 55
================================================================================
React について(,-min)
#hatenaintern
!!



================================================================================
ページ 56
================================================================================
React とは
• ユーザインターフェースを構築するための View ライブラリ
• UI を関数で定義する
• 「仮想 DOM」と呼ばれるオブジェクトを返す
• React がその仮想 DOM を元に、実際の DOM を更新する
• JSX という HTML-like な拡張構⽂を使う
#hatenaintern
!"



================================================================================
ページ 57
================================================================================
#hatenaintern
!"



================================================================================
ページ 58
================================================================================
仮想(Virtual) DOM
• React の内部で持っている、実際の DOM!の対になる構造体
• 状態の変更を検知すると...
• 変更前後の仮想 DOM の差分を計算し、その差分だけを実際
の DOM に反映
https://ja.react.dev/learn/preserving-and-resetting-state
! Document Object Model の略。HTML や XML ⽂書の構造を操作するためのプログラミングインターフェイスのこと。
#hatenaintern
!"



================================================================================
ページ 59
================================================================================
React の何が嬉しい?
React <=> ⽣の JavaScript で書いた時を⽐較するとよくわかる。
#hatenaintern
!"



================================================================================
ページ 60
================================================================================
#hatenaintern
!"



================================================================================
ページ 61
================================================================================
#hatenaintern
!"



================================================================================
ページ 62
================================================================================
React の何が嬉しい?
• DOM をどう更新するかを意識しなくて済む
• 完成形の仮想 DOM を返せば、React がいい感じに更新してくれる
• DOM の状態更新を簡潔に書ける
• id=... を付けて、 getElementById で要素を取ってきて...が不要に
• value={newTodo} と書くだけで OK
• マークアップとロジックを近くに置ける
• 関連するものが近くにあることで、認知負荷が下がる (コロケーション!")
• 1つの関数にまとまってるので、テストもしやすい
!" 関連するリソース同⼠を近くに置いておくことで、様々な負荷を軽減するという考え⽅。https://www.mizdra.net/entry/TUTT/VT/VV/TUWXYU を参照。
#hatenaintern
!"



================================================================================
ページ 63
================================================================================
React の書き⽅‧読み⽅
#hatenaintern
!"



================================================================================
ページ 64
================================================================================
JSX
• JavaScript に HTML っぽい記法を追加した拡張構⽂
• .jsx/.tsx という拡張⼦の中で書ける
<h1 className="hello">My name is Clementine!</h1>
• HTML の属性名ではなく、キャメルケースの命名規則を使⽤ !!
• class は className と記述される
• これは class が JavaScript において予約語であるため !"
!" https://github.com/facebook/react/issues/45676#issuecomment-;<4=>7;?5
!! aria-* や data-* 属性は例外です。
#hatenaintern
!"



================================================================================
ページ 65
================================================================================
関数コンポーネントとクラスコンポーネント
React ではコンポーネントの書き⽅が 2 種類あります。
<HelloMessage name="hatena" />
関数コンポーネント
const HelloMessage = ({ name }) => {
  return <div>Hello {name}</div>
}
クラスコンポーネント
class HelloMessage extends React.Component {
  render() {
    return <div>Hello {this.props.name}</div>
  }
}
#hatenaintern
!"



================================================================================
ページ 66
================================================================================
関数コンポーネントとクラスコンポーネント
• 基本的にはどちらも同じことができる
• 関数コンポーネントのほうがシンプルで、書きやすい
• 公式ドキュメントでも関数コンポーネントが推奨されてる
• 関数コンポーネントを使おう
• ただし、⼀部 API がクラスコンポーネントでしか使えない
• Error Boundary 関連の API など
• そういう時だけ、クラスコンポーネントを使うと良い
#hatenaintern
!!



================================================================================
ページ 67
================================================================================
Function Component と TypeScript
• ⾊々な書き⽅がある
• arrow function or function 宣⾔
• type alias で Props を定義する or inline で書く !"
• React.FC<Props> を使う or 使わない(型推論に任せる) !#
• どう書くかは好みで良いと思う
type Props = { name: string }
const Welcome: React.FC<Props> = ({ name }) => {
  return <h1>Welcome {name}</h1>
}
function Welcome({ name }: { name: string }) {
  return <h1>Welcome {name}</h1>
}
!" React.FC<Props> を使うと、React Component として不正なundefinedを返すことをコンパイル時に防⽌できます
!" interface Props { name: string } と書くパターンもある。微妙に挙動は違うが、Props の定義にはどちらを使ってもほぼ同じ。
#hatenaintern
!"



================================================================================
ページ 68
================================================================================
Props と State
• React Component には値を持つ⽅法が⼤きく 2 つある
• 関数の引数として受け取るPropsと内部状態を保持するState
#hatenaintern
!"



================================================================================
ページ 69
================================================================================
Props を渡す/受け取る
• 受け取る側は関数の第 1 引数でオブジェクトとして受け取る
type Props = { name: string }
const Welcome: React.FC<Props> = ({ name }) => {
  return <h1>Welcome {name}</h1>
}
• 渡す側(親側)は JSX の属性値の記法で渡す
<Welcome name="John" />
// <h1>Welcome John</h1>
#hatenaintern
!"



================================================================================
ページ 70
================================================================================
Hooks
https://ja.react.dev/learn/state-a-components-
memory#meet-your-ﬁrst-hook によると...
フックを使うことで、さまざまな React の機能に「接続 (hook 
into)」して使⽤することができます。
Hook を使うことで、⾊々なことができるようになります。
#hatenaintern
!"



================================================================================
ページ 71
================================================================================
例: useState
• コンポーネントに状態を持
たせるための Hook
const Counter = () => {
  const [count, setCount] = useState(0)
  const increaseCount = ()
    => setCount((prevCount) => prevCount + 1)
  return (
    <div>
      カウント: {count}
      <button onClick={increaseCount}>カウント</button>
    </div>
  )
}
#hatenaintern
!"



================================================================================
ページ 72
================================================================================
Hooks の掟
フックのルール ‒ React
• 名前はuseから始める
• トップレベルで呼ぶ !"
• ifの中などで呼ばない
• early return する前に必ず呼ぶ
これらはeslint-plugin-react-hooksで検出してくれるように出来る
!" ただし React *+ で導⼊された use は、例外的に条件分岐の中で呼び出せます
#hatenaintern
!"



================================================================================
ページ 73
================================================================================
代表的な組み込み Hooks の紹介
#hatenaintern
!"



================================================================================
ページ 74
================================================================================
useState
• useState(initial)で初期値を渡す
• 返り値はタプル
• 1 つ⽬が現在の値で、2 つ⽬が setter
• setter を呼ぶと内部状態が更新されたことが React に通知される
• 仮想 DOM の再⽣成 !"、⽐較、レンダリングの更新が⾏われる
• 推論できないものを型指定したい場合は型引数を⽤いることが出来る
const [count, setCount] = useState(0)
const [color, setColor] = useState<Color>("red")
!" React によって関数コンポーネント⾃体が再実⾏され、その返り値が新しい仮想 DOM となります
#hatenaintern
!"



================================================================================
ページ 75
================================================================================
useStateの setter について
• 新しい値を渡す
const [color, setColor] = useState<Color>("red")
const change2Blue = () => setColor("blue")
• 直前の値を利⽤して新しい値を決定する
const [count, setCount] = useState(0)
const increaseCount = () => setCount((prevCount) => prevCount + 1)
#hatenaintern
!"



================================================================================
ページ 76
================================================================================
useEffect
• 外部システムに接続し、同期させるための Hook
• 例えば 
• API からデータを取得する
• ⽣の DOM API を使う
• アニメーションさせる
• React の外のシステムと接続したい時に使う
#hatenaintern
!"



================================================================================
ページ 77
================================================================================
setInterval でタイマーと同期する
const Timer = () => {
  const [duration, setDuration] = useState(1000)
  useEffect(() => {
    setInterval(() => {
      console.log("tick")
    }, duration)
  }, [])
  return (
    <div>
      <input type="number" value={duration} onChange={(e) => setDuration(+e.target.value)} />
      <div>間隔: {duration}</div>
    </div>
  )
}
これで Component のマウント 12 時に setInterval が呼ばれ、指定した間隔で tick が出⼒され
ます。
!" Component に対応した DOM が挿⼊(初回描画)されることをマウント(mount)、その DOM が削除されることをアンマウント(unmount)と呼びます
#hatenaintern
!!



================================================================================
ページ 78
================================================================================
useEffectと依存配列
• デフォルトでは、エフェクトはレンダー時に毎回実⾏される
• しかし、それが望ましくない場合も
• useEffect の第 2 引数 (依存配列) で、不必要な実⾏を防げる
• useEffect(任意の処理関数, [])
• マウント時にだけ副作⽤を実⾏
• useEffect(任意の処理関数, [val1, val2])
• val1 や val2 のいずれかが変更されたときにエフェクトを実⾏
#hatenaintern
!"



================================================================================
ページ 79
================================================================================
カウンターのカウントが変わるたびに、サーバーにメトリクスを送る例
const Counter = () => {
  const [name, setName] = useState("インターンに参加した回数")
  const [count, setCount] = useState(0)
  useEffect(() => {
    fetch(`/api/user-metrics?count=${count}`)
  }, [count])
  return (
    <>
      <input type="text" value={name} onChange={(e) => setName(e.target.value)} />
      <button onClick={() => setCount(c => c + 1)}>
        Increment
      </button>
      <div>{count}</div>
    </>
  )
}
name が変わっても、メトリクスは送られない。
#hatenaintern
!"



================================================================================
ページ 80
================================================================================
依存配列は⾃分で選ぶものではない
• 基本的には、エフェクトから参照されてる値を全て依存配列に⼊れる !" !#
• ESLint + eslint-plugin-react-hooks を使うと、⼊れ忘れてる値を警告してくれる
• この警告に従うのがセオリー
useEffect(() => {
  fetch(`/api/user-metrics?count=${count}`)
}, [])
// ^^ React Hook useEffect has a missing dependency: 'count'.
//    Either include it or remove the dependency array.
ESLint + eslint-plugin-react-hooks は後からの導⼊が⾯倒なので、初⼿で必ず導⼊しましょう。
!" 全ての参照値を依存配列に⼊れるといっても、「この値が変わる度に実⾏されると困る」ケースもあります。その場合はエフェクトを分割するなどがセオリーとされてます。
!" ref やコンポーネントの外で定義された関数などは不変なので、依存配列に⼊れなくて良いという例外的なルールがあったりします。
#hatenaintern
!"



================================================================================
ページ 81
================================================================================
useEffect とクリーンアップ
• 実はエフェクトから関数を返せる
• クリーンアップ関数 と呼ばれる
• 次のエフェクトが実⾏される前!"に呼ばれる
• これを利⽤すると副作⽤のクリーンアップが出来る
前回の setInterval の例をクリーンアップを追加すると以下のようになる
useEffect(() => {
  const id = setInterval(() => {
    console.log("tick")
  }, duration);
  return () => {
    // clearInterval でタイマーを停止する関数
    clearInterval(id)
  }
}, [duration])
!" 空配列を指定している場合などはアンマウント時にも実⾏される
#hatenaintern
!"



================================================================================
ページ 82
================================================================================
独⾃フック(Custom Hook)
• 内部で他の Hook を呼び出す関数で、 use から名前が始まるもののこと
• 複数の Hooks を組み合わせたり、Component の振る舞いを共通化して、1 つの関数に切り出すときなどに利⽤する
const useUserStatus = ({ userId }) => {
  const [status, setStatus] = useState(null)
  useEffect(() => {
    const handler = (user) => {
      setStatus(user.status)
    }
    Api.subscribe(userId, handler)
    return () => Api.unsubscribe(userId, handler)
  })
  return status
}
function SomeComponent({ userId }) {
  const status = useUserStatus({ userId })
  return <div>{status}</div>
}
#hatenaintern
!"



================================================================================
ページ 83
================================================================================
独⾃フックについての Tips
• 独⾃フックに切り出すことで、その部分をテストできる
• 独⾃フックの中では useMemo、useEffect、useCallback を積極
的に使う
• パフォーマンス最適化のためになる
• 参考: useCallback はとにかく使え！ 特にカスタムフックで
は - uhyo/blog
#hatenaintern
!"



================================================================================
ページ 84
================================================================================
標準化について (*min)
#hatenaintern
!"



================================================================================
ページ 85
================================================================================
標準化について
ブラウザで動く⾔語や API などはそれぞれ以下のような仕様で標準化されてます。
標準化団体
策定している仕様
WHATWG
HTML Living Standard[^AB]
DOM Living Standard
Fetch Living Standard
WJC
CSS Speciﬁcations
WCAG
TCJB
ECMAScript
Internationalization API
IETF
RFC xxx
#hatenaintern
!"



================================================================================
ページ 86
================================================================================
こうした仕様を知ることは重要
• API の正しい振る舞いを定義しているのは仕様
• 世の中に公開されている情報が数多くあるが...
• その情報の正しさを最終的に保証するための情報源が仕様
• 例えば JavaScript や CSS などの振る舞いがブラウザ間で異なる場合...
• その時に正しさを保証してくれるのは仕様である
• 実際、開発をしてると仕様とブラウザの差異に遭遇することも !"
!" ウェブブラウザにバグ報告をするときにやること - ぱすたけ⽇記
#hatenaintern
!"



================================================================================
ページ 87
================================================================================
ECMAScript について
• JavaScript の標準仕様は ECMAScript と呼ばれる
• Ecma International!!の中の Technical Committee DE（TCDE）という技術委員会により策
定
• 現在の仕様はhttps://github.com/tcDE/ecma]^]
• 常に最新版が公開され続けてる
• こういう形式を Living Standard と呼ぶ
• 毎年 6 ⽉頃に ECMAScript ]v]w のようなタグが打たれる
• バージョン番号が付与したものも公開される
!! Ecma International は C#などの標準化作業も⾏っている
#hatenaintern
!"



================================================================================
ページ 88
================================================================================
ECMAScript の Stage
• ECMAScript には⾃由に提案(proposal)を出せる
• GitHub 上で proposal が公開される
• issue、PR、TCMN のミーティングなどでの議論を経て、
Stage が上がる &'
• Stage ] になると仕様に取り込まれる
!" 責任者であるチャンピオンのステージを進めたいという意思も必要
#hatenaintern
!!



================================================================================
ページ 89
================================================================================
Stage の詳細
https://jsprimer.net/basic/ecmascript/ より引⽤‧⼀部改変。
ステージ
ステージの概要
(
アイデアの段階
.
機能提案の段階
3
機能の仕様書ドラフトを作成した状態
3.C
仕様がある程度固まってて、実装前にプロトタイプなどを作って実験する段
階
Y
仕様としては完成しており、ブラウザの実装やフィードバックを求める段階
i
仕様策定が完了し、2 つ以上の実装!"!#が存在している状態
!" 主に Stage) 以前時点での実装などはその後の仕様変更などの可能性もあるので、ブラウザの開発者向けフラグを有効にしているときだけ使えたり、preﬁx を付けた名前で API が提供され
ることもある。それらも実装として許容されるなどの緩さはある。
!" V", SpiderMonkey, Hermes といった JavaScript エンジンなどに実装されてることが要求されてる。
#hatenaintern
!"



================================================================================
ページ 90
================================================================================
ECMAScript の仕様と実装
• Stage ( になる前に、ブラウザなどに実装される
• 実装上の困難さ、使⽤上や仕様の問題などを確認するため
• その過程で仕様にフィードバックができたり、有⽤性を⽰せる
• Stage ( になる前に、polyﬁll や Babel によるトランスパイルが
サポートされることも
• ブラウザに実装するより前に、ユーザに試してもらえる
#hatenaintern
!"



================================================================================
ページ 91
================================================================================
ECMAScript は全てが Open
• 誰でもプロポーザルを出せるし、読めるし、議論できる
• 興味のある提案があったら覗いたり、使ってみよう
• フィードバックすれば、JavaScript をより良くできる !"
!" ECMAScript のプロポーザルは多くの場合、その提案が「どのようなモチベーションがあるのか」、「どのような問題を解決するのか」、「どのようなユースケースがあるのか」などが記
されているので、その有⽤性などを⽰すことも貢献に繋がります。
#hatenaintern
!"



================================================================================
ページ 92
================================================================================
JavaScript API を策定する仕様
実は、JavaScript の全てが ECMAScript で策定されてる訳では無いです。
仕様
策定している内容
ECMAScript (TC89)
JavaScript の構⽂や基本的な API
DOM Living Standard (WHATWG)
document.querySelector などの DOM API
Fetch Living Standard (WHATWG)
fetch API
Internationalization API (TC89)
Intl.DateTimeFormat などの国際化 API
#hatenaintern
!"



================================================================================
ページ 93
================================================================================
ブラウザベンダと WHATWG 仕様
• Google は HTML や DOM に関わる API!"の提案を数多く⾏ってる
• Chrome には取り込まれるが、Apple や Moziila の反対により、標準化されないことも
• Chrome の仕様トラッカー: Chrome Platform Status
• Apple や Mozilla それぞれから⽴場を表明するウェブサイトがある
• Mozilla Speciﬁcation Positions
• Standards Positions | Webkit
• WÄC 内の Web Incubator Community Groupで様々な提案が作成‧議論されている
!" https://scrapbox.io/pastak-pub/⾯⽩ WebAPI100 連発 で⾊々紹介しています
#hatenaintern
!"



================================================================================
ページ 94
================================================================================
ビルドツールについて (,min)
#hatenaintern
!"



================================================================================
ページ 95
================================================================================
ビルドツールについて
• TypeScript がそのまま実⾏されることは少ない
• 最適化などの様々な都合により、⼤抵はコードを変換してから
実⾏する
• その変換に使われるツールを「ビルドツール」と呼ぶ
#hatenaintern
!"



================================================================================
ページ 96
================================================================================
代表的なビルドツール ①
• .ts => .js へ変換するツール
• .ts は JavaScript ランタイムで直接実⾏できないので、変換が必要
• tsc, swc, esbuild など !"
• 古い ECMAScript バージョンへ変換 (downlevel) するツール
• 古いブラウザなどをサポートするために必要
• tsc, babel, swc, esbuild など
!" ブラウザ組み込みのページ遷移に代わって、JavaScript でページ遷移を⾏うこと。これにより、ページを完全に読み込み直すことなく、シームレスな遷移が可能になる。
#hatenaintern
!"



================================================================================
ページ 97
================================================================================
代表的なビルドツール ②
• JavaScript ファイルを結合するツール (bundler)
• ページアクセス直後のネットワークリクエストの数を減らすために必要
• webpack, rollup など
• CSS や画像ファイルなども bundle できる
• JavaScript ファイルを圧縮するツール (miniﬁer)
• ネットワーク転送量を減らすために必要
• terser など
#hatenaintern
!"



================================================================================
ページ 98
================================================================================
代表的なビルドツール ③
• 統合的なビルドツール
• 上記の機能をまとめて提供するツール
• next build/next dev, Vite など
• 内部的には swc や terser などを使ってる
• 基本的には、これを使うと良い
#hatenaintern
!"



================================================================================
ページ 99
================================================================================
統合的なビルドツールに備わってる機能
実は他にも⾊々な機能が備わってます。
• Watch ビルド
• ファイルの変更を監視して、変更があったら⾃動でリビルドする
• 開発サーバー
• localhost:3000 などで開発中のアプリケーションを配信してくれる
• Hot Module Replacement (HMR)
• リビルド結果をブラウザに開いているページに、リロードなしで反映する!"
!" ファイルの構成に基づいてルーティングすること。Next.js であれば app/user/page.tsx を作成すると /user にルーティングできるようになる仕組みのこと。
#hatenaintern
!!



================================================================================
ページ 100
================================================================================
Web フレームワークについて
• Web フレームワークと呼ばれるものもある
• Next.js, Remix, Nuxt.js, Astro, ...
• フロントエンド開発をすぐに始められるよう、⾊々組み込まれ
てる
#hatenaintern
!""



================================================================================
ページ 101
================================================================================
Web フレームワークが組み込んでるもの
• ビルドツールとその推奨設定
• いい感じの設定が組み込まれてて、ほぼ設定不要で使える
• ルーティング
• ページ遷移時にソフトナビゲーション !" したり、File-based routing !# をサポートしたり
• サーバーサイドレンダリング (SSR) $%
• Node.js サーバー上でコンポーネントをレンダーしてから HTML を返す技術
• SEO や初回表⽰の⾼速化に寄与する
• テストランナーの提供
• すぐにユニットテストやコンポーネントテストが書ける
!" 詳しくは https://speakerdeck.com/mizdra/react-server-components-noyi-wen-wojie-kiming-kasu?slide=BC を参照。
!" ファイルの構成に基づいてルーティングすること。Next.js であれば app/user/page.tsx を作成すると /user にルーティングできるようになる仕組みのこと。
!" ブラウザ組み込みのページ遷移に代わって、JavaScript でページ遷移を⾏うこと。これにより、ページを完全に読み込み直すことなく、シームレスな遷移が可能になる。
#hatenaintern
!"!



================================================================================
ページ 102
================================================================================
どれを使えば良いか
作りたいものの要件に応じて適切なものを選びましょう。
• React 使って SSR もしたい
• Next.js を使う
• React 使うけど SSR は不要で、SEO も気にしない
• Vite + React を使う
• Node.js 向けライブラリを作りたい
• tsc だけで⼗分
• .js をネットワーク経由で取得しないので、bundler/miniﬁer は不要
それぞれのツールの役割や⽬的を知っていれば、⾃ずと分かるはずです。
#hatenaintern
!"#



================================================================================
ページ 103
================================================================================
⼼構え的な話 ()m)
#hatenaintern
!"#



================================================================================
ページ 104
================================================================================
⼼構え的な話
• フロントエンドは、直接ユーザが触れる部分
• ユーザからの評価に直結する
• 良い UI を実装しよう
• ユーザビリティやパフォーマンス改善をちゃんとやる
• ユーザのことを考える
#hatenaintern
!"#



================================================================================
ページ 105
================================================================================
⼼構え的な話
アクセシビリティに気を使いましょう
• 具体的な配慮点
• キーボードで操作できたり
• 機械翻訳できたり
• ⽂字サイズを⾃由に変えたり
• 障害者の⽅のため、だけではない
• 健常者も⽂字サイズ変えたいことはある
• 皆のためにもなる
#hatenaintern
!"#



================================================================================
ページ 106
================================================================================
⼼構え的な話 (時間があれば)
⾊々な職種の⽅と協⼒しよう。
• デザイナーと協⼒する
• デザイナーさんの⼒だけでは実現が難しいものを、エンジニアがサポートしたり
• アニメーションの PoC 作ってみるとか
• プランナーと協⼒する
• UI の実装をしているからこそ、ユーザビリティの改善点が⾒つかるはず
• エンジニア視点で新機能の提案してみるとか
協⼒して、より良いものを作っていきましょう。
#hatenaintern
!"#



================================================================================
ページ 107
================================================================================
お疲れさまでした
• JavaScript/TypeScript/React についてざっと紹介しました
• これだけで完璧に理解した！とならないと思いますが...
• 開発に⼊るため‧学ぶための⾜がかりになったはず
• JavaScript やフロントエンドの世界は更に広がっています
• ブラウザを介して、ここまで多くのユーザの⽬に触れる分野は中々あ
りません
• 是⾮フロントエンドの世界を楽しんでください
#hatenaintern
!"#



================================================================================
ページ 108
================================================================================
付録
本編に⼊り切らなかった踏み込んだ補⾜や解説について書いてい
ます。興味があれば読んでください的なコーナーです。
#hatenaintern
!"#



================================================================================
ページ 109
================================================================================
|| と ?? の違い
• ?? は⽐較的新しい構⽂で、昔のエンジンで動かなかった
• 古い JavaScript コードでは、代わりに || が使われがち
• || は左辺が Falsy (偽とみなせるもの) なら右辺の値を返す
• Falsy な値の例: false/null/undefined/NaN/0/'' (空⽂字)
const price1 = 0 || 100; // 100
const price2 = 0 ?? 100; // 0
• 挙動が難しいので、?? を使うのがオススメ
#hatenaintern
!"#



================================================================================
ページ 110
================================================================================
Arrow Function に置き換え出来ないケース
• function を使ってコンストラクタ関数にしている(new している)
• arguments を参照している
• this を参照している
• このケースについて解説
#hatenaintern
!!"



================================================================================
ページ 111
================================================================================
Arrow Function と this
• Arrow Function と function xxx(){...} で this の扱いが異な
る
• このことによって単純な置き換えが不可な場合がある
#hatenaintern
!!!



================================================================================
ページ 112
================================================================================
this のスコープの違いについて
• function だと呼び出し元のオブジェクトが this になる
const person = {
  name: "chris",
  say: function () {
    setTimeout(function () {
      console.log(`I'm ${this.name}`)
    }, 100)
  },
}
person.say() // I'm
• この場合は window.setTimeout(window は省略できる) からの呼び出しなので、 window 
になる
#hatenaintern
!!"



================================================================================
ページ 113
================================================================================
this のスコープの違いについて
• Arrow Function だとスコープが外と同じになる
const person = {
  name: "chris",
  say: function () {
    setTimeout(() => {
      console.log(`I'm ${this.name}`)
    }, 100)
  },
}
person.say() // I'm chris
#hatenaintern
!!"



================================================================================
ページ 114
================================================================================
useState の state を更新する際の注意
新しい値を渡すときの落とし⽳
const [count, setCount] = useState(0)
const increase = () => setCount(count + 1)
としてしまうと、
const incrementDouble = () => {
  increment()
  increment()
}
のようなものを作ったときに、incrementDouble を呼んでも 1 しか増えません。
#hatenaintern
!!"



================================================================================
ページ 115
================================================================================
関数内の変数スコープと useState
例えば、以下のようなコードがあった時:
const Component = () => {
  const [count, setCount] = useState(0)
  const increment = () => setCount(count + 1)
  const incrementDouble = () => {
    increment()
    increment()
  }
}
#hatenaintern
!!"



================================================================================
ページ 116
================================================================================
関数内の変数スコープと useState
これと同じ意味になる:
const Component = () => {
  const [count, setCount] = useState(0)
  const incrementDouble = () => {
    setCount(count + 1) // count = 0 の時、`setCount(1)` になる
    setCount(count + 1) // count = 0 の時、`setCount(1)` になる
  }
}
#hatenaintern
!!"



================================================================================
ページ 117
================================================================================
setter に関数を渡すと良い
setCount((prevCount) => prevCount + 1) とすると、期待通りになる
const Component = () => {
  const [count, setCount] = useState(0)
  const increment = () => setCount((prevCount) => prevCount + 1)
  const incrementDouble = () => {
    increment() // count = 0 の時、`setCount(0 + 1)` になる
    increment() // count = 1 の時、`setCount(1 + 1)` になる
  }
}
更新後の state の値が更新前の値に依存している場合は、関数を渡す形式を使いましょ
う。
#hatenaintern
!!"



================================================================================
ページ 118
================================================================================
Hooks の依存配列の変更検知について
• 依存配列の値が変わったかは Object.is で検証される
• 同じ内容のオブジェクトでも、参照が異なると変わったと認識さ
れる
console.log(Object.is("foo", "foo")) // true
console.log(Object.is({ prop: "foo" }, { prop: "foo" })) // false
const objA = { prop: "foo" }
const objB = objA
console.log(Object.is(objA, objB)) // true
#hatenaintern
!!"



================================================================================
ページ 119
================================================================================
依存配列にオブジェクトを⼊れるケースについて
function Component() {
  const config = { theme: "sports" }
  useEffect(() => {
    loadConfig(config).then(() => {})
  }, [config])
}
のような場合にはレンダリングの度に、config が再⽣成される。よっ
て、異なる値として認識されてしまい、毎回エフェクトが実⾏されて
しまう。LM
!" このような例の場合は依存に [config.theme] という⾵に値を書いてしまっても良いが、依存するオブジェクトについて知っている必要があるので難しい。
#hatenaintern
!!"



================================================================================
ページ 120
================================================================================
シンプルな回避策
• ⼀番簡単な回避策は Component の外で初期化すること
const config = { theme: "sports" }
function Component() {
  useEffect(() => {
    loadConfig(config).then(() => {})
  }, [config])
}
• ⼀⽅で、Props を利⽤してオブジェクトを⽣成してる場合は採⽤でき
ない
#hatenaintern
!"#



================================================================================
ページ 121
================================================================================
useMemo を使った回避策
• useMemo は React に組み込まれている Hooks で、値のメモ化!"ができる
• これで過度なエフェクトの再実⾏を防げる
function Component({ theme }) {
  const config = useMemo(() => ({ theme }), [theme])
  useEffect(() => {
    loadConfig(config).then(() => {})
  }, [config])
}
!" メモ化はパフォーマンス改善のために計算結果をキャッシュしたりすること
#hatenaintern
!"!



================================================================================
ページ 122
================================================================================
useCallback で関数をメモ化する
• 実は関数も実態はオブジェクト
• コンポーネント内で関数宣⾔すると、毎回再⽣成されてしま
う
• 値同様に関数をメモ化したい場合は useCallback を利⽤する
const handler = useCallback((val) => alert(val), [])
useEffect(() => {
  Api.notification.subscribe(handler)
}, [handler])
#hatenaintern
!""



================================================================================
ページ 123
================================================================================
React Component 内で DOM にアクセスする
• React に組み込まれている、参照を保持できる ref オブジェクトを作成する useRef を使う
• ref オブジェクトは current プロパティに現在の値を持っている
const textInput = useRef(null)
const submit = (e) => {
  e.preventDefault()
  if (textInput.current.value.length < 100)
    return alert("101文字以上が必要です")
  createPost({ body: textInput.current.value })
}
return (
  <form onSubmit={submit}>
    <input type="text" ref={textInput} />
  </form>
)
#hatenaintern
!"#



================================================================================
ページ 124
================================================================================
DOM へのアクセスを避ける⽅が良い
• DOM に直接アクセスすると、React の制御外のところで値が取得されたり変更されることに
• ライブラリの都合などで本当に必要なときのみにしておくと良い
const [text, setText] = useState("")
const submit = (e) => {
  e.preventDefault()
  if (text < 100) return alert("101文字以上が必要です")
  createPost({ body: text })
}
return (
  <form onSubmit={submit}>
    <input type="text" onChange={(e) => setText(e.target.value)} />
  </form>
)
#hatenaintern
!"#

