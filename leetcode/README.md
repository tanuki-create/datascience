# LeetCode Problems Collection

This directory contains 100 carefully selected LeetCode problems with detailed solutions, organized by difficulty level.

## Problem Categories

### Easy Problems (1-40)
- Basic algorithms and data structures
- Array manipulation
- String processing
- Simple mathematical problems

### Medium Problems (41-80)
- Advanced data structures
- Dynamic programming
- Graph algorithms
- Tree traversal

### Hard Problems (81-100)
- Complex algorithms
- Advanced dynamic programming
- Graph theory
- System design concepts

## Directory Structure

```
leetcode/
â”œâ”€â”€ easy/           # Problems 1-40
â”œâ”€â”€ medium/         # Problems 41-80
â”œâ”€â”€ hard/           # Problems 81-100
â””â”€â”€ README.md       # This file
```

## How to Use

Each problem directory contains:
- `problem.md` - Problem description and examples
- `solution.py` - Python solution with detailed comments
- `test_cases.py` - Test cases to verify the solution

## Problem Index

### Easy (1-40)
1. Two Sum
2. Valid Parentheses
3. Maximum Subarray
4. Best Time to Buy and Sell Stock
5. Climbing Stairs
6. House Robber
7. Valid Anagram
8. Missing Number
9. Single Number
10. Reverse Integer
11. Palindrome Number
12. Roman to Integer
13. Longest Common Prefix
14. Valid Palindrome
15. Remove Duplicates from Sorted Array
16. Plus One
17. Merge Sorted Array
18. Convert Sorted Array to Binary Search Tree
19. Symmetric Tree
20. Maximum Depth of Binary Tree
21. Same Tree
22. Invert Binary Tree
23. Path Sum
24. Minimum Depth of Binary Tree
25. Balanced Binary Tree
26. Convert Sorted List to Binary Search Tree
27. Binary Tree Level Order Traversal
28. Binary Tree Zigzag Level Order Traversal
29. Binary Tree Right Side View
30. Count Complete Tree Nodes
31. Sum of Left Leaves
32. Find Mode in Binary Search Tree
33. Diameter of Binary Tree
34. Binary Tree Tilt
35. Subtree of Another Tree
36. Binary Tree Paths
37. Sum Root to Leaf Numbers
38. Path Sum II
39. Path Sum III
40. Binary Tree Maximum Path Sum

### Medium (41-80)
41. Add Two Numbers
42. Longest Substring Without Repeating Characters
43. Longest Palindromic Substring
44. ZigZag Conversion
45. String to Integer (atoi)
46. Container With Most Water
47. Integer to Roman
48. 3Sum
49. 3Sum Closest
50. Letter Combinations of a Phone Number
51. Remove Nth Node From End of List
52. Generate Parentheses
53. Swap Nodes in Pairs
54. Divide Two Integers
55. Next Permutation
56. Search in Rotated Sorted Array
57. Find First and Last Position of Element in Sorted Array
58. Valid Sudoku
59. Combination Sum
60. Combination Sum II
61. First Missing Positive
62. Trapping Rain Water
63. Multiply Strings
64. Wildcard Matching
65. Jump Game
66. Permutations
67. Permutations II
68. Rotate Image
69. Group Anagrams
70. Pow(x, n)
71. Spiral Matrix
72. Jump Game II
73. Merge Intervals
74. Insert Interval
75. Length of Last Word
76. Spiral Matrix II
77. Permutation Sequence
78. Rotate List
79. Unique Paths
80. Unique Paths II

### Hard (81-100)
81. Minimum Window Substring
82. Substring with Concatenation of All Words
83. Minimum Path Sum
84. Unique Binary Search Trees
85. Unique Binary Search Trees II
86. Interleaving String
87. Validate Binary Search Tree
88. Recover Binary Search Tree
89. Binary Tree Inorder Traversal
90. Binary Tree Preorder Traversal
91. Binary Tree Postorder Traversal
92. Binary Tree Level Order Traversal II
93. Convert Sorted Array to Binary Search Tree
94. Flatten Binary Tree to Linked List
95. Populating Next Right Pointers in Each Node
96. Populating Next Right Pointers in Each Node II
97. Binary Tree Maximum Path Sum
98. Sum Root to Leaf Numbers
99. Path Sum II
100. Path Sum III

## Tips for Solving

1. **Read the problem carefully** - Understand the input/output format
2. **Think about edge cases** - Empty inputs, single elements, etc.
3. **Start with brute force** - Then optimize
4. **Use appropriate data structures** - Hash maps, stacks, queues, etc.
5. **Consider time and space complexity** - Aim for optimal solutions

## Time Complexity Guidelines

- **Easy**: O(n) to O(nÂ²) time complexity
- **Medium**: O(n log n) to O(nÂ²) time complexity  
- **Hard**: O(n) to O(nÂ³) time complexity, sometimes exponential

Happy coding! ðŸš€
